diff --git a/detect-renamed-and-clone-dest.diff b/detect-renamed-and-clone-dest.diff
new file mode 100644
index 0000000..b6a78a7
--- /dev/null
+++ b/detect-renamed-and-clone-dest.diff
@@ -0,0 +1,13194 @@
+diff --git a/Makefile.in b/Makefile.in
+index a1253e5d..b2e9ecfe 100644
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -53,7 +53,7 @@ popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
+ 	popt/popthelp.o popt/poptparse.o
+ OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) @BUILD_ZLIB@ @BUILD_POPT@
+ 
+-TLS_OBJ = tls.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o @BUILD_POPT@
++TLS_OBJ = tls.o syscall.o util1.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o lib/wildmatch.o @BUILD_POPT@
+ 
+ # Programs we must have to run the test cases
+ CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
+@@ -170,7 +170,7 @@ getgroups$(EXEEXT): getgroups.o
+ getfsdev$(EXEEXT): getfsdev.o
+ 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)
+ 
+-TRIMSLASH_OBJ = trimslash.o syscall.o util2.o t_stub.o lib/compat.o lib/snprintf.o
++TRIMSLASH_OBJ = trimslash.o syscall.o util1.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o
+ trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
+ 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
+ 
+diff --git a/backup.c b/backup.c
+index 686cb297..c139c0a3 100644
+--- a/backup.c
++++ b/backup.c
+@@ -162,7 +162,7 @@ char *get_backup_name(const char *fname)
+ 			int ret;
+ 			if (backup_dir_len > 1)
+ 				backup_dir_buf[backup_dir_len-1] = '\0';
+-			ret = make_path(backup_dir_buf, 0);
++			ret = make_path(backup_dir_buf, ACCESSPERMS, 0);
+ 			if (backup_dir_len > 1)
+ 				backup_dir_buf[backup_dir_len-1] = '/';
+ 			if (ret < 0)
+diff --git a/compat.c b/compat.c
+index 4ce8c6d0..72e71594 100644
+--- a/compat.c
++++ b/compat.c
+@@ -40,6 +40,7 @@ extern int checksum_seed;
+ extern int basis_dir_cnt;
+ extern int prune_empty_dirs;
+ extern int protocol_version;
++extern int detect_renamed;
+ extern int protect_args;
+ extern int preserve_uid;
+ extern int preserve_gid;
+@@ -172,6 +173,7 @@ void set_allow_inc_recurse(void)
+ 		allow_inc_recurse = 0;
+ 	else if (!am_sender
+ 	 && (delete_before || delete_after
++	  || detect_renamed
+ 	  || delay_updates || prune_empty_dirs))
+ 		allow_inc_recurse = 0;
+ 	else if (am_server && strchr(client_info, 'i') == NULL)
+diff --git a/delete.c b/delete.c
+index 89c1f8d6..464f12db 100644
+--- a/delete.c
++++ b/delete.c
+@@ -25,6 +25,7 @@
+ extern int am_root;
+ extern int make_backups;
+ extern int max_delete;
++extern int detect_renamed;
+ extern char *backup_dir;
+ extern char *backup_suffix;
+ extern int backup_suffix_len;
+@@ -44,6 +45,8 @@ static inline int is_backup_file(char *fn)
+  * its contents, otherwise just checks for content.  Returns DR_SUCCESS or
+  * DR_NOT_EMPTY.  Note that fname must point to a MAXPATHLEN buffer!  (The
+  * buffer is used for recursion, but returned unchanged.)
++ *
++ * Note: --detect-rename may use this routine with DEL_NO_DELETIONS set!
+  */
+ static enum delret delete_dir_contents(char *fname, uint16 flags)
+ {
+@@ -63,7 +66,9 @@ static enum delret delete_dir_contents(char *fname, uint16 flags)
+ 	save_filters = push_local_filters(fname, dlen);
+ 
+ 	non_perishable_cnt = 0;
++	file_extra_cnt += SUM_EXTRA_CNT;
+ 	dirlist = get_dirlist(fname, dlen, 0);
++	file_extra_cnt -= SUM_EXTRA_CNT;
+ 	ret = non_perishable_cnt ? DR_NOT_EMPTY : DR_SUCCESS;
+ 
+ 	if (!dirlist->used)
+@@ -103,7 +108,8 @@ static enum delret delete_dir_contents(char *fname, uint16 flags)
+ 		if (S_ISDIR(fp->mode)) {
+ 			if (delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
+ 				ret = DR_NOT_EMPTY;
+-		}
++		} else if (detect_renamed && S_ISREG(fp->mode))
++			look_for_rename(fp, fname);
+ 		if (delete_item(fname, fp->mode, flags) != DR_SUCCESS)
+ 			ret = DR_NOT_EMPTY;
+ 	}
+@@ -126,6 +132,8 @@ static enum delret delete_dir_contents(char *fname, uint16 flags)
+  *
+  * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's
+  * a directory! (The buffer is used for recursion, but returned unchanged.)
++ *
++ * Also note: --detect-rename may use this routine with DEL_NO_DELETIONS set!
+  */
+ enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
+ {
+@@ -153,6 +161,9 @@ enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
+ 		/* OK: try to delete the directory. */
+ 	}
+ 
++	if (flags & DEL_NO_DELETIONS)
++		return DR_SUCCESS;
++
+ 	if (!(flags & DEL_MAKE_ROOM) && max_delete >= 0 && stats.deleted_files >= max_delete) {
+ 		skipped_deletes++;
+ 		return DR_AT_LIMIT;
+diff --git a/flist.c b/flist.c
+index 464d556e..54c2df77 100644
+--- a/flist.c
++++ b/flist.c
+@@ -64,6 +64,7 @@ extern int non_perishable_cnt;
+ extern int prune_empty_dirs;
+ extern int copy_links;
+ extern int copy_unsafe_links;
++extern int detect_renamed;
+ extern int protocol_version;
+ extern int sanitize_paths;
+ extern int munge_symlinks;
+@@ -132,6 +133,8 @@ static int64 tmp_dev = -1, tmp_ino;
+ #endif
+ static char tmp_sum[MAX_DIGEST_LEN];
+ 
++struct file_list the_fattr_list;
++
+ static char empty_sum[MAX_DIGEST_LEN];
+ static int flist_count_offset; /* for --delete --progress */
+ static int show_filelist_progress;
+@@ -280,6 +283,45 @@ static inline int is_excluded(const char *fname, int is_dir, int filter_level)
+ 	return name_is_excluded(fname, is_dir ? NAME_IS_DIR : NAME_IS_FILE, filter_level);
+ }
+ 
++static int fattr_compare(struct file_struct **file1, struct file_struct **file2)
++{
++	struct file_struct *f1 = *file1;
++	struct file_struct *f2 = *file2;
++	int64 len1 = F_LENGTH(f1), len2 = F_LENGTH(f2);
++	int diff;
++
++	if (!f1->basename || !S_ISREG(f1->mode) || !len1) {
++		if (!f2->basename || !S_ISREG(f2->mode) || !len2)
++			return 0;
++		return 1;
++	}
++	if (!f2->basename || !S_ISREG(f2->mode) || !len2)
++		return -1;
++
++	/* Don't use diff for values that are longer than an int. */
++	if (len1 != len2)
++		return len1 < len2 ? -1 : 1;
++
++	if (always_checksum) {
++		diff = u_memcmp(F_SUM(f1), F_SUM(f2), flist_csum_len);
++		if (diff)
++			return diff;
++	} else if (f1->modtime != f2->modtime)
++		return f1->modtime < f2->modtime ? -1 : 1;
++
++	diff = u_strcmp(f1->basename, f2->basename);
++	if (diff)
++		return diff;
++
++	if (f1->dirname == f2->dirname)
++		return 0;
++	if (!f1->dirname)
++		return -1;
++	if (!f2->dirname)
++		return 1;
++	return u_strcmp(f1->dirname, f2->dirname);
++}
++
+ static void send_directory(int f, struct file_list *flist,
+ 			   char *fbuf, int len, int flags);
+ 
+@@ -2722,6 +2764,23 @@ struct file_list *recv_file_list(int f, int dir_ndx)
+ 	 * for a non-relative transfer in recv_file_entry(). */
+ 	flist_sort_and_clean(flist, relative_paths);
+ 
++	if (detect_renamed) {
++		int j = flist->used;
++		the_fattr_list.used = j;
++		the_fattr_list.files = new_array(struct file_struct *, j);
++		memcpy(the_fattr_list.files, flist->files,
++		       j * sizeof (struct file_struct *));
++		qsort(the_fattr_list.files, j,
++		      sizeof the_fattr_list.files[0], (int (*)())fattr_compare);
++		the_fattr_list.low = 0;
++		while (j-- > 0) {
++			struct file_struct *fp = the_fattr_list.files[j];
++			if (fp->basename && S_ISREG(fp->mode) && F_LENGTH(fp))
++				break;
++		}
++		the_fattr_list.high = j;
++	}
++
+ 	if (protocol_version < 30) {
+ 		/* Recv the io_error flag */
+ 		int err = read_int(f);
+diff --git a/generator.c b/generator.c
+index 110db28f..d549a8ce 100644
+--- a/generator.c
++++ b/generator.c
+@@ -81,6 +81,7 @@ extern int always_checksum;
+ extern int flist_csum_len;
+ extern char *partial_dir;
+ extern int alt_dest_type;
++extern int detect_renamed;
+ extern int whole_file;
+ extern int list_only;
+ extern int read_batch;
+@@ -99,11 +100,13 @@ extern char *tmpdir;
+ extern char *basis_dir[MAX_BASIS_DIRS+1];
+ extern struct file_list *cur_flist, *first_flist, *dir_flist;
+ extern filter_rule_list filter_list, daemon_filter_list;
++extern struct file_list the_fattr_list;
+ 
+ int maybe_ATTRS_REPORT = 0;
+ int maybe_ATTRS_ACCURATE_TIME = 0;
+ 
+ static dev_t dev_zero;
++static int unexplored_dirs = 1;
+ static int deldelay_size = 0, deldelay_cnt = 0;
+ static char *deldelay_buf = NULL;
+ static int deldelay_fd = -1;
+@@ -268,14 +271,19 @@ static void do_delayed_deletions(char *delbuf)
+  * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
+  * MAXPATHLEN buffer with the name of the directory in it (the functions we
+  * call will append names onto the end, but the old dir value will be restored
+- * on exit). */
+-static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)
++ * on exit).
++ *
++ * Note:  --detect-rename may use this routine with DEL_NO_DELETIONS set!
++ */
++static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev,
++			  int del_flags)
+ {
+ 	static int already_warned = 0;
+ 	static struct hashtable *dev_tbl;
+ 	struct file_list *dirlist;
+-	char delbuf[MAXPATHLEN];
+-	int dlen, i;
++	char *p, delbuf[MAXPATHLEN];
++	unsigned remainder;
++	int dlen, i, restore_dot = 0;
+ 
+ 	if (!fbuf) {
+ 		change_local_filter_dir(NULL, 0, 0);
+@@ -289,17 +297,22 @@ static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)
+ 		maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
+ 
+ 	if (io_error & IOERR_GENERAL && !ignore_errors) {
+-		if (already_warned)
++		if (!already_warned) {
++			rprintf(FINFO,
++			    "IO error encountered -- skipping file deletion\n");
++			already_warned = 1;
++		}
++		if (!detect_renamed)
+ 			return;
+-		rprintf(FINFO,
+-			"IO error encountered -- skipping file deletion\n");
+-		already_warned = 1;
+-		return;
++		del_flags |= DEL_NO_DELETIONS;
+ 	}
+ 
+ 	dlen = strlen(fbuf);
+ 	change_local_filter_dir(fbuf, dlen, F_DEPTH(file));
+ 
++	if (detect_renamed)
++		unexplored_dirs--;
++
+ 	if (one_file_system) {
+ 		if (!dev_tbl)
+ 			dev_tbl = hashtable_create(16, HT_KEY64);
+@@ -315,6 +328,14 @@ static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)
+ 
+ 	dirlist = get_dirlist(fbuf, dlen, 0);
+ 
++	p = fbuf + dlen;
++	if (dlen == 1 && *fbuf == '.') {
++		restore_dot = 1;
++		p = fbuf;
++	} else if (dlen != 1 || *fbuf != '/')
++		*p++ = '/';
++	remainder = MAXPATHLEN - (p - fbuf);
++
+ 	/* If an item in dirlist is not found in flist, delete it
+ 	 * from the filesystem. */
+ 	for (i = dirlist->used; i--; ) {
+@@ -327,6 +348,10 @@ static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)
+ 					f_name(fp, NULL));
+ 			continue;
+ 		}
++		if (detect_renamed && S_ISREG(fp->mode)) {
++			strlcpy(p, fp->basename, remainder);
++			look_for_rename(fp, fbuf);
++		}
+ 		/* Here we want to match regardless of file type.  Replacement
+ 		 * of a file with one of another type is handled separately by
+ 		 * a delete_item call with a DEL_MAKE_ROOM flag. */
+@@ -335,14 +360,19 @@ static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev)
+ 			if (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)
+ 				flags |= DEL_NO_UID_WRITE;
+ 			f_name(fp, delbuf);
+-			if (delete_during == 2) {
+-				if (!remember_delete(fp, delbuf, flags))
++			if (delete_during == 2 && !(del_flags & DEL_NO_DELETIONS)) {
++				if (!remember_delete(fp, delbuf, del_flags | flags))
+ 					break;
+ 			} else
+-				delete_item(delbuf, fp->mode, flags);
+-		}
++				delete_item(delbuf, fp->mode, del_flags | flags);
++		} else if (detect_renamed && S_ISDIR(fp->mode))
++			unexplored_dirs++;
+ 	}
+ 
++	if (restore_dot)
++		fbuf[0] = '.';
++	fbuf[dlen] = '\0';
++
+ 	flist_free(dirlist);
+ }
+ 
+@@ -378,14 +408,127 @@ static void do_delete_pass(void)
+ 		 || !S_ISDIR(st.st_mode))
+ 			continue;
+ 
+-		delete_in_dir(fbuf, file, st.st_dev);
++		delete_in_dir(fbuf, file, st.st_dev, 0);
+ 	}
+-	delete_in_dir(NULL, NULL, dev_zero);
++	delete_in_dir(NULL, NULL, dev_zero, 0);
+ 
+ 	if (INFO_GTE(FLIST, 2) && !am_server)
+ 		rprintf(FINFO, "                    \r");
+ }
+ 
++/* Search for a regular file that matches either (1) the size & modified
++ * time (plus the basename, if possible) or (2) the size & checksum.  If
++ * we find an exact match down to the dirname, return -1 because we found
++ * an up-to-date file in the transfer, not a renamed file. */
++static int fattr_find(struct file_struct *f, char *fname)
++{
++	int low = the_fattr_list.low, high = the_fattr_list.high;
++	int mid, ok_match = -1, good_match = -1;
++	struct file_struct *fmid;
++	int diff;
++
++	while (low <= high) {
++		mid = (low + high) / 2;
++		fmid = the_fattr_list.files[mid];
++		if (F_LENGTH(fmid) != F_LENGTH(f)) {
++			if (F_LENGTH(fmid) < F_LENGTH(f))
++				low = mid + 1;
++			else
++				high = mid - 1;
++			continue;
++		}
++		if (always_checksum) {
++			/* We use the FLAG_FILE_SENT flag to indicate when we
++			 * have computed the checksum for an entry. */
++			if (!(f->flags & FLAG_FILE_SENT)) {
++				STRUCT_STAT st;
++				if (fmid->modtime == f->modtime
++				 && f_name_cmp(fmid, f) == 0)
++					return -1; /* assume we can't help */
++				st.st_size = F_LENGTH(f);
++				st.st_mtime = f->modtime;
++				file_checksum(fname, &st, F_SUM(f));
++				f->flags |= FLAG_FILE_SENT;
++			}
++			diff = u_memcmp(F_SUM(fmid), F_SUM(f), flist_csum_len);
++			if (diff) {
++				if (diff < 0)
++					low = mid + 1;
++				else
++					high = mid - 1;
++				continue;
++			}
++		} else {
++			if (fmid->modtime != f->modtime) {
++				if (fmid->modtime < f->modtime)
++					low = mid + 1;
++				else
++					high = mid - 1;
++				continue;
++			}
++		}
++		/* --detect-moved doesn't allow non-basename matches */
++		if (detect_renamed != 3)
++			ok_match = mid;
++		diff = u_strcmp(fmid->basename, f->basename);
++		if (diff == 0) {
++			good_match = mid;
++			if (fmid->dirname == f->dirname)
++				return -1; /* file is up-to-date */
++			if (!fmid->dirname) {
++				low = mid + 1;
++				continue;
++			}
++			if (!f->dirname) {
++				high = mid - 1;
++				continue;
++			}
++			diff = u_strcmp(fmid->dirname, f->dirname);
++			if (diff == 0)
++				return -1; /* file is up-to-date */
++		}
++		if (diff < 0)
++			low = mid + 1;
++		else
++			high = mid - 1;
++	}
++
++	return good_match >= 0 ? good_match : ok_match;
++}
++
++void look_for_rename(struct file_struct *file, char *fname)
++{
++	struct file_struct *fp;
++	char *partialptr, *fn;
++	STRUCT_STAT st;
++	int ndx;
++
++	if (!partial_dir || (ndx = fattr_find(file, fname)) < 0)
++		return;
++
++	fp = the_fattr_list.files[ndx];
++	fn = f_name(fp, NULL);
++	/* We don't provide an alternate-basis file if there is a basis file. */
++	if (link_stat(fn, &st, 0) == 0)
++		return;
++
++	if (!dry_run) {
++		if ((partialptr = partial_dir_fname(fn)) == NULL
++		 || !handle_partial_dir(partialptr, PDIR_CREATE))
++			return;
++		/* We only use the file if we can hard-link it into our tmp dir. */
++		if (link(fname, partialptr) != 0) {
++			if (errno != EEXIST)
++				handle_partial_dir(partialptr, PDIR_DELETE);
++			return;
++		}
++	}
++
++	/* I think this falls into the -vv category with "%s is uptodate", etc. */
++	if (INFO_GTE(MISC, 2))
++		rprintf(FINFO, "found renamed: %s => %s\n", fname, fn);
++}
++
+ static inline int mtime_differs(STRUCT_STAT *stp, struct file_struct *file)
+ {
+ #ifdef ST_MTIME_NSEC
+@@ -962,7 +1105,7 @@ static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
+ 			best_match = j;
+ 			match_level = 2;
+ 		}
+-		if (unchanged_attrs(cmpbuf, file, sxp)) {
++		if (alt_dest_type == CLONE_DEST || unchanged_attrs(cmpbuf, file, sxp)) {
+ 			best_match = j;
+ 			match_level = 3;
+ 			break;
+@@ -988,9 +1131,16 @@ static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
+ 				goto got_nothing_for_ya;
+ 		}
+ #ifdef SUPPORT_HARD_LINKS
+-		if (alt_dest_type == LINK_DEST) {
+-			if (!hard_link_one(file, fname, cmpbuf, 1))
+-				goto try_a_copy;
++		if (alt_dest_type == LINK_DEST || alt_dest_type == CLONE_DEST) {
++			if (alt_dest_type == LINK_DEST) {
++				if (!hard_link_one(file, fname, cmpbuf, 1))
++					goto try_a_copy;
++			} else if (do_clone(cmpbuf, fname, file->mode) == 0) {
++				finish_transfer(fname, fname, cmpbuf, NULL, file, 1, 0);
++			} else {
++				rsyserr(FERROR_XFER, errno, "failed to clone %s to %s", cmpbuf, fname);
++				exit_cleanup(RERR_UNSUPPORTED);
++			}
+ 			if (atimes_ndx)
+ 				set_file_attrs(fname, file, sxp, NULL, 0);
+ 			if (preserve_hard_links && F_IS_HLINKED(file))
+@@ -1104,7 +1254,7 @@ static int try_dests_non(struct file_struct *file, char *fname, int ndx,
+ 
+ 	if (match_level == 3) {
+ #ifdef SUPPORT_HARD_LINKS
+-		if (alt_dest_type == LINK_DEST
++		if ((alt_dest_type == LINK_DEST || alt_dest_type == CLONE_DEST)
+ #ifndef CAN_HARDLINK_SYMLINK
+ 		 && !S_ISLNK(file->mode)
+ #endif
+@@ -1182,6 +1332,7 @@ static void list_file_entry(struct file_struct *f)
+ 	}
+ }
+ 
++static struct bitbag *delayed_bits = NULL;
+ static int phase = 0;
+ static int dflt_perms;
+ 
+@@ -1318,7 +1469,7 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 			 && do_stat(dn, &sx.st) < 0) {
+ 				if (dry_run)
+ 					goto parent_is_dry_missing;
+-				if (make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0) {
++				if (make_path(fname, ACCESSPERMS, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0) {
+ 					rsyserr(FERROR_XFER, errno,
+ 						"recv_generator: mkdir %s failed",
+ 						full_fname(dn));
+@@ -1471,7 +1622,7 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 		}
+ 		if (real_ret != 0 && do_mkdir(fname,file->mode|added_perms) < 0 && errno != EEXIST) {
+ 			if (!relative_paths || errno != ENOENT
+-			 || make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0
++			 || make_path(fname, ACCESSPERMS, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0
+ 			 || (do_mkdir(fname, file->mode|added_perms) < 0 && errno != EEXIST)) {
+ 				rsyserr(FERROR_XFER, errno,
+ 					"recv_generator: mkdir %s failed",
+@@ -1519,9 +1670,12 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 		}
+ 		else if (delete_during && f_out != -1 && !phase
+ 		    && !(file->flags & FLAG_MISSING_DIR)) {
+-			if (file->flags & FLAG_CONTENT_DIR)
+-				delete_in_dir(fname, file, real_sx.st.st_dev);
+-			else
++			if (file->flags & FLAG_CONTENT_DIR) {
++				if (detect_renamed && real_ret != 0)
++					unexplored_dirs++;
++				delete_in_dir(fname, file, real_sx.st.st_dev,
++					      delete_during < 0 ? DEL_NO_DELETIONS : 0);
++			} else
+ 				change_local_filter_dir(fname, strlen(fname), F_DEPTH(file));
+ 		}
+ 		prior_dir_file = file;
+@@ -1789,8 +1943,14 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 			goto cleanup;
+ 		}
+ #endif
+-		if (stat_errno == ENOENT)
++		if (stat_errno == ENOENT) {
++			if (detect_renamed && unexplored_dirs > 0
++			 && F_LENGTH(file)) {
++				bitbag_set_bit(delayed_bits, ndx);
++				return;
++			}
+ 			goto notify_others;
++		}
+ 		rsyserr(FERROR_XFER, stat_errno, "recv_generator: failed to stat %s",
+ 			full_fname(fname));
+ 		goto cleanup;
+@@ -1840,6 +2000,21 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 		fnamecmp = partialptr;
+ 		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
+ 		statret = 0;
++		if (detect_renamed > 1 && quick_check_ok(FT_REG, fnamecmp, file, &sx.st)) {
++			/* Adopt the partial file. */
++			finish_transfer(fname, fnamecmp, NULL, NULL, file, 1, 1);
++			handle_partial_dir(partialptr, PDIR_DELETE);
++			if (itemizing)
++				itemize(fnamecmp, file, ndx, -1, &sx,
++						ITEM_LOCAL_CHANGE, fnamecmp_type, NULL);
++#ifdef SUPPORT_HARD_LINKS
++			if (preserve_hard_links && F_IS_HLINKED(file))
++				finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
++#endif
++			if (remove_source_files == 1)
++				goto return_with_success;
++			goto cleanup;
++		}
+ 	}
+ 
+ 	if (!do_xfers)
+@@ -2256,6 +2431,12 @@ void generate_files(int f_out, const char *local_name)
+ 	if (DEBUG_GTE(GENR, 1))
+ 		rprintf(FINFO, "generator starting pid=%d\n", (int)getpid());
+ 
++	if (detect_renamed) {
++		delayed_bits = bitbag_create(cur_flist->used);
++		if (!delete_before && !delete_during)
++			delete_during = -1;
++	}
++
+ 	if (delete_before && !solo_file && cur_flist->used > 0)
+ 		do_delete_pass();
+ 	if (delete_during == 2) {
+@@ -2264,7 +2445,7 @@ void generate_files(int f_out, const char *local_name)
+ 	}
+ 	info_levels[INFO_FLIST] = info_levels[INFO_PROGRESS] = 0;
+ 
+-	if (append_mode > 0 || whole_file < 0)
++	if (append_mode > 0 || detect_renamed || whole_file < 0)
+ 		whole_file = 0;
+ 	if (DEBUG_GTE(FLIST, 1)) {
+ 		rprintf(FINFO, "delta-transmission %s\n",
+@@ -2300,7 +2481,7 @@ void generate_files(int f_out, const char *local_name)
+ 						dirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
+ 					} else
+ 						dirdev = MAKEDEV(0, 0);
+-					delete_in_dir(fbuf, fp, dirdev);
++					delete_in_dir(fbuf, fp, dirdev, 0);
+ 				} else
+ 					change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(fp));
+ 			}
+@@ -2347,7 +2528,21 @@ void generate_files(int f_out, const char *local_name)
+ 	} while ((cur_flist = cur_flist->next) != NULL);
+ 
+ 	if (delete_during)
+-		delete_in_dir(NULL, NULL, dev_zero);
++		delete_in_dir(NULL, NULL, dev_zero, 0);
++	if (detect_renamed) {
++		if (delete_during < 0)
++			delete_during = 0;
++		detect_renamed = 0;
++
++		for (i = -1; (i = bitbag_next_bit(delayed_bits, i)) >= 0; ) {
++			struct file_struct *file = cur_flist->files[i];
++			if (local_name)
++				strlcpy(fbuf, local_name, sizeof fbuf);
++			else
++				f_name(file, fbuf);
++			recv_generator(fbuf, file, i, itemizing, code, f_out);
++		}
++	}
+ 	phase++;
+ 	if (DEBUG_GTE(GENR, 1))
+ 		rprintf(FINFO, "generate_files phase=%d\n", phase);
+diff --git a/generator.c.orig b/generator.c.orig
+new file mode 100644
+index 00000000..1d8f409f
+--- /dev/null
++++ b/generator.c.orig
+@@ -0,0 +1,2612 @@
++/*
++ * Routines that are exclusive to the generator process.
++ *
++ * Copyright (C) 1996-2000 Andrew Tridgell
++ * Copyright (C) 1996 Paul Mackerras
++ * Copyright (C) 2002 Martin Pool <mbp@samba.org>
++ * Copyright (C) 2003-2023 Wayne Davison
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 3 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not, visit the http://fsf.org website.
++ */
++
++#include "rsync.h"
++#include "inums.h"
++#include "ifuncs.h"
++
++extern int dry_run;
++extern int do_xfers;
++extern int stdout_format_has_i;
++extern int logfile_format_has_i;
++extern int am_root;
++extern int am_server;
++extern int am_daemon;
++extern int inc_recurse;
++extern int relative_paths;
++extern int implied_dirs;
++extern int keep_dirlinks;
++extern int write_devices;
++extern int preserve_acls;
++extern int preserve_xattrs;
++extern int preserve_links;
++extern int preserve_devices;
++extern int preserve_specials;
++extern int preserve_hard_links;
++extern int preserve_executability;
++extern int preserve_perms;
++extern int preserve_mtimes;
++extern int omit_dir_times;
++extern int omit_link_times;
++extern int delete_mode;
++extern int delete_before;
++extern int delete_during;
++extern int delete_after;
++extern int missing_args;
++extern int msgdone_cnt;
++extern int ignore_errors;
++extern int remove_source_files;
++extern int delay_updates;
++extern int update_only;
++extern int human_readable;
++extern int ignore_existing;
++extern int ignore_non_existing;
++extern int want_xattr_optim;
++extern int modify_window;
++extern int inplace;
++extern int append_mode;
++extern int make_backups;
++extern int csum_length;
++extern int ignore_times;
++extern int size_only;
++extern OFF_T max_size;
++extern OFF_T min_size;
++extern int io_error;
++extern int flist_eof;
++extern int allowed_lull;
++extern int sock_f_out;
++extern int protocol_version;
++extern int file_total;
++extern int fuzzy_basis;
++extern int always_checksum;
++extern int flist_csum_len;
++extern char *partial_dir;
++extern int alt_dest_type;
++extern int detect_renamed;
++extern int whole_file;
++extern int list_only;
++extern int read_batch;
++extern int write_batch;
++extern int safe_symlinks;
++extern int32 block_size;
++extern int unsort_ndx;
++extern int max_delete;
++extern int force_delete;
++extern int one_file_system;
++extern int skipped_deletes;
++extern dev_t filesystem_dev;
++extern mode_t orig_umask;
++extern uid_t our_uid;
++extern char *tmpdir;
++extern char *basis_dir[MAX_BASIS_DIRS+1];
++extern struct file_list *cur_flist, *first_flist, *dir_flist;
++extern filter_rule_list filter_list, daemon_filter_list;
++extern struct file_list the_fattr_list;
++
++int maybe_ATTRS_REPORT = 0;
++int maybe_ATTRS_ACCURATE_TIME = 0;
++
++static dev_t dev_zero;
++static int unexplored_dirs = 1;
++static int deldelay_size = 0, deldelay_cnt = 0;
++static char *deldelay_buf = NULL;
++static int deldelay_fd = -1;
++static int loopchk_limit;
++static int dir_tweaking;
++static int symlink_timeset_failed_flags;
++static int need_retouch_dir_times;
++static int need_retouch_dir_perms;
++static const char *solo_file = NULL;
++
++/* Forward declarations. */
++#ifdef SUPPORT_HARD_LINKS
++static void handle_skipped_hlink(struct file_struct *file, int itemizing,
++				 enum logcode code, int f_out);
++#endif
++
++#define EARLY_DELAY_DONE_MSG() (!delay_updates)
++#define EARLY_DELETE_DONE_MSG() (!(delete_during == 2 || delete_after))
++
++static int start_delete_delay_temp(void)
++{
++	char fnametmp[MAXPATHLEN];
++	int save_dry_run = dry_run;
++
++	dry_run = 0;
++	if (!get_tmpname(fnametmp, "deldelay", False)
++	 || (deldelay_fd = do_mkstemp(fnametmp, 0600)) < 0) {
++		rprintf(FINFO, "NOTE: Unable to create delete-delay temp file%s.\n",
++			inc_recurse ? "" : " -- switching to --delete-after");
++		delete_during = 0;
++		delete_after = !inc_recurse;
++		dry_run = save_dry_run;
++		return 0;
++	}
++	unlink(fnametmp);
++	dry_run = save_dry_run;
++	return 1;
++}
++
++static int flush_delete_delay(void)
++{
++	if (deldelay_fd < 0 && !start_delete_delay_temp())
++		return 0;
++	if (write(deldelay_fd, deldelay_buf, deldelay_cnt) != deldelay_cnt) {
++		rsyserr(FERROR, errno, "flush of delete-delay buffer");
++		delete_during = 0;
++		delete_after = !inc_recurse;
++		close(deldelay_fd);
++		return 0;
++	}
++	deldelay_cnt = 0;
++	return 1;
++}
++
++static int remember_delete(struct file_struct *file, const char *fname, int flags)
++{
++	int len;
++
++	if (deldelay_cnt == deldelay_size && !flush_delete_delay())
++		return 0;
++
++	if (flags & DEL_NO_UID_WRITE)
++		deldelay_buf[deldelay_cnt++] = '!';
++
++	while (1) {
++		len = snprintf(deldelay_buf + deldelay_cnt, deldelay_size - deldelay_cnt,
++			       "%x %s%c", (int)file->mode, fname, '\0');
++		if ((deldelay_cnt += len) <= deldelay_size)
++			break;
++		deldelay_cnt -= len;
++		if (!flush_delete_delay())
++			return 0;
++	}
++
++	return 1;
++}
++
++static int read_delay_line(char *buf, int *flags_p)
++{
++	static int read_pos = 0;
++	unsigned int mode;
++	int j, len;
++	char *bp, *past_space;
++
++	while (1) {
++		for (j = read_pos; j < deldelay_cnt && deldelay_buf[j]; j++) {}
++		if (j < deldelay_cnt)
++			break;
++		if (deldelay_fd < 0) {
++			if (j > read_pos)
++				goto invalid_data;
++			return -1;
++		}
++		deldelay_cnt -= read_pos;
++		if (deldelay_cnt == deldelay_size)
++			goto invalid_data;
++		if (deldelay_cnt && read_pos) {
++			memmove(deldelay_buf, deldelay_buf + read_pos,
++				deldelay_cnt);
++		}
++		len = read(deldelay_fd, deldelay_buf + deldelay_cnt,
++			   deldelay_size - deldelay_cnt);
++		if (len == 0) {
++			if (deldelay_cnt) {
++				rprintf(FERROR, "ERROR: unexpected EOF in delete-delay file.\n");
++			}
++			return -1;
++		}
++		if (len < 0) {
++			rsyserr(FERROR, errno,
++				"reading delete-delay file");
++			return -1;
++		}
++		deldelay_cnt += len;
++		read_pos = 0;
++	}
++
++	bp = deldelay_buf + read_pos;
++	if (*bp == '!') {
++		bp++;
++		*flags_p = DEL_NO_UID_WRITE;
++	} else
++		*flags_p = 0;
++
++	if (sscanf(bp, "%x ", &mode) != 1) {
++	  invalid_data:
++		rprintf(FERROR, "ERROR: invalid data in delete-delay file.\n");
++		return -1;
++	}
++	past_space = strchr(bp, ' ') + 1;
++	len = j - read_pos - (past_space - bp) + 1; /* count the '\0' */
++	read_pos = j + 1;
++
++	if (len > MAXPATHLEN) {
++		rprintf(FERROR, "ERROR: filename too long in delete-delay file.\n");
++		return -1;
++	}
++
++	/* The caller needs the name in a MAXPATHLEN buffer, so we copy it
++	 * instead of returning a pointer to our buffer. */
++	memcpy(buf, past_space, len);
++
++	return mode;
++}
++
++static void do_delayed_deletions(char *delbuf)
++{
++	int mode, flags;
++
++	if (deldelay_fd >= 0) {
++		if (deldelay_cnt && !flush_delete_delay())
++			return;
++		lseek(deldelay_fd, 0, 0);
++	}
++	while ((mode = read_delay_line(delbuf, &flags)) >= 0)
++		delete_item(delbuf, mode, flags | DEL_RECURSE);
++	if (deldelay_fd >= 0)
++		close(deldelay_fd);
++}
++
++/* This function is used to implement per-directory deletion, and is used by
++ * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
++ * MAXPATHLEN buffer with the name of the directory in it (the functions we
++ * call will append names onto the end, but the old dir value will be restored
++ * on exit).
++ *
++ * Note:  --detect-rename may use this routine with DEL_NO_DELETIONS set!
++ */
++static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t fs_dev,
++			  int del_flags)
++{
++	static int already_warned = 0;
++	static struct hashtable *dev_tbl;
++	struct file_list *dirlist;
++	char *p, delbuf[MAXPATHLEN];
++	unsigned remainder;
++	int dlen, i, restore_dot = 0;
++
++	if (!fbuf) {
++		change_local_filter_dir(NULL, 0, 0);
++		return;
++	}
++
++	if (DEBUG_GTE(DEL, 2))
++		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
++
++	if (allowed_lull)
++		maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
++
++	if (io_error & IOERR_GENERAL && !ignore_errors) {
++		if (!already_warned) {
++			rprintf(FINFO,
++			    "IO error encountered -- skipping file deletion\n");
++			already_warned = 1;
++		}
++		if (!detect_renamed)
++			return;
++		del_flags |= DEL_NO_DELETIONS;
++	}
++
++	dlen = strlen(fbuf);
++	change_local_filter_dir(fbuf, dlen, F_DEPTH(file));
++
++	if (detect_renamed)
++		unexplored_dirs--;
++
++	if (one_file_system) {
++		if (!dev_tbl)
++			dev_tbl = hashtable_create(16, HT_KEY64);
++		if (file->flags & FLAG_TOP_DIR) {
++			hashtable_find(dev_tbl, fs_dev+1, "");
++			filesystem_dev = fs_dev;
++		} else if (filesystem_dev != fs_dev) {
++			if (!hashtable_find(dev_tbl, fs_dev+1, NULL))
++				return;
++			filesystem_dev = fs_dev; /* it's a prior top-dir dev */
++		}
++	}
++
++	dirlist = get_dirlist(fbuf, dlen, 0);
++
++	p = fbuf + dlen;
++	if (dlen == 1 && *fbuf == '.') {
++		restore_dot = 1;
++		p = fbuf;
++	} else if (dlen != 1 || *fbuf != '/')
++		*p++ = '/';
++	remainder = MAXPATHLEN - (p - fbuf);
++
++	/* If an item in dirlist is not found in flist, delete it
++	 * from the filesystem. */
++	for (i = dirlist->used; i--; ) {
++		struct file_struct *fp = dirlist->files[i];
++		if (!F_IS_ACTIVE(fp))
++			continue;
++		if (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {
++			if (INFO_GTE(MOUNT, 1))
++				rprintf(FINFO, "cannot delete mount point: %s\n",
++					f_name(fp, NULL));
++			continue;
++		}
++		if (detect_renamed && S_ISREG(fp->mode)) {
++			strlcpy(p, fp->basename, remainder);
++			look_for_rename(fp, fbuf);
++		}
++		/* Here we want to match regardless of file type.  Replacement
++		 * of a file with one of another type is handled separately by
++		 * a delete_item call with a DEL_MAKE_ROOM flag. */
++		if (flist_find_ignore_dirness(cur_flist, fp) < 0) {
++			int flags = DEL_RECURSE;
++			if (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)
++				flags |= DEL_NO_UID_WRITE;
++			f_name(fp, delbuf);
++			if (delete_during == 2 && !(del_flags & DEL_NO_DELETIONS)) {
++				if (!remember_delete(fp, delbuf, del_flags | flags))
++					break;
++			} else
++				delete_item(delbuf, fp->mode, del_flags | flags);
++		} else if (detect_renamed && S_ISDIR(fp->mode))
++			unexplored_dirs++;
++	}
++
++	if (restore_dot)
++		fbuf[0] = '.';
++	fbuf[dlen] = '\0';
++
++	flist_free(dirlist);
++}
++
++/* This deletes any files on the receiving side that are not present on the
++ * sending side.  This is used by --delete-before and --delete-after. */
++static void do_delete_pass(void)
++{
++	char fbuf[MAXPATHLEN];
++	STRUCT_STAT st;
++	int j;
++
++	/* dry_run is incremented when the destination doesn't exist yet. */
++	if (dry_run > 1 || list_only)
++		return;
++
++	for (j = 0; j < cur_flist->used; j++) {
++		struct file_struct *file = cur_flist->sorted[j];
++
++		if (!F_IS_ACTIVE(file))
++			continue;
++
++		f_name(file, fbuf);
++
++		if (!(file->flags & FLAG_CONTENT_DIR)) {
++			change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(file));
++			continue;
++		}
++
++		if (DEBUG_GTE(DEL, 1) && file->flags & FLAG_TOP_DIR)
++			rprintf(FINFO, "deleting in %s\n", fbuf);
++
++		if (link_stat(fbuf, &st, keep_dirlinks) < 0
++		 || !S_ISDIR(st.st_mode))
++			continue;
++
++		delete_in_dir(fbuf, file, st.st_dev, 0);
++	}
++	delete_in_dir(NULL, NULL, dev_zero, 0);
++
++	if (INFO_GTE(FLIST, 2) && !am_server)
++		rprintf(FINFO, "                    \r");
++}
++
++/* Search for a regular file that matches either (1) the size & modified
++ * time (plus the basename, if possible) or (2) the size & checksum.  If
++ * we find an exact match down to the dirname, return -1 because we found
++ * an up-to-date file in the transfer, not a renamed file. */
++static int fattr_find(struct file_struct *f, char *fname)
++{
++	int low = the_fattr_list.low, high = the_fattr_list.high;
++	int mid, ok_match = -1, good_match = -1;
++	struct file_struct *fmid;
++	int diff;
++
++	while (low <= high) {
++		mid = (low + high) / 2;
++		fmid = the_fattr_list.files[mid];
++		if (F_LENGTH(fmid) != F_LENGTH(f)) {
++			if (F_LENGTH(fmid) < F_LENGTH(f))
++				low = mid + 1;
++			else
++				high = mid - 1;
++			continue;
++		}
++		if (always_checksum) {
++			/* We use the FLAG_FILE_SENT flag to indicate when we
++			 * have computed the checksum for an entry. */
++			if (!(f->flags & FLAG_FILE_SENT)) {
++				STRUCT_STAT st;
++				if (fmid->modtime == f->modtime
++				 && f_name_cmp(fmid, f) == 0)
++					return -1; /* assume we can't help */
++				st.st_size = F_LENGTH(f);
++				st.st_mtime = f->modtime;
++				file_checksum(fname, &st, F_SUM(f));
++				f->flags |= FLAG_FILE_SENT;
++			}
++			diff = u_memcmp(F_SUM(fmid), F_SUM(f), flist_csum_len);
++			if (diff) {
++				if (diff < 0)
++					low = mid + 1;
++				else
++					high = mid - 1;
++				continue;
++			}
++		} else {
++			if (fmid->modtime != f->modtime) {
++				if (fmid->modtime < f->modtime)
++					low = mid + 1;
++				else
++					high = mid - 1;
++				continue;
++			}
++		}
++		ok_match = mid;
++		diff = u_strcmp(fmid->basename, f->basename);
++		if (diff == 0) {
++			good_match = mid;
++			if (fmid->dirname == f->dirname)
++				return -1; /* file is up-to-date */
++			if (!fmid->dirname) {
++				low = mid + 1;
++				continue;
++			}
++			if (!f->dirname) {
++				high = mid - 1;
++				continue;
++			}
++			diff = u_strcmp(fmid->dirname, f->dirname);
++			if (diff == 0)
++				return -1; /* file is up-to-date */
++		}
++		if (diff < 0)
++			low = mid + 1;
++		else
++			high = mid - 1;
++	}
++
++	return good_match >= 0 ? good_match : ok_match;
++}
++
++void look_for_rename(struct file_struct *file, char *fname)
++{
++	struct file_struct *fp;
++	char *partialptr, *fn;
++	STRUCT_STAT st;
++	int ndx;
++
++	if (!partial_dir || (ndx = fattr_find(file, fname)) < 0)
++		return;
++
++	fp = the_fattr_list.files[ndx];
++	fn = f_name(fp, NULL);
++	/* We don't provide an alternate-basis file if there is a basis file. */
++	if (link_stat(fn, &st, 0) == 0)
++		return;
++
++	if (!dry_run) {
++		if ((partialptr = partial_dir_fname(fn)) == NULL
++		 || !handle_partial_dir(partialptr, PDIR_CREATE))
++			return;
++		/* We only use the file if we can hard-link it into our tmp dir. */
++		if (link(fname, partialptr) != 0) {
++			if (errno != EEXIST)
++				handle_partial_dir(partialptr, PDIR_DELETE);
++			return;
++		}
++	}
++
++	/* I think this falls into the -vv category with "%s is uptodate", etc. */
++	if (INFO_GTE(MISC, 2))
++		rprintf(FINFO, "found renamed: %s => %s\n", fname, fn);
++}
++
++static inline int mtime_differs(STRUCT_STAT *stp, struct file_struct *file)
++{
++#ifdef ST_MTIME_NSEC
++	return !same_time(stp->st_mtime, stp->ST_MTIME_NSEC, file->modtime, F_MOD_NSEC_or_0(file));
++#else
++	return !same_time(stp->st_mtime, 0, file->modtime, 0);
++#endif
++}
++
++static inline int any_time_differs(stat_x *sxp, struct file_struct *file, UNUSED(const char *fname))
++{
++	int differs = mtime_differs(&sxp->st, file);
++#ifdef SUPPORT_CRTIMES
++	if (!differs && crtimes_ndx) {
++		if (sxp->crtime == 0)
++			sxp->crtime = get_create_time(fname, &sxp->st);
++		differs = !same_time(sxp->crtime, 0, F_CRTIME(file), 0);
++	}
++#endif
++	return differs;
++}
++
++static inline int perms_differ(struct file_struct *file, stat_x *sxp)
++{
++	if (preserve_perms)
++		return !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS);
++
++	if (preserve_executability)
++		return (sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0);
++
++	return 0;
++}
++
++static inline int ownership_differs(struct file_struct *file, stat_x *sxp)
++{
++	if (am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file))
++		return 1;
++
++	if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))
++		return 1;
++
++	return 0;
++}
++
++#ifdef SUPPORT_ACLS
++static inline int acls_differ(const char *fname, struct file_struct *file, stat_x *sxp)
++{
++	if (preserve_acls) {
++		if (!ACL_READY(*sxp))
++			get_acl(fname, sxp);
++		if (set_acl(NULL, file, sxp, file->mode))
++			return 1;
++	}
++
++	return 0;
++}
++#endif
++
++#ifdef SUPPORT_XATTRS
++static inline int xattrs_differ(const char *fname, struct file_struct *file, stat_x *sxp)
++{
++	if (preserve_xattrs) {
++		if (!XATTR_READY(*sxp))
++			get_xattr(fname, sxp);
++		if (xattr_diff(file, sxp, 0))
++			return 1;
++	}
++
++	return 0;
++}
++#endif
++
++int unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp)
++{
++	if (S_ISLNK(file->mode)) {
++#ifdef CAN_SET_SYMLINK_TIMES
++		if (preserve_mtimes && !omit_link_times && any_time_differs(sxp, file, fname))
++			return 0;
++#endif
++#ifdef CAN_CHMOD_SYMLINK
++		if (perms_differ(file, sxp))
++			return 0;
++#endif
++#ifdef CAN_CHOWN_SYMLINK
++		if (ownership_differs(file, sxp))
++			return 0;
++#endif
++#if defined SUPPORT_ACLS && 0 /* no current symlink-ACL support */
++		if (acls_differ(fname, file, sxp))
++			return 0;
++#endif
++#if defined SUPPORT_XATTRS && !defined NO_SYMLINK_XATTRS
++		if (xattrs_differ(fname, file, sxp))
++			return 0;
++#endif
++	} else {
++		if (preserve_mtimes && any_time_differs(sxp, file, fname))
++			return 0;
++		if (perms_differ(file, sxp))
++			return 0;
++		if (ownership_differs(file, sxp))
++			return 0;
++#ifdef SUPPORT_ACLS
++		if (acls_differ(fname, file, sxp))
++			return 0;
++#endif
++#ifdef SUPPORT_XATTRS
++		if (xattrs_differ(fname, file, sxp))
++			return 0;
++#endif
++	}
++
++	return 1;
++}
++
++void itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statret,
++	     stat_x *sxp, int32 iflags, uchar fnamecmp_type,
++	     const char *xname)
++{
++	if (statret >= 0) { /* A from-dest-dir statret can == 1! */
++		int keep_time = !preserve_mtimes ? 0
++		    : S_ISDIR(file->mode) ? !omit_dir_times
++		    : S_ISLNK(file->mode) ? !omit_link_times
++		    : 1;
++
++		if (S_ISREG(file->mode) && F_LENGTH(file) != sxp->st.st_size)
++			iflags |= ITEM_REPORT_SIZE;
++		if (file->flags & FLAG_TIME_FAILED) { /* symlinks only */
++			if (iflags & ITEM_LOCAL_CHANGE)
++				iflags |= symlink_timeset_failed_flags;
++		} else if (keep_time
++		 ? mtime_differs(&sxp->st, file)
++		 : iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !(iflags & ITEM_MATCHED)
++		  && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
++			iflags |= ITEM_REPORT_TIME;
++		if (atimes_ndx && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)
++		 && !same_time(F_ATIME(file), 0, sxp->st.st_atime, 0))
++			iflags |= ITEM_REPORT_ATIME;
++#ifdef SUPPORT_CRTIMES
++		if (crtimes_ndx) {
++			if (sxp->crtime == 0)
++				sxp->crtime = get_create_time(fnamecmp, &sxp->st);
++			if (!same_time(sxp->crtime, 0, F_CRTIME(file), 0))
++				iflags |= ITEM_REPORT_CRTIME;
++		}
++#endif
++#ifndef CAN_CHMOD_SYMLINK
++		if (S_ISLNK(file->mode)) {
++			;
++		} else
++#endif
++		if (preserve_perms) {
++			if (!BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
++				iflags |= ITEM_REPORT_PERMS;
++		} else if (preserve_executability
++		 && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))
++			iflags |= ITEM_REPORT_PERMS;
++		if (uid_ndx && am_root && (uid_t)F_OWNER(file) != sxp->st.st_uid)
++			iflags |= ITEM_REPORT_OWNER;
++		if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))
++			iflags |= ITEM_REPORT_GROUP;
++#ifdef SUPPORT_ACLS
++		if (preserve_acls && !S_ISLNK(file->mode)) {
++			if (!ACL_READY(*sxp))
++				get_acl(fnamecmp, sxp);
++			if (set_acl(NULL, file, sxp, file->mode))
++				iflags |= ITEM_REPORT_ACL;
++		}
++#endif
++#ifdef SUPPORT_XATTRS
++		if (preserve_xattrs) {
++			if (!XATTR_READY(*sxp))
++				get_xattr(fnamecmp, sxp);
++			if (xattr_diff(file, sxp, 1))
++				iflags |= ITEM_REPORT_XATTR;
++		}
++#endif
++	} else {
++#ifdef SUPPORT_XATTRS
++		if (preserve_xattrs && xattr_diff(file, NULL, 1))
++			iflags |= ITEM_REPORT_XATTR;
++#endif
++		iflags |= ITEM_IS_NEW;
++	}
++
++	iflags &= 0xffff;
++	if ((iflags & (SIGNIFICANT_ITEM_FLAGS|ITEM_REPORT_XATTR) || INFO_GTE(NAME, 2)
++	  || stdout_format_has_i > 1 || (xname && *xname)) && !read_batch) {
++		if (protocol_version >= 29) {
++			if (ndx >= 0)
++				write_ndx(sock_f_out, ndx);
++			write_shortint(sock_f_out, iflags);
++			if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
++				write_byte(sock_f_out, fnamecmp_type);
++			if (iflags & ITEM_XNAME_FOLLOWS)
++				write_vstring(sock_f_out, xname, strlen(xname));
++#ifdef SUPPORT_XATTRS
++			if (preserve_xattrs && do_xfers
++			 && iflags & (ITEM_REPORT_XATTR|ITEM_TRANSFER)) {
++				int fd = iflags & ITEM_REPORT_XATTR
++				      && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))
++				       ? sock_f_out : -1;
++				send_xattr_request(NULL, file, fd);
++			}
++#endif
++		} else if (ndx >= 0) {
++			enum logcode code = logfile_format_has_i ? FINFO : FCLIENT;
++			log_item(code, file, iflags, xname);
++		}
++	}
++}
++
++static enum filetype get_file_type(mode_t mode)
++{
++	if (S_ISREG(mode))
++		return FT_REG;
++	if (S_ISLNK(mode))
++		return FT_SYMLINK;
++	if (S_ISDIR(mode))
++		return FT_DIR;
++	if (IS_SPECIAL(mode))
++		return FT_SPECIAL;
++	if (IS_DEVICE(mode))
++		return FT_DEVICE;
++	return FT_UNSUPPORTED;
++}
++
++/* Perform our quick-check heuristic for determining if a file is unchanged. */
++int quick_check_ok(enum filetype ftype, const char *fn, struct file_struct *file, STRUCT_STAT *st)
++{
++	switch (ftype) {
++	  case FT_REG:
++		if (st->st_size != F_LENGTH(file))
++			return 0;
++
++		/* If always_checksum is set then we use the checksum instead
++		 * of the file mtime to determine whether to sync. */
++		if (always_checksum > 0) {
++			char sum[MAX_DIGEST_LEN];
++			file_checksum(fn, st, sum);
++			return memcmp(sum, F_SUM(file), flist_csum_len) == 0;
++		}
++
++		if (size_only > 0)
++			return 1;
++
++		if (ignore_times)
++			return 0;
++
++		if (mtime_differs(st, file))
++			return 0;
++		break;
++	  case FT_DIR:
++		break;
++	  case FT_SYMLINK: {
++#ifdef SUPPORT_LINKS
++		char lnk[MAXPATHLEN];
++		int len = do_readlink(fn, lnk, MAXPATHLEN-1);
++		if (len <= 0)
++			return 0;
++		lnk[len] = '\0';
++		if (strcmp(lnk, F_SYMLINK(file)) != 0)
++			return 0;
++		break;
++#else
++		return -1;
++#endif
++	  }
++	  case FT_SPECIAL:
++		if (!BITS_EQUAL(file->mode, st->st_mode, _S_IFMT))
++			return 0;
++		break;
++	  case FT_DEVICE: {
++		uint32 *devp = F_RDEV_P(file);
++		if (st->st_rdev != MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp)))
++			return 0;
++		break;
++	  }
++	  case FT_UNSUPPORTED:
++		return -1;
++	}
++	return 1;
++}
++
++/*
++ * set (initialize) the size entries in the per-file sum_struct
++ * calculating dynamic block and checksum sizes.
++ *
++ * This is only called from generate_and_send_sums() but is a separate
++ * function to encapsulate the logic.
++ *
++ * The block size is a rounded square root of file length.
++ *
++ * The checksum size is determined according to:
++ *     blocksum_bits = BLOCKSUM_BIAS + 2*log2(file_len) - log2(block_len)
++ * provided by Donovan Baarda which gives a probability of rsync
++ * algorithm corrupting data and falling back using the whole md4
++ * checksums.
++ *
++ * This might be made one of several selectable heuristics.
++ */
++static void sum_sizes_sqroot(struct sum_struct *sum, int64 len)
++{
++	int32 blength;
++	int s2length;
++	int64 l;
++
++	if (len < 0) {
++		/* The file length overflowed our int64 var, so we can't process this file. */
++		sum->count = -1; /* indicate overflow error */
++		return;
++	}
++
++	if (block_size)
++		blength = block_size;
++	else if (len <= BLOCK_SIZE * BLOCK_SIZE)
++		blength = BLOCK_SIZE;
++	else {
++		int32 max_blength = protocol_version < 30 ? OLD_MAX_BLOCK_SIZE : MAX_BLOCK_SIZE;
++		int32 c;
++		int cnt;
++		for (c = 1, l = len, cnt = 0; l >>= 2; c <<= 1, cnt++) {}
++		if (c < 0 || c >= max_blength)
++			blength = max_blength;
++		else {
++			blength = 0;
++			do {
++				blength |= c;
++				if (len < (int64)blength * blength)
++					blength &= ~c;
++				c >>= 1;
++			} while (c >= 8);	/* round to multiple of 8 */
++			blength = MAX(blength, BLOCK_SIZE);
++		}
++	}
++
++	if (protocol_version < 27) {
++		s2length = csum_length;
++	} else if (csum_length == SUM_LENGTH) {
++		s2length = SUM_LENGTH;
++	} else {
++		int32 c;
++		int b = BLOCKSUM_BIAS;
++		for (l = len; l >>= 1; b += 2) {}
++		for (c = blength; (c >>= 1) && b; b--) {}
++		/* add a bit, subtract rollsum, round up. */
++		s2length = (b + 1 - 32 + 7) / 8; /* --optimize in compiler-- */
++		s2length = MAX(s2length, csum_length);
++		s2length = MIN(s2length, SUM_LENGTH);
++	}
++
++	sum->flength	= len;
++	sum->blength	= blength;
++	sum->s2length	= s2length;
++	sum->remainder	= (int32)(len % blength);
++	sum->count	= (int32)(l = (len / blength) + (sum->remainder != 0));
++
++	if ((int64)sum->count != l)
++		sum->count = -1;
++
++	if (sum->count && DEBUG_GTE(DELTASUM, 2)) {
++		rprintf(FINFO,
++			"count=%s rem=%ld blength=%ld s2length=%d flength=%s\n",
++			big_num(sum->count), (long)sum->remainder, (long)sum->blength,
++			sum->s2length, big_num(sum->flength));
++	}
++}
++
++
++/*
++ * Generate and send a stream of signatures/checksums that describe a buffer
++ *
++ * Generate approximately one checksum every block_len bytes.
++ */
++static int generate_and_send_sums(int fd, OFF_T len, int f_out, int f_copy)
++{
++	int32 i;
++	struct map_struct *mapbuf;
++	struct sum_struct sum;
++	OFF_T offset = 0;
++
++	sum_sizes_sqroot(&sum, len);
++	if (sum.count < 0)
++		return -1;
++	write_sum_head(f_out, &sum);
++
++	if (append_mode > 0 && f_copy < 0)
++		return 0;
++
++	if (len > 0)
++		mapbuf = map_file(fd, len, MAX_MAP_SIZE, sum.blength);
++	else
++		mapbuf = NULL;
++
++	for (i = 0; i < sum.count; i++) {
++		int32 n1 = (int32)MIN(len, (OFF_T)sum.blength);
++		char *map = map_ptr(mapbuf, offset, n1);
++		char sum2[MAX_DIGEST_LEN];
++		uint32 sum1;
++
++		len -= n1;
++		offset += n1;
++
++		if (f_copy >= 0) {
++			full_write(f_copy, map, n1);
++			if (append_mode > 0)
++				continue;
++		}
++
++		sum1 = get_checksum1(map, n1);
++		get_checksum2(map, n1, sum2);
++
++		if (DEBUG_GTE(DELTASUM, 3)) {
++			rprintf(FINFO,
++				"chunk[%s] offset=%s len=%ld sum1=%08lx\n",
++				big_num(i), big_num(offset - n1), (long)n1,
++				(unsigned long)sum1);
++		}
++		write_int(f_out, sum1);
++		write_buf(f_out, sum2, sum.s2length);
++	}
++
++	if (mapbuf)
++		unmap_file(mapbuf);
++
++	return 0;
++}
++
++
++/* Try to find a filename in the same dir as "fname" with a similar name. */
++static struct file_struct *find_fuzzy(struct file_struct *file, struct file_list *dirlist_array[], uchar *fnamecmp_type_ptr)
++{
++	int fname_len, fname_suf_len;
++	const char *fname_suf, *fname = file->basename;
++	uint32 lowest_dist = 25 << 16; /* ignore a distance greater than 25 */
++	int i, j;
++	struct file_struct *lowest_fp = NULL;
++
++	fname_len = strlen(fname);
++	fname_suf = find_filename_suffix(fname, fname_len, &fname_suf_len);
++
++	/* Try to find an exact size+mtime match first. */
++	for (i = 0; i < fuzzy_basis; i++) {
++		struct file_list *dirlist = dirlist_array[i];
++
++		if (!dirlist)
++			continue;
++
++		for (j = 0; j < dirlist->used; j++) {
++			struct file_struct *fp = dirlist->files[j];
++
++			if (!F_IS_ACTIVE(fp))
++				continue;
++
++			if (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)
++				continue;
++
++			if (F_LENGTH(fp) == F_LENGTH(file) && same_time(fp->modtime, 0, file->modtime, 0)) {
++				if (DEBUG_GTE(FUZZY, 2))
++					rprintf(FINFO, "fuzzy size/modtime match for %s\n", f_name(fp, NULL));
++				*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;
++				return fp;
++			}
++
++		}
++	}
++
++	for (i = 0; i < fuzzy_basis; i++) {
++		struct file_list *dirlist = dirlist_array[i];
++
++		if (!dirlist)
++			continue;
++
++		for (j = 0; j < dirlist->used; j++) {
++			struct file_struct *fp = dirlist->files[j];
++			const char *suf, *name;
++			int len, suf_len;
++			uint32 dist;
++
++			if (!F_IS_ACTIVE(fp))
++				continue;
++
++			if (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)
++				continue;
++
++			name = fp->basename;
++			len = strlen(name);
++			suf = find_filename_suffix(name, len, &suf_len);
++
++			dist = fuzzy_distance(name, len, fname, fname_len, lowest_dist);
++			/* Add some extra weight to how well the suffixes match unless we've already disqualified
++			 * this file based on a heuristic. */
++			if (dist < 0xFFFF0000U) {
++				dist += fuzzy_distance(suf, suf_len, fname_suf, fname_suf_len, 0xFFFF0000U) * 10;
++			}
++			if (DEBUG_GTE(FUZZY, 2)) {
++				rprintf(FINFO, "fuzzy distance for %s = %d.%05d\n",
++					f_name(fp, NULL), (int)(dist>>16), (int)(dist&0xFFFF));
++			}
++			if (dist <= lowest_dist) {
++				lowest_dist = dist;
++				lowest_fp = fp;
++				*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;
++			}
++		}
++	}
++
++	return lowest_fp;
++}
++
++/* Copy a file found in our --copy-dest handling. */
++static int copy_altdest_file(const char *src, const char *dest, struct file_struct *file)
++{
++	char buf[MAXPATHLEN];
++	const char *copy_to, *partialptr;
++	int save_preserve_xattrs = preserve_xattrs;
++	int ok, fd_w;
++
++	if (inplace) {
++		/* Let copy_file open the destination in place. */
++		fd_w = -1;
++		copy_to = dest;
++	} else {
++		fd_w = open_tmpfile(buf, dest, file);
++		if (fd_w < 0)
++			return -1;
++		copy_to = buf;
++	}
++	cleanup_set(copy_to, NULL, NULL, -1, -1);
++	if (copy_file(src, copy_to, fd_w, file->mode) < 0) {
++		if (INFO_GTE(COPY, 1)) {
++			rsyserr(FINFO, errno, "copy_file %s => %s",
++				full_fname(src), copy_to);
++		}
++		/* Try to clean up. */
++		unlink(copy_to);
++		cleanup_disable();
++		return -1;
++	}
++	partialptr = partial_dir ? partial_dir_fname(dest) : NULL;
++	preserve_xattrs = 0; /* xattrs were copied with file */
++	ok = finish_transfer(dest, copy_to, src, partialptr, file, 1, 0);
++	preserve_xattrs = save_preserve_xattrs;
++	cleanup_disable();
++	return ok ? 0 : -1;
++}
++
++/* This is only called for regular files.  We return -2 if we've finished
++ * handling the file, -1 if no dest-linking occurred, or a non-negative
++ * value if we found an alternate basis file.  If we're called with the
++ * find_exact_for_existing flag, the destination file already exists, so
++ * we only try to find an exact alt-dest match.  In this case, the returns
++ * are only -2 & -1 (both as above). */
++static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
++			 char *cmpbuf, stat_x *sxp, int find_exact_for_existing,
++			 int itemizing, enum logcode code)
++{
++	STRUCT_STAT real_st = sxp->st;
++	int best_match = -1;
++	int match_level = 0;
++	int j = 0;
++
++	do {
++		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
++		if (link_stat(cmpbuf, &sxp->st, 0) < 0 || !S_ISREG(sxp->st.st_mode))
++			continue;
++		if (match_level == 0) {
++			best_match = j;
++			match_level = 1;
++		}
++		if (!quick_check_ok(FT_REG, cmpbuf, file, &sxp->st))
++			continue;
++		if (match_level == 1) {
++			best_match = j;
++			match_level = 2;
++		}
++		if (alt_dest_type == CLONE_DEST || unchanged_attrs(cmpbuf, file, sxp)) {
++			best_match = j;
++			match_level = 3;
++			break;
++		}
++		free_stat_x(sxp);
++	} while (basis_dir[++j] != NULL);
++
++	if (!match_level)
++		goto got_nothing_for_ya;
++
++	if (j != best_match) {
++		j = best_match;
++		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
++		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
++			goto got_nothing_for_ya;
++	}
++
++	if (match_level == 3 && alt_dest_type != COPY_DEST) {
++		if (find_exact_for_existing) {
++			if (alt_dest_type == LINK_DEST && real_st.st_dev == sxp->st.st_dev && real_st.st_ino == sxp->st.st_ino)
++				return -1;
++			if (do_unlink(fname) < 0 && errno != ENOENT)
++				goto got_nothing_for_ya;
++		}
++#ifdef SUPPORT_HARD_LINKS
++		if (alt_dest_type == LINK_DEST || alt_dest_type == CLONE_DEST) {
++			if (alt_dest_type == LINK_DEST) {
++				if (!hard_link_one(file, fname, cmpbuf, 1))
++					goto try_a_copy;
++			} else if (do_clone(cmpbuf, fname, file->mode) == 0) {
++				finish_transfer(fname, fname, cmpbuf, NULL, file, 1, 0);
++			} else {
++				rsyserr(FERROR_XFER, errno, "failed to clone %s to %s", cmpbuf, fname);
++				exit_cleanup(RERR_UNSUPPORTED);
++			}
++			if (atimes_ndx)
++				set_file_attrs(fname, file, sxp, NULL, 0);
++			if (preserve_hard_links && F_IS_HLINKED(file))
++				finish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, j);
++			if (!maybe_ATTRS_REPORT && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {
++				itemize(cmpbuf, file, ndx, 1, sxp,
++					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
++					0, "");
++			}
++		} else
++#endif
++		{
++			if (itemizing)
++				itemize(cmpbuf, file, ndx, 0, sxp, 0, 0, NULL);
++		}
++		if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)
++			rprintf(FCLIENT, "%s is uptodate\n", fname);
++		return -2;
++	}
++
++	if (find_exact_for_existing)
++		goto got_nothing_for_ya;
++
++	if (match_level >= 2) {
++#ifdef SUPPORT_HARD_LINKS
++	  try_a_copy: /* Copy the file locally. */
++#endif
++		if (!dry_run && copy_altdest_file(cmpbuf, fname, file) < 0) {
++			if (find_exact_for_existing) /* Can get here via hard-link failure */
++				goto got_nothing_for_ya;
++			return -1;
++		}
++		if (itemizing)
++			itemize(cmpbuf, file, ndx, 0, sxp, ITEM_LOCAL_CHANGE, 0, NULL);
++		if (maybe_ATTRS_REPORT
++		 && ((!itemizing && INFO_GTE(NAME, 1) && match_level == 2)
++		  || (INFO_GTE(NAME, 2) && match_level == 3))) {
++			code = match_level == 3 ? FCLIENT : FINFO;
++			rprintf(code, "%s%s\n", fname,
++				match_level == 3 ? " is uptodate" : "");
++		}
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && F_IS_HLINKED(file))
++			finish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, -1);
++#endif
++		return -2;
++	}
++
++	return FNAMECMP_BASIS_DIR_LOW + j;
++
++got_nothing_for_ya:
++	sxp->st = real_st;
++	return -1;
++}
++
++/* This is only called for non-regular files.  We return -2 if we've finished
++ * handling the file, or -1 if no dest-linking occurred, or a non-negative
++ * value if we found an alternate basis file. */
++static int try_dests_non(struct file_struct *file, char *fname, int ndx,
++			 char *cmpbuf, stat_x *sxp, int itemizing,
++			 enum logcode code)
++{
++	int best_match = -1;
++	int match_level = 0;
++	enum filetype ftype = get_file_type(file->mode);
++	int j = 0;
++
++#ifndef SUPPORT_LINKS
++	if (ftype == FT_SYMLINK)
++		return -1;
++#endif
++	if (ftype == FT_REG || ftype == FT_UNSUPPORTED) {
++		rprintf(FERROR,
++			"internal: try_dests_non() called with invalid mode (%o)\n",
++			(int)file->mode);
++		exit_cleanup(RERR_UNSUPPORTED);
++	}
++
++	do {
++		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
++		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
++			continue;
++		if (ftype != get_file_type(sxp->st.st_mode))
++			continue;
++		if (match_level < 1) {
++			match_level = 1;
++			best_match = j;
++		}
++		if (!quick_check_ok(ftype, cmpbuf, file, &sxp->st))
++			continue;
++		if (match_level < 2) {
++			match_level = 2;
++			best_match = j;
++		}
++		if (unchanged_attrs(cmpbuf, file, sxp)) {
++			match_level = 3;
++			best_match = j;
++			break;
++		}
++	} while (basis_dir[++j] != NULL);
++
++	if (!match_level)
++		return -1;
++
++	if (j != best_match) {
++		j = best_match;
++		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
++		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
++			return -1;
++	}
++
++	if (match_level == 3) {
++#ifdef SUPPORT_HARD_LINKS
++		if ((alt_dest_type == LINK_DEST || alt_dest_type == CLONE_DEST)
++#ifndef CAN_HARDLINK_SYMLINK
++		 && !S_ISLNK(file->mode)
++#endif
++#ifndef CAN_HARDLINK_SPECIAL
++		 && !IS_SPECIAL(file->mode) && !IS_DEVICE(file->mode)
++#endif
++		 && !S_ISDIR(file->mode)) {
++			if (do_link(cmpbuf, fname) < 0) {
++				rsyserr(FERROR_XFER, errno,
++					"failed to hard-link %s with %s",
++					cmpbuf, fname);
++				return j;
++			}
++			if (preserve_hard_links && F_IS_HLINKED(file))
++				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
++		} else
++#endif
++			match_level = 2;
++		if (itemizing && stdout_format_has_i
++		 && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {
++			int chg = alt_dest_type == COMPARE_DEST && ftype != FT_DIR ? 0
++			    : ITEM_LOCAL_CHANGE + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);
++			char *lp = match_level == 3 ? "" : NULL;
++			itemize(cmpbuf, file, ndx, 0, sxp, chg + ITEM_MATCHED, 0, lp);
++		}
++		if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT) {
++			rprintf(FCLIENT, "%s%s is uptodate\n",
++				fname, ftype == FT_DIR ? "/" : "");
++		}
++		return -2;
++	}
++
++	return j;
++}
++
++static void list_file_entry(struct file_struct *f)
++{
++	char permbuf[PERMSTRING_SIZE];
++	const char *mtime_str = timestring(f->modtime);
++	int size_width = human_readable ? 14 : 11;
++	int mtime_width = 1 + strlen(mtime_str);
++	int atime_width = atimes_ndx ? mtime_width : 0;
++	int crtime_width = crtimes_ndx ? mtime_width : 0;
++
++	if (!F_IS_ACTIVE(f)) {
++		/* this can happen if duplicate names were removed */
++		return;
++	}
++
++	/* TODO: indicate '+' if the entry has an ACL. */
++
++	if (missing_args == 2 && f->mode == 0) {
++		rprintf(FINFO, "%-*s %s\n",
++			10 + 1 + size_width + mtime_width + atime_width + crtime_width, "*missing",
++			f_name(f, NULL));
++	} else {
++		const char *atime_str = atimes_ndx && !S_ISDIR(f->mode) ? timestring(F_ATIME(f)) : "";
++		const char *crtime_str = crtimes_ndx ? timestring(F_CRTIME(f)) : "";
++		const char *arrow, *lnk;
++
++		permstring(permbuf, f->mode);
++
++#ifdef SUPPORT_LINKS
++		if (preserve_links && S_ISLNK(f->mode)) {
++			arrow = " -> ";
++			lnk = F_SYMLINK(f);
++		} else
++#endif
++			arrow = lnk = "";
++
++		rprintf(FINFO, "%s %*s %s%*s%*s %s%s%s\n",
++			permbuf, size_width, human_num(F_LENGTH(f)),
++			timestring(f->modtime), atime_width, atime_str, crtime_width, crtime_str,
++			f_name(f, NULL), arrow, lnk);
++	}
++}
++
++static struct bitbag *delayed_bits = NULL;
++static int phase = 0;
++static int dflt_perms;
++
++static int implied_dirs_are_missing;
++/* Helper for recv_generator's skip_dir and dry_missing_dir tests. */
++static BOOL is_below(struct file_struct *file, struct file_struct *subtree)
++{
++	return F_DEPTH(file) > F_DEPTH(subtree)
++		&& (!implied_dirs_are_missing || f_name_has_prefix(file, subtree));
++}
++
++/* Acts on the indicated item in cur_flist whose name is fname.  If a dir,
++ * make sure it exists, and has the right permissions/timestamp info.  For
++ * all other non-regular files (symlinks, etc.) we create them here.  For
++ * regular files that have changed, we try to find a basis file and then
++ * start sending checksums.  The ndx is the file's unique index value.
++ *
++ * The fname parameter must point to a MAXPATHLEN buffer!  (e.g it gets
++ * passed to delete_item(), which can use it during a recursive delete.)
++ *
++ * Note that f_out is set to -1 when doing final directory-permission and
++ * modification-time repair. */
++static void recv_generator(char *fname, struct file_struct *file, int ndx,
++			   int itemizing, enum logcode code, int f_out)
++{
++	static const char *parent_dirname = "";
++	static struct file_struct *prior_dir_file = NULL;
++	/* Missing dir not created due to --dry-run; will still be scanned. */
++	static struct file_struct *dry_missing_dir = NULL;
++	/* Missing dir whose contents are skipped altogether due to
++	 * --ignore-non-existing, daemon exclude, or mkdir failure. */
++	static struct file_struct *skip_dir = NULL;
++	static struct file_list *fuzzy_dirlist[MAX_BASIS_DIRS+1];
++	static int need_fuzzy_dirlist = 0;
++	struct file_struct *fuzzy_file = NULL;
++	int fd = -1, f_copy = -1;
++	stat_x sx, real_sx;
++	STRUCT_STAT partial_st;
++	struct file_struct *back_file = NULL;
++	int statret, real_ret, stat_errno;
++	char *fnamecmp, *partialptr, *backupptr = NULL;
++	char fnamecmpbuf[MAXPATHLEN];
++	uchar fnamecmp_type;
++	int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
++	enum filetype stype, ftype = get_file_type(file->mode);
++	int is_dir = ftype != FT_DIR ? 0
++		   : inc_recurse && ndx != cur_flist->ndx_start - 1 ? -1
++		   : 1;
++
++	if (DEBUG_GTE(GENR, 1))
++		rprintf(FINFO, "recv_generator(%s,%d)\n", fname, ndx);
++
++	if (list_only) {
++		if (is_dir < 0
++		 || (is_dir && !implied_dirs && file->flags & FLAG_IMPLIED_DIR))
++			return;
++		list_file_entry(file);
++		return;
++	}
++
++	maybe_ATTRS_ACCURATE_TIME = always_checksum ? ATTRS_ACCURATE_TIME : 0;
++
++	if (skip_dir) {
++		if (is_below(file, skip_dir)) {
++			if (is_dir)
++				file->flags |= FLAG_MISSING_DIR;
++#ifdef SUPPORT_HARD_LINKS
++			else if (F_IS_HLINKED(file))
++				handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++			return;
++		}
++		skip_dir = NULL;
++	}
++
++	init_stat_x(&sx);
++	if (daemon_filter_list.head && (*fname != '.' || fname[1])) {
++		if (check_filter(&daemon_filter_list, FLOG, fname, is_dir) < 0) {
++			if (is_dir < 0)
++				return;
++#ifdef SUPPORT_HARD_LINKS
++			if (F_IS_HLINKED(file))
++				handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++			rprintf(FERROR_XFER,
++				"ERROR: daemon refused to receive %s \"%s\"\n",
++				is_dir ? "directory" : "file", fname);
++			if (is_dir)
++				goto skipping_dir_contents;
++			return;
++		}
++	}
++
++	if (dry_run > 1 || (dry_missing_dir && is_below(file, dry_missing_dir))) {
++		int i;
++	  parent_is_dry_missing:
++		for (i = 0; i < fuzzy_basis; i++) {
++			if (fuzzy_dirlist[i]) {
++				flist_free(fuzzy_dirlist[i]);
++				fuzzy_dirlist[i] = NULL;
++			}
++		}
++		parent_dirname = "";
++		statret = -1;
++		stat_errno = ENOENT;
++	} else {
++		const char *dn = file->dirname ? file->dirname : ".";
++		dry_missing_dir = NULL;
++		if (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {
++			/* Each parent dir must be in the file list or the flist data is bad.
++			 * Optimization: most of the time the parent dir will be the last dir
++			 * this function was asked to process in the file list. */
++			if (!inc_recurse
++			 && (*dn != '.' || dn[1]) /* Avoid an issue with --relative and the "." dir. */
++			 && (!prior_dir_file || strcmp(dn, f_name(prior_dir_file, NULL)) != 0)) {
++				int ok = 0, j = flist_find_name(cur_flist, dn, -1);
++				if (j >= 0) {
++					struct file_struct *f = cur_flist->sorted[j];
++					if (S_ISDIR(f->mode) || (missing_args == 2 && !file->mode && !f->mode))
++						ok = 1;
++				}
++				/* The --delete-missing-args option can actually put invalid entries into
++				 * the file list, so if that option was specified, we'll just complain about
++				 * it and allow it. */
++				if (!ok && missing_args == 2 && file->mode == 0 && j < 0)
++					rprintf(FERROR, "WARNING: parent dir is absent in the file list: %s\n", dn);
++				else if (!ok) {
++					rprintf(FERROR, "ABORTING due to invalid path from sender: %s/%s\n",
++						dn, file->basename);
++					exit_cleanup(RERR_PROTOCOL);
++				}
++			}
++			if (relative_paths && !implied_dirs && file->mode != 0
++			 && do_stat(dn, &sx.st) < 0) {
++				if (dry_run)
++					goto parent_is_dry_missing;
++				if (make_path(fname, ACCESSPERMS, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0) {
++					rsyserr(FERROR_XFER, errno,
++						"recv_generator: mkdir %s failed",
++						full_fname(dn));
++				}
++			}
++			if (fuzzy_basis) {
++				int i;
++				for (i = 0; i < fuzzy_basis; i++) {
++					if (fuzzy_dirlist[i]) {
++						flist_free(fuzzy_dirlist[i]);
++						fuzzy_dirlist[i] = NULL;
++					}
++				}
++				need_fuzzy_dirlist = 1;
++			}
++#ifdef SUPPORT_ACLS
++			if (!preserve_perms)
++				dflt_perms = default_perms_for_dir(dn);
++#endif
++		}
++		parent_dirname = dn;
++
++		statret = link_stat(fname, &sx.st, keep_dirlinks && is_dir);
++		stat_errno = errno;
++	}
++
++	if (missing_args == 2 && file->mode == 0) {
++		if (filter_list.head && check_filter(&filter_list, FINFO, fname, is_dir) < 0)
++			return;
++		if (statret == 0)
++			delete_item(fname, sx.st.st_mode, del_opts);
++		return;
++	}
++
++	if (ignore_non_existing > 0 && statret == -1 && stat_errno == ENOENT) {
++		if (is_dir) {
++			if (is_dir < 0)
++				return;
++			skip_dir = file;
++			file->flags |= FLAG_MISSING_DIR;
++		}
++#ifdef SUPPORT_HARD_LINKS
++		else if (F_IS_HLINKED(file))
++			handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++		if (INFO_GTE(SKIP, 1)) {
++			rprintf(FINFO, "not creating new %s \"%s\"\n",
++				is_dir ? "directory" : "file", fname);
++		}
++		return;
++	}
++
++	if (statret == 0 && !(sx.st.st_mode & S_IWUSR)
++	 && !am_root && sx.st.st_uid == our_uid)
++		del_opts |= DEL_NO_UID_WRITE;
++
++	if (statret == 0)
++		stype = get_file_type(sx.st.st_mode);
++	else
++		stype = FT_UNSUPPORTED;
++
++	if (ignore_existing > 0 && statret == 0
++	 && (!is_dir || stype != FT_DIR)) {
++		if (INFO_GTE(SKIP, 1) && is_dir >= 0) {
++			const char *suf = "";
++			if (INFO_GTE(SKIP, 2)) {
++				if (ftype != stype)
++					suf = " (type change)";
++				else if (!quick_check_ok(ftype, fname, file, &sx.st))
++					suf = always_checksum ? " (sum change)" : " (file change)";
++				else if (!unchanged_attrs(fname, file, &sx))
++					suf = " (attr change)";
++				else
++					suf = " (uptodate)";
++			}
++			rprintf(FINFO, "%s exists%s\n", fname, suf);
++		}
++#ifdef SUPPORT_HARD_LINKS
++		if (F_IS_HLINKED(file))
++			handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++		goto cleanup;
++	}
++
++	fnamecmp = fname;
++
++	if (is_dir) {
++		mode_t added_perms;
++		if (!implied_dirs && file->flags & FLAG_IMPLIED_DIR)
++			goto cleanup;
++		if (am_root < 0) {
++			/* For --fake-super, the dir must be useable by the copying
++			 * user, just like it would be for root. */
++			added_perms = S_IRUSR|S_IWUSR|S_IXUSR;
++		} else
++			added_perms = 0;
++		if (is_dir < 0) {
++			if (!preserve_mtimes || omit_dir_times)
++				goto cleanup;
++			/* In inc_recurse mode we want to make sure any missing
++			 * directories get created while we're still processing
++			 * the parent dir (which allows us to touch the parent
++			 * dir's mtime right away).  We will handle the dir in
++			 * full later (right before we handle its contents). */
++			if (statret == 0
++			 && (stype == FT_DIR
++			  || delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0))
++				goto cleanup; /* Any errors get reported later. */
++			if (do_mkdir(fname, (file->mode|added_perms) & 0700) == 0)
++				file->flags |= FLAG_DIR_CREATED;
++			goto cleanup;
++		}
++		/* The file to be received is a directory, so we need
++		 * to prepare appropriately.  If there is already a
++		 * file of that name and it is *not* a directory, then
++		 * we need to delete it.  If it doesn't exist, then
++		 * (perhaps recursively) create it. */
++		if (statret == 0 && stype != FT_DIR) {
++			if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0)
++				goto skipping_dir_contents;
++			statret = -1;
++		}
++		if (dry_run && statret != 0) {
++			if (!dry_missing_dir)
++				dry_missing_dir = file;
++			file->flags |= FLAG_MISSING_DIR;
++		}
++		init_stat_x(&real_sx);
++		real_sx.st = sx.st;
++		real_ret = statret;
++		if (file->flags & FLAG_DIR_CREATED)
++			statret = -1;
++		if (!preserve_perms) { /* See comment in non-dir code below. */
++			file->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms, statret == 0);
++		}
++		if (statret != 0 && basis_dir[0] != NULL) {
++			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);
++			if (j == -2) {
++				itemizing = 0;
++				code = FNONE;
++				statret = 1;
++			} else if (j >= 0) {
++				statret = 1;
++				fnamecmp = fnamecmpbuf;
++			}
++		}
++		if (itemizing && f_out != -1) {
++			itemize(fnamecmp, file, ndx, statret, &sx,
++				statret ? ITEM_LOCAL_CHANGE : 0, 0, NULL);
++		}
++		if (real_ret != 0 && do_mkdir(fname,file->mode|added_perms) < 0 && errno != EEXIST) {
++			if (!relative_paths || errno != ENOENT
++			 || make_path(fname, ACCESSPERMS, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0
++			 || (do_mkdir(fname, file->mode|added_perms) < 0 && errno != EEXIST)) {
++				rsyserr(FERROR_XFER, errno,
++					"recv_generator: mkdir %s failed",
++					full_fname(fname));
++			  skipping_dir_contents:
++				rprintf(FERROR, "*** Skipping any contents from this failed directory ***\n");
++				skip_dir = file;
++				file->flags |= FLAG_MISSING_DIR;
++				goto cleanup;
++			}
++		}
++
++#ifdef SUPPORT_XATTRS
++		if (preserve_xattrs && statret == 1)
++			copy_xattrs(fnamecmpbuf, fname);
++#endif
++		if (set_file_attrs(fname, file, real_ret ? NULL : &real_sx, NULL, 0)
++		 && INFO_GTE(NAME, 1) && code != FNONE && f_out != -1)
++			rprintf(code, "%s/\n", fname);
++
++		/* We need to ensure that the dirs in the transfer have both
++		 * readable and writable permissions during the time we are
++		 * putting files within them.  This is then restored to the
++		 * former permissions after the transfer is done. */
++#ifdef HAVE_CHMOD
++		if (!am_root && (file->mode & S_IRWXU) != S_IRWXU && dir_tweaking) {
++			mode_t mode = file->mode | S_IRWXU;
++			if (do_chmod(fname, mode) < 0) {
++				rsyserr(FERROR_XFER, errno,
++					"failed to modify permissions on %s",
++					full_fname(fname));
++			}
++			need_retouch_dir_perms = 1;
++		}
++#endif
++
++		if (real_ret != 0 && one_file_system)
++			real_sx.st.st_dev = filesystem_dev;
++		if (inc_recurse) {
++			if (one_file_system) {
++				uint32 *devp = F_DIR_DEV_P(file);
++				DEV_MAJOR(devp) = major(real_sx.st.st_dev);
++				DEV_MINOR(devp) = minor(real_sx.st.st_dev);
++			}
++		}
++		else if (delete_during && f_out != -1 && !phase
++		    && !(file->flags & FLAG_MISSING_DIR)) {
++			if (file->flags & FLAG_CONTENT_DIR) {
++				if (detect_renamed && real_ret != 0)
++					unexplored_dirs++;
++				delete_in_dir(fname, file, real_sx.st.st_dev,
++					      delete_during < 0 ? DEL_NO_DELETIONS : 0);
++			} else
++				change_local_filter_dir(fname, strlen(fname), F_DEPTH(file));
++		}
++		prior_dir_file = file;
++		goto cleanup;
++	}
++
++	/* If we're not preserving permissions, change the file-list's
++	 * mode based on the local permissions and some heuristics. */
++	if (!preserve_perms) {
++		int exists = statret == 0 && stype != FT_DIR;
++		file->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms, exists);
++	}
++
++#ifdef SUPPORT_HARD_LINKS
++	if (preserve_hard_links && F_HLINK_NOT_FIRST(file)
++	 && hard_link_check(file, ndx, fname, statret, &sx, itemizing, code))
++		goto cleanup;
++#endif
++
++	if (preserve_links && ftype == FT_SYMLINK) {
++#ifdef SUPPORT_LINKS
++		const char *sl = F_SYMLINK(file);
++		if (safe_symlinks && unsafe_symlink(sl, fname)) {
++			if (INFO_GTE(NAME, 1)) {
++				if (solo_file) {
++					/* fname contains the destination path, but we
++					 * want to report the source path. */
++					fname = f_name(file, NULL);
++				}
++				rprintf(FINFO,
++					"ignoring unsafe symlink \"%s\" -> \"%s\"\n",
++					fname, sl);
++			}
++			goto cleanup;
++		}
++		if (statret == 0) {
++			if (stype == FT_SYMLINK && quick_check_ok(stype, fname, file, &sx.st)) {
++				/* The link is pointing to the right place. */
++				set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
++				if (itemizing)
++					itemize(fname, file, ndx, 0, &sx, 0, 0, NULL);
++#ifdef SUPPORT_HARD_LINKS
++				if (preserve_hard_links && F_IS_HLINKED(file))
++					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
++#endif
++				if (remove_source_files == 1)
++					goto return_with_success;
++				goto cleanup;
++			}
++		} else if (basis_dir[0] != NULL) {
++			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);
++			if (j == -2) {
++#ifndef CAN_HARDLINK_SYMLINK
++				if (alt_dest_type == LINK_DEST) {
++					/* Resort to --copy-dest behavior. */
++				} else
++#endif
++				if (alt_dest_type != COPY_DEST)
++					goto cleanup;
++				itemizing = 0;
++				code = FNONE;
++			} else if (j >= 0) {
++				statret = 1;
++				fnamecmp = fnamecmpbuf;
++			}
++		}
++		if (atomic_create(file, fname, sl, NULL, MAKEDEV(0, 0), &sx, statret == 0 ? DEL_FOR_SYMLINK : 0)) {
++			set_file_attrs(fname, file, NULL, NULL, 0);
++			if (itemizing) {
++				if (statret == 0 && stype != FT_SYMLINK)
++					statret = -1;
++				itemize(fnamecmp, file, ndx, statret, &sx,
++					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
++			}
++			if (code != FNONE && INFO_GTE(NAME, 1))
++				rprintf(code, "%s -> %s\n", fname, sl);
++#ifdef SUPPORT_HARD_LINKS
++			if (preserve_hard_links && F_IS_HLINKED(file))
++				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
++#endif
++			/* This does not check remove_source_files == 1
++			 * because this is one of the items that the old
++			 * --remove-sent-files option would remove. */
++			if (remove_source_files)
++				goto return_with_success;
++		}
++#endif
++		goto cleanup;
++	}
++
++	if ((am_root && preserve_devices && ftype == FT_DEVICE)
++	 || (preserve_specials && ftype == FT_SPECIAL)) {
++		dev_t rdev;
++		int del_for_flag;
++		if (ftype == FT_DEVICE) {
++			uint32 *devp = F_RDEV_P(file);
++			rdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
++			del_for_flag = DEL_FOR_DEVICE;
++		} else {
++			rdev = 0;
++			del_for_flag = DEL_FOR_SPECIAL;
++		}
++		if (statret == 0) {
++			if (ftype != stype)
++				statret = -1;
++			else if (quick_check_ok(ftype, fname, file, &sx.st)) {
++				/* The device or special file is identical. */
++				set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
++				if (itemizing)
++					itemize(fname, file, ndx, 0, &sx, 0, 0, NULL);
++#ifdef SUPPORT_HARD_LINKS
++				if (preserve_hard_links && F_IS_HLINKED(file))
++					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
++#endif
++				if (remove_source_files == 1)
++					goto return_with_success;
++				goto cleanup;
++			}
++		} else if (basis_dir[0] != NULL) {
++			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx, itemizing, code);
++			if (j == -2) {
++#ifndef CAN_HARDLINK_SPECIAL
++				if (alt_dest_type == LINK_DEST) {
++					/* Resort to --copy-dest behavior. */
++				} else
++#endif
++				if (alt_dest_type != COPY_DEST)
++					goto cleanup;
++				itemizing = 0;
++				code = FNONE;
++			} else if (j >= 0) {
++				statret = 1;
++				fnamecmp = fnamecmpbuf;
++			}
++		}
++		if (DEBUG_GTE(GENR, 1)) {
++			rprintf(FINFO, "mknod(%s, 0%o, [%ld,%ld])\n",
++				fname, (int)file->mode,
++				(long)major(rdev), (long)minor(rdev));
++		}
++		if (atomic_create(file, fname, NULL, NULL, rdev, &sx, del_for_flag)) {
++			set_file_attrs(fname, file, NULL, NULL, 0);
++			if (itemizing) {
++				itemize(fnamecmp, file, ndx, statret, &sx,
++					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
++			}
++			if (code != FNONE && INFO_GTE(NAME, 1))
++				rprintf(code, "%s\n", fname);
++#ifdef SUPPORT_HARD_LINKS
++			if (preserve_hard_links && F_IS_HLINKED(file))
++				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
++#endif
++			if (remove_source_files == 1)
++				goto return_with_success;
++		}
++		goto cleanup;
++	}
++
++	if (ftype != FT_REG) {
++		if (INFO_GTE(NONREG, 1)) {
++			if (solo_file)
++				fname = f_name(file, NULL);
++			rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
++		}
++		goto cleanup;
++	}
++
++	if (max_size >= 0 && F_LENGTH(file) > max_size) {
++		if (INFO_GTE(SKIP, 1)) {
++			if (solo_file)
++				fname = f_name(file, NULL);
++			rprintf(FINFO, "%s is over max-size\n", fname);
++		}
++		goto cleanup;
++	}
++	if (min_size >= 0 && F_LENGTH(file) < min_size) {
++		if (INFO_GTE(SKIP, 1)) {
++			if (solo_file)
++				fname = f_name(file, NULL);
++			rprintf(FINFO, "%s is under min-size\n", fname);
++		}
++		goto cleanup;
++	}
++
++	if (update_only > 0 && statret == 0 && file->modtime - sx.st.st_mtime < modify_window) {
++		if (INFO_GTE(SKIP, 1))
++			rprintf(FINFO, "%s is newer\n", fname);
++#ifdef SUPPORT_HARD_LINKS
++		if (F_IS_HLINKED(file))
++			handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++		goto cleanup;
++	}
++
++	fnamecmp_type = FNAMECMP_FNAME;
++
++	if (statret == 0 && !(stype == FT_REG || (write_devices && stype == FT_DEVICE))) {
++		if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_FILE) != 0)
++			goto cleanup;
++		statret = -1;
++		stat_errno = ENOENT;
++	}
++
++	if (basis_dir[0] != NULL && (statret != 0 || alt_dest_type != COPY_DEST)) {
++		int j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &sx, statret == 0, itemizing, code);
++		if (j == -2) {
++			if (remove_source_files == 1)
++				goto return_with_success;
++			goto cleanup;
++		}
++		if (j >= 0) {
++			fnamecmp = fnamecmpbuf;
++			fnamecmp_type = j;
++			statret = 0;
++		}
++	}
++
++	init_stat_x(&real_sx);
++	real_sx.st = sx.st; /* Don't copy xattr/acl pointers, as they would free wrong. */
++	real_ret = statret;
++
++	if (partial_dir && (partialptr = partial_dir_fname(fname)) != NULL
++	 && link_stat(partialptr, &partial_st, 0) == 0
++	 && S_ISREG(partial_st.st_mode)) {
++		if (statret != 0)
++			goto prepare_to_open;
++	} else
++		partialptr = NULL;
++
++	if (statret != 0 && fuzzy_basis) {
++		if (need_fuzzy_dirlist) {
++			const char *dn = file->dirname ? file->dirname : ".";
++			int i;
++			strlcpy(fnamecmpbuf, dn, sizeof fnamecmpbuf);
++			for (i = 0; i < fuzzy_basis; i++) {
++				if (i && pathjoin(fnamecmpbuf, MAXPATHLEN, basis_dir[i-1], dn) >= MAXPATHLEN)
++					continue;
++				fuzzy_dirlist[i] = get_dirlist(fnamecmpbuf, -1, GDL_IGNORE_FILTER_RULES | GDL_PERHAPS_DIR);
++				if (fuzzy_dirlist[i] && fuzzy_dirlist[i]->used == 0) {
++					flist_free(fuzzy_dirlist[i]);
++					fuzzy_dirlist[i] = NULL;
++				}
++			}
++			need_fuzzy_dirlist = 0;
++		}
++
++		/* Sets fnamecmp_type to FNAMECMP_FUZZY or above. */
++		fuzzy_file = find_fuzzy(file, fuzzy_dirlist, &fnamecmp_type);
++		if (fuzzy_file) {
++			f_name(fuzzy_file, fnamecmpbuf);
++			if (DEBUG_GTE(FUZZY, 1)) {
++				rprintf(FINFO, "fuzzy basis selected for %s: %s\n",
++					fname, fnamecmpbuf);
++			}
++			sx.st.st_size = F_LENGTH(fuzzy_file);
++			statret = 0;
++			fnamecmp = fnamecmpbuf;
++		}
++	}
++
++	if (statret != 0) {
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
++			cur_flist->in_progress++;
++			goto cleanup;
++		}
++#endif
++		if (stat_errno == ENOENT) {
++			if (detect_renamed && unexplored_dirs > 0
++			 && F_LENGTH(file)) {
++				bitbag_set_bit(delayed_bits, ndx);
++				return;
++			}
++			goto notify_others;
++		}
++		rsyserr(FERROR_XFER, stat_errno, "recv_generator: failed to stat %s",
++			full_fname(fname));
++		goto cleanup;
++	}
++
++	if (write_devices && IS_DEVICE(sx.st.st_mode) && sx.st.st_size == 0) {
++		/* This early open into fd skips the regular open below. */
++		if ((fd = do_open(fnamecmp, O_RDONLY, 0)) >= 0)
++			real_sx.st.st_size = sx.st.st_size = get_device_size(fd, fnamecmp);
++	}
++
++	if (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
++		;
++	else if (fnamecmp_type >= FNAMECMP_FUZZY)
++		;
++	else if (quick_check_ok(FT_REG, fnamecmp, file, &sx.st)) {
++		if (partialptr) {
++			do_unlink(partialptr);
++			handle_partial_dir(partialptr, PDIR_DELETE);
++		}
++		set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT | maybe_ATTRS_ACCURATE_TIME);
++		if (itemizing)
++			itemize(fnamecmp, file, ndx, statret, &sx, 0, 0, NULL);
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && F_IS_HLINKED(file))
++			finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
++#endif
++		if (remove_source_files != 1)
++			goto cleanup;
++	  return_with_success:
++		if (!dry_run)
++			send_msg_success(fname, ndx);
++		goto cleanup;
++	}
++
++	if (append_mode > 0 && sx.st.st_size >= F_LENGTH(file)) {
++#ifdef SUPPORT_HARD_LINKS
++		if (F_IS_HLINKED(file))
++			handle_skipped_hlink(file, itemizing, code, f_out);
++#endif
++		goto cleanup;
++	}
++
++  prepare_to_open:
++	if (partialptr) {
++		sx.st = partial_st;
++		fnamecmp = partialptr;
++		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
++		statret = 0;
++	}
++
++	if (!do_xfers)
++		goto notify_others;
++
++	if (read_batch || whole_file) {
++		if (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {
++			if (!(backupptr = get_backup_name(fname)))
++				goto cleanup;
++			if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
++				goto pretend_missing;
++			if (copy_file(fname, backupptr, -1, back_file->mode) < 0) {
++				unmake_file(back_file);
++				back_file = NULL;
++				goto cleanup;
++			}
++		}
++		goto notify_others;
++	}
++
++	if (fuzzy_dirlist[0]) {
++		int j = flist_find(fuzzy_dirlist[0], file);
++		if (j >= 0) /* don't use changing file as future fuzzy basis */
++			fuzzy_dirlist[0]->files[j]->flags |= FLAG_FILE_SENT;
++	}
++
++	/* open the file */
++	if (fd < 0 && (fd = do_open(fnamecmp, O_RDONLY, 0)) < 0) {
++		rsyserr(FERROR, errno, "failed to open %s, continuing",
++			full_fname(fnamecmp));
++	  pretend_missing:
++		/* pretend the file didn't exist */
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
++			cur_flist->in_progress++;
++			goto cleanup;
++		}
++#endif
++		statret = real_ret = -1;
++		goto notify_others;
++	}
++
++	if (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {
++		if (!(backupptr = get_backup_name(fname))) {
++			goto cleanup;
++		}
++		if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS))) {
++			goto pretend_missing;
++		}
++		if (robust_unlink(backupptr) && errno != ENOENT) {
++			rsyserr(FERROR_XFER, errno, "unlink %s",
++				full_fname(backupptr));
++			unmake_file(back_file);
++			back_file = NULL;
++			goto cleanup;
++		}
++		if ((f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0) {
++			rsyserr(FERROR_XFER, errno, "open %s", full_fname(backupptr));
++			unmake_file(back_file);
++			back_file = NULL;
++			goto cleanup;
++		}
++		fnamecmp_type = FNAMECMP_BACKUP;
++	}
++
++	if (DEBUG_GTE(DELTASUM, 3)) {
++		rprintf(FINFO, "gen mapped %s of size %s\n",
++			fnamecmp, big_num(sx.st.st_size));
++	}
++
++	if (DEBUG_GTE(DELTASUM, 2))
++		rprintf(FINFO, "generating and sending sums for %d\n", ndx);
++
++  notify_others:
++	if (remove_source_files && !delay_updates && !phase && !dry_run)
++		increment_active_files(ndx, itemizing, code);
++	if (inc_recurse && (!dry_run || write_batch < 0))
++		cur_flist->in_progress++;
++#ifdef SUPPORT_HARD_LINKS
++	if (preserve_hard_links && F_IS_HLINKED(file))
++		file->flags |= FLAG_FILE_SENT;
++#endif
++	write_ndx(f_out, ndx);
++	if (itemizing) {
++		int iflags = ITEM_TRANSFER;
++		if (always_checksum > 0)
++			iflags |= ITEM_REPORT_CHANGE;
++		if (fnamecmp_type != FNAMECMP_FNAME)
++			iflags |= ITEM_BASIS_TYPE_FOLLOWS;
++		if (fnamecmp_type >= FNAMECMP_FUZZY)
++			iflags |= ITEM_XNAME_FOLLOWS;
++		itemize(fnamecmp, file, -1, real_ret, &real_sx, iflags, fnamecmp_type,
++			fuzzy_file ? fuzzy_file->basename : NULL);
++		free_stat_x(&real_sx);
++	}
++
++	if (!do_xfers) {
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && F_IS_HLINKED(file))
++			finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
++#endif
++		goto cleanup;
++	}
++	if (read_batch)
++		goto cleanup;
++
++	if (statret != 0 || whole_file)
++		write_sum_head(f_out, NULL);
++	else if (sx.st.st_size <= 0) {
++		write_sum_head(f_out, NULL);
++	} else {
++		if (generate_and_send_sums(fd, sx.st.st_size, f_out, f_copy) < 0) {
++			rprintf(FWARNING,
++				"WARNING: file is too large for checksum sending: %s\n",
++				fnamecmp);
++			write_sum_head(f_out, NULL);
++		}
++	}
++
++  cleanup:
++	if (fd >= 0)
++		close(fd);
++	if (back_file) {
++		int save_preserve_xattrs = preserve_xattrs;
++		if (f_copy >= 0)
++			close(f_copy);
++#ifdef SUPPORT_XATTRS
++		if (preserve_xattrs) {
++			copy_xattrs(fname, backupptr);
++			preserve_xattrs = 0;
++		}
++#endif
++		set_file_attrs(backupptr, back_file, NULL, NULL, 0);
++		preserve_xattrs = save_preserve_xattrs;
++		if (INFO_GTE(BACKUP, 1)) {
++			rprintf(FINFO, "backed up %s to %s\n",
++				fname, backupptr);
++		}
++		unmake_file(back_file);
++	}
++
++	free_stat_x(&sx);
++}
++
++/* If we are replacing an existing hard link, symlink, device, or special file,
++ * create a temp-name item and rename it into place.  A symlimk specifies slnk,
++ * a hard link specifies hlnk, otherwise we create a device based on rdev.
++ * Specify 0 for the del_for_flag if there is not a file to replace.  This
++ * returns 1 on success and 0 on failure. */
++int atomic_create(struct file_struct *file, char *fname, const char *slnk, const char *hlnk,
++		  dev_t rdev, stat_x *sxp, int del_for_flag)
++{
++	char tmpname[MAXPATHLEN];
++	const char *create_name;
++	int skip_atomic, dir_in_the_way = del_for_flag && S_ISDIR(sxp->st.st_mode);
++
++	if (!del_for_flag || dir_in_the_way || tmpdir || !get_tmpname(tmpname, fname, True))
++		skip_atomic = 1;
++	else
++		skip_atomic = 0;
++
++	if (del_for_flag) {
++		if (make_backups > 0 && !dir_in_the_way) {
++			if (!make_backup(fname, skip_atomic))
++				return 0;
++		} else if (skip_atomic) {
++			int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
++			if (delete_item(fname, sxp->st.st_mode, del_opts | del_for_flag) != 0)
++				return 0;
++		}
++	}
++
++	create_name = skip_atomic ? fname : tmpname;
++
++	if (slnk) {
++#ifdef SUPPORT_LINKS
++		if (do_symlink(slnk, create_name) < 0) {
++			rsyserr(FERROR_XFER, errno, "symlink %s -> \"%s\" failed",
++				full_fname(create_name), slnk);
++			return 0;
++		}
++#else
++		return 0;
++#endif
++	} else if (hlnk) {
++#ifdef SUPPORT_HARD_LINKS
++		if (!hard_link_one(file, create_name, hlnk, 0))
++			return 0;
++#else
++		return 0;
++#endif
++	} else {
++		if (do_mknod(create_name, file->mode, rdev) < 0) {
++			rsyserr(FERROR_XFER, errno, "mknod %s failed",
++				full_fname(create_name));
++			return 0;
++		}
++	}
++
++	if (!skip_atomic) {
++		if (do_rename(tmpname, fname) < 0) {
++			rsyserr(FERROR_XFER, errno, "rename %s -> \"%s\" failed",
++				full_fname(tmpname), full_fname(fname));
++			do_unlink(tmpname);
++			return 0;
++		}
++	}
++
++	return 1;
++}
++
++#ifdef SUPPORT_HARD_LINKS
++static void handle_skipped_hlink(struct file_struct *file, int itemizing,
++				 enum logcode code, int f_out)
++{
++	char fbuf[MAXPATHLEN];
++	int new_last_ndx;
++	struct file_list *save_flist = cur_flist;
++
++	/* If we skip the last item in a chain of links and there was a
++	 * prior non-skipped hard-link waiting to finish, finish it now. */
++	if ((new_last_ndx = skip_hard_link(file, &cur_flist)) < 0)
++		return;
++
++	file = cur_flist->files[new_last_ndx - cur_flist->ndx_start];
++	cur_flist->in_progress--; /* undo prior increment */
++	f_name(file, fbuf);
++	recv_generator(fbuf, file, new_last_ndx, itemizing, code, f_out);
++
++	cur_flist = save_flist;
++}
++#endif
++
++static void touch_up_dirs(struct file_list *flist, int ndx)
++{
++	static int counter = 0;
++	struct file_struct *file;
++	char *fname;
++	BOOL fix_dir_perms;
++	int i, start, end;
++
++	if (ndx < 0) {
++		start = 0;
++		end = flist->used - 1;
++	} else
++		start = end = ndx;
++
++	/* Fix any directory permissions that were modified during the
++	 * transfer and/or re-set any tweaked modified-time values. */
++	for (i = start; i <= end; i++, counter++) {
++		file = flist->files[i];
++		if (!F_IS_ACTIVE(file))
++			continue;
++		if (!S_ISDIR(file->mode)
++		 || (!implied_dirs && file->flags & FLAG_IMPLIED_DIR))
++			continue;
++		if (DEBUG_GTE(TIME, 2)) {
++			fname = f_name(file, NULL);
++			rprintf(FINFO, "touch_up_dirs: %s (%d)\n",
++				NS(fname), i);
++		}
++		/* Be sure not to retouch permissions with --fake-super. */
++		fix_dir_perms = !am_root && !(file->mode & S_IWUSR);
++		if (file->flags & FLAG_MISSING_DIR || !(need_retouch_dir_times || fix_dir_perms))
++			continue;
++		fname = f_name(file, NULL);
++		if (fix_dir_perms)
++			do_chmod(fname, file->mode);
++		if (need_retouch_dir_times) {
++			STRUCT_STAT st;
++			if (link_stat(fname, &st, 0) == 0 && mtime_differs(&st, file)) {
++				st.st_mtime = file->modtime;
++#ifdef ST_MTIME_NSEC
++				st.ST_MTIME_NSEC = F_MOD_NSEC_or_0(file);
++#endif
++				set_times(fname, &st);
++			}
++		}
++		if (counter >= loopchk_limit) {
++			if (allowed_lull)
++				maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
++			else
++				maybe_flush_socket(0);
++			counter = 0;
++		}
++	}
++}
++
++void check_for_finished_files(int itemizing, enum logcode code, int check_redo)
++{
++	struct file_struct *file;
++	struct file_list *flist;
++	char fbuf[MAXPATHLEN];
++	int ndx;
++
++	while (1) {
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && (ndx = get_hlink_num()) != -1) {
++			int send_failed = (ndx == -2);
++			if (send_failed)
++				ndx = get_hlink_num();
++			flist = flist_for_ndx(ndx, "check_for_finished_files.1");
++			file = flist->files[ndx - flist->ndx_start];
++			assert(file->flags & FLAG_HLINKED);
++			if (send_failed)
++				handle_skipped_hlink(file, itemizing, code, sock_f_out);
++			else
++				finish_hard_link(file, f_name(file, fbuf), ndx, NULL, itemizing, code, -1);
++			flist->in_progress--;
++			continue;
++		}
++#endif
++
++		if (check_redo && (ndx = get_redo_num()) != -1) {
++			OFF_T save_max_size = max_size;
++			OFF_T save_min_size = min_size;
++			csum_length = SUM_LENGTH;
++			max_size = -1;
++			min_size = -1;
++			ignore_existing = -ignore_existing;
++			ignore_non_existing = -ignore_non_existing;
++			update_only = -update_only;
++			always_checksum = -always_checksum;
++			size_only = -size_only;
++			append_mode = -append_mode;
++			make_backups = -make_backups; /* avoid dup backup w/inplace */
++			ignore_times++;
++
++			flist = cur_flist;
++			cur_flist = flist_for_ndx(ndx, "check_for_finished_files.2");
++
++			file = cur_flist->files[ndx - cur_flist->ndx_start];
++			if (solo_file)
++				strlcpy(fbuf, solo_file, sizeof fbuf);
++			else
++				f_name(file, fbuf);
++			recv_generator(fbuf, file, ndx, itemizing, code, sock_f_out);
++			cur_flist->to_redo--;
++
++			cur_flist = flist;
++
++			csum_length = SHORT_SUM_LENGTH;
++			max_size = save_max_size;
++			min_size = save_min_size;
++			ignore_existing = -ignore_existing;
++			ignore_non_existing = -ignore_non_existing;
++			update_only = -update_only;
++			always_checksum = -always_checksum;
++			size_only = -size_only;
++			append_mode = -append_mode;
++			make_backups = -make_backups;
++			ignore_times--;
++			continue;
++		}
++
++		if (cur_flist == first_flist)
++			break;
++
++		/* We only get here if inc_recurse is enabled. */
++		if (first_flist->in_progress || first_flist->to_redo)
++			break;
++
++		write_ndx(sock_f_out, NDX_DONE);
++		if (!read_batch && !flist_eof) {
++			int old_total = 0;
++			for (flist = first_flist; flist != cur_flist; flist = flist->next)
++				old_total += flist->used;
++			maybe_flush_socket(!flist_eof && file_total - old_total < MIN_FILECNT_LOOKAHEAD/2);
++		}
++
++		if (delete_during == 2 || !dir_tweaking) {
++			/* Skip directory touch-up. */
++		} else if (first_flist->parent_ndx >= 0)
++			touch_up_dirs(dir_flist, first_flist->parent_ndx);
++
++		flist_free(first_flist); /* updates first_flist */
++	}
++}
++
++void generate_files(int f_out, const char *local_name)
++{
++	int i, ndx, next_loopchk = 0;
++	char fbuf[MAXPATHLEN];
++	int itemizing;
++	enum logcode code;
++	int save_info_flist = info_levels[INFO_FLIST];
++	int save_info_progress = info_levels[INFO_PROGRESS];
++
++	if (protocol_version >= 29) {
++		itemizing = 1;
++		maybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;
++		code = logfile_format_has_i ? FNONE : FLOG;
++	} else if (am_daemon) {
++		itemizing = logfile_format_has_i && do_xfers;
++		maybe_ATTRS_REPORT = ATTRS_REPORT;
++		code = itemizing || !do_xfers ? FCLIENT : FINFO;
++	} else if (!am_server) {
++		itemizing = stdout_format_has_i;
++		maybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;
++		code = itemizing ? FNONE : FINFO;
++	} else {
++		itemizing = 0;
++		maybe_ATTRS_REPORT = ATTRS_REPORT;
++		code = FINFO;
++	}
++	solo_file = local_name;
++	dir_tweaking = !(list_only || solo_file || dry_run);
++	need_retouch_dir_times = preserve_mtimes && !omit_dir_times;
++	loopchk_limit = allowed_lull ? allowed_lull * 5 : 200;
++	symlink_timeset_failed_flags = ITEM_REPORT_TIME
++	    | (protocol_version >= 30 || !am_server ? ITEM_REPORT_TIMEFAIL : 0);
++	implied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;
++
++	if (DEBUG_GTE(GENR, 1))
++		rprintf(FINFO, "generator starting pid=%d\n", (int)getpid());
++
++	if (detect_renamed) {
++		delayed_bits = bitbag_create(cur_flist->used);
++		if (!delete_before && !delete_during)
++			delete_during = -1;
++	}
++
++	if (delete_before && !solo_file && cur_flist->used > 0)
++		do_delete_pass();
++	if (delete_during == 2) {
++		deldelay_size = BIGPATHBUFLEN * 4;
++		deldelay_buf = new_array(char, deldelay_size);
++	}
++	info_levels[INFO_FLIST] = info_levels[INFO_PROGRESS] = 0;
++
++	if (append_mode > 0 || detect_renamed || whole_file < 0)
++		whole_file = 0;
++	if (DEBUG_GTE(FLIST, 1)) {
++		rprintf(FINFO, "delta-transmission %s\n",
++			whole_file
++			? "disabled for local transfer or --whole-file"
++			: "enabled");
++	}
++
++	dflt_perms = (ACCESSPERMS & ~orig_umask);
++
++	do {
++#ifdef SUPPORT_HARD_LINKS
++		if (preserve_hard_links && inc_recurse) {
++			while (!flist_eof && file_total < MIN_FILECNT_LOOKAHEAD/2)
++				wait_for_receiver();
++		}
++#endif
++
++		if (inc_recurse && cur_flist->parent_ndx >= 0) {
++			struct file_struct *fp = dir_flist->files[cur_flist->parent_ndx];
++			if (solo_file)
++				strlcpy(fbuf, solo_file, sizeof fbuf);
++			else
++				f_name(fp, fbuf);
++			ndx = cur_flist->ndx_start - 1;
++			recv_generator(fbuf, fp, ndx, itemizing, code, f_out);
++			if (delete_during && dry_run < 2 && !list_only
++			 && !(fp->flags & FLAG_MISSING_DIR)) {
++				if (fp->flags & FLAG_CONTENT_DIR) {
++					dev_t dirdev;
++					if (one_file_system) {
++						uint32 *devp = F_DIR_DEV_P(fp);
++						dirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
++					} else
++						dirdev = MAKEDEV(0, 0);
++					delete_in_dir(fbuf, fp, dirdev, 0);
++				} else
++					change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(fp));
++			}
++		}
++		for (i = cur_flist->low; i <= cur_flist->high; i++) {
++			struct file_struct *file = cur_flist->sorted[i];
++
++			if (!F_IS_ACTIVE(file))
++				continue;
++
++			if (unsort_ndx)
++				ndx = F_NDX(file);
++			else
++				ndx = i + cur_flist->ndx_start;
++
++			if (solo_file)
++				strlcpy(fbuf, solo_file, sizeof fbuf);
++			else
++				f_name(file, fbuf);
++			recv_generator(fbuf, file, ndx, itemizing, code, f_out);
++
++			check_for_finished_files(itemizing, code, 0);
++
++			if (i + cur_flist->ndx_start >= next_loopchk) {
++				if (allowed_lull)
++					maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
++				else
++					maybe_flush_socket(0);
++				next_loopchk += loopchk_limit;
++			}
++		}
++
++		if (!inc_recurse) {
++			write_ndx(f_out, NDX_DONE);
++			break;
++		}
++
++		while (1) {
++			check_for_finished_files(itemizing, code, 1);
++			if (cur_flist->next || flist_eof)
++				break;
++			wait_for_receiver();
++		}
++	} while ((cur_flist = cur_flist->next) != NULL);
++
++	if (delete_during)
++		delete_in_dir(NULL, NULL, dev_zero, 0);
++	if (detect_renamed) {
++		if (delete_during < 0)
++			delete_during = 0;
++		detect_renamed = 0;
++
++		for (i = -1; (i = bitbag_next_bit(delayed_bits, i)) >= 0; ) {
++			struct file_struct *file = cur_flist->files[i];
++			if (local_name)
++				strlcpy(fbuf, local_name, sizeof fbuf);
++			else
++				f_name(file, fbuf);
++			recv_generator(fbuf, file, i, itemizing, code, f_out);
++		}
++	}
++	phase++;
++	if (DEBUG_GTE(GENR, 1))
++		rprintf(FINFO, "generate_files phase=%d\n", phase);
++
++	while (1) {
++		check_for_finished_files(itemizing, code, 1);
++		if (msgdone_cnt)
++			break;
++		wait_for_receiver();
++	}
++
++	phase++;
++	if (DEBUG_GTE(GENR, 1))
++		rprintf(FINFO, "generate_files phase=%d\n", phase);
++
++	write_ndx(f_out, NDX_DONE);
++
++	/* Reduce round-trip lag-time for a useless delay-updates phase. */
++	if (protocol_version >= 29 && EARLY_DELAY_DONE_MSG())
++		write_ndx(f_out, NDX_DONE);
++
++	if (protocol_version >= 31 && EARLY_DELETE_DONE_MSG()) {
++		if ((INFO_GTE(STATS, 2) && (delete_mode || force_delete)) || read_batch)
++			write_del_stats(f_out);
++		if (EARLY_DELAY_DONE_MSG()) /* Can't send this before delay */
++			write_ndx(f_out, NDX_DONE);
++	}
++
++	/* Read MSG_DONE for the redo phase (and any prior messages). */
++	while (1) {
++		check_for_finished_files(itemizing, code, 0);
++		if (msgdone_cnt > 1)
++			break;
++		wait_for_receiver();
++	}
++
++	if (protocol_version >= 29) {
++		phase++;
++		if (DEBUG_GTE(GENR, 1))
++			rprintf(FINFO, "generate_files phase=%d\n", phase);
++		if (!EARLY_DELAY_DONE_MSG()) {
++			write_ndx(f_out, NDX_DONE);
++			if (protocol_version >= 31 && EARLY_DELETE_DONE_MSG())
++				write_ndx(f_out, NDX_DONE);
++		}
++		/* Read MSG_DONE for delay-updates phase & prior messages. */
++		while (msgdone_cnt == 2)
++			wait_for_receiver();
++	}
++
++	info_levels[INFO_FLIST] = save_info_flist;
++	info_levels[INFO_PROGRESS] = save_info_progress;
++
++	if (delete_during == 2)
++		do_delayed_deletions(fbuf);
++	if (delete_after && !solo_file && file_total > 0)
++		do_delete_pass();
++
++	if (max_delete >= 0 && skipped_deletes) {
++		rprintf(FWARNING,
++			"Deletions stopped due to --max-delete limit (%d skipped)\n",
++			skipped_deletes);
++		io_error |= IOERR_DEL_LIMIT;
++	}
++
++	if (protocol_version >= 31) {
++		if (!EARLY_DELETE_DONE_MSG()) {
++			if (INFO_GTE(STATS, 2) || read_batch)
++				write_del_stats(f_out);
++			write_ndx(f_out, NDX_DONE);
++		}
++
++		/* Read MSG_DONE for late-delete phase & prior messages. */
++		while (msgdone_cnt == 3)
++			wait_for_receiver();
++	}
++
++	if ((need_retouch_dir_perms || need_retouch_dir_times)
++	 && dir_tweaking && (!inc_recurse || delete_during == 2))
++		touch_up_dirs(dir_flist, -1);
++
++	if (DEBUG_GTE(GENR, 1))
++		rprintf(FINFO, "generate_files finished\n");
++}
+diff --git a/main.c b/main.c
+index 0c60b86d..eda229a0 100644
+--- a/main.c
++++ b/main.c
+@@ -726,7 +726,7 @@ static char *get_local_name(struct file_list *flist, char *dest_path)
+ 
+ 	if (mkpath_dest_arg && statret < 0 && (cp || file_total > 1)) {
+ 		int save_errno = errno;
+-		int ret = make_path(dest_path, file_total > 1 && !trailing_slash ? 0 : MKP_DROP_NAME);
++		int ret = make_path(dest_path, ACCESSPERMS, file_total > 1 && !trailing_slash ? 0 : MKP_DROP_NAME);
+ 		if (ret < 0)
+ 			goto mkdir_error;
+ 		if (ret && (INFO_GTE(NAME, 1) || stdout_format_has_i)) {
+diff --git a/options.c b/options.c
+index fd674754..7def1216 100644
+--- a/options.c
++++ b/options.c
+@@ -91,6 +91,7 @@ int am_server = 0;
+ int am_sender = 0;
+ int am_starting_up = 1;
+ int relative_paths = -1;
++int detect_renamed = 0;
+ int implied_dirs = 1;
+ int missing_args = 0; /* 0 = FERROR_XFER, 1 = ignore, 2 = delete */
+ int numeric_ids = 0;
+@@ -582,7 +583,7 @@ enum {OPT_SERVER = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
+       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
+       OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG, OPT_BLOCK_SIZE,
+-      OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT, OPT_STDERR,
++      OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT, OPT_STDERR, OPT_CLONE_DEST,
+       OPT_OLD_COMPRESS, OPT_NEW_COMPRESS, OPT_NO_COMPRESS, OPT_OLD_ARGS,
+       OPT_STOP_AFTER, OPT_STOP_AT,
+       OPT_REFUSED_BASE = 9000};
+@@ -743,6 +744,10 @@ static struct poptOption long_options[] = {
+   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
+   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
+   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
++  {"detect-renamed",   0,  POPT_ARG_VAL,    &detect_renamed, 1, 0, 0 },
++  {"detect-renamed-lax",0, POPT_ARG_VAL,    &detect_renamed, 2, 0, 0 },
++  {"detect-moved",     0,  POPT_ARG_VAL,    &detect_renamed, 3, 0, 0 },
++  {"clone-dest",       0,  POPT_ARG_STRING, 0, OPT_CLONE_DEST, 0, 0 },
+   {"fuzzy",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },
+   {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
+   {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
+@@ -1004,6 +1009,9 @@ static void set_refuse_options(void)
+ #ifndef SUPPORT_HARD_LINKS
+ 	parse_one_refuse_match(0, "link-dest", list_end);
+ #endif
++#ifndef FICLONE
++	parse_one_refuse_match(0, "clone-dest", list_end);
++#endif
+ #ifndef HAVE_MKTIME
+ 	parse_one_refuse_match(0, "stop-at", list_end);
+ #endif
+@@ -1333,6 +1341,8 @@ char *alt_dest_opt(int type)
+ 		return "--copy-dest";
+ 	case LINK_DEST:
+ 		return "--link-dest";
++	case CLONE_DEST:
++		return "--clone-dest";
+ 	default:
+ 		NOISY_DEATH("Unknown alt_dest_opt type");
+ 	}
+@@ -1714,6 +1724,10 @@ int parse_arguments(int *argc_p, const char ***argv_p)
+ 			want_dest_type = LINK_DEST;
+ 			goto set_dest_dir;
+ 
++		case OPT_CLONE_DEST:
++			want_dest_type = CLONE_DEST;
++			goto set_dest_dir;
++
+ 		case OPT_COPY_DEST:
+ 			want_dest_type = COPY_DEST;
+ 			goto set_dest_dir;
+@@ -2400,7 +2414,7 @@ int parse_arguments(int *argc_p, const char ***argv_p)
+ 		inplace = 1;
+ 	}
+ 
+-	if (delay_updates && !partial_dir)
++	if ((delay_updates || detect_renamed) && !partial_dir)
+ 		partial_dir = tmp_partialdir;
+ 
+ 	if (inplace) {
+@@ -2409,6 +2423,7 @@ int parse_arguments(int *argc_p, const char ***argv_p)
+ 			snprintf(err_buf, sizeof err_buf,
+ 				 "--%s cannot be used with --%s\n",
+ 				 append_mode ? "append" : "inplace",
++				 detect_renamed ? "detect-renamed" :
+ 				 delay_updates ? "delay-updates" : "partial-dir");
+ 			goto cleanup;
+ 		}
+@@ -2835,6 +2850,14 @@ void server_options(char **args, int *argc_p)
+ 			args[ac++] = "--super";
+ 		if (size_only)
+ 			args[ac++] = "--size-only";
++		if (detect_renamed) {
++			if (detect_renamed == 1)
++				args[ac++] = "--detect-renamed";
++			else if (detect_renamed == 2)
++				args[ac++] = "--detect-renamed-lax";
++			else
++				args[ac++] = "--detect-moved";
++		}
+ 		if (do_stats)
+ 			args[ac++] = "--stats";
+ 	} else {
+diff --git a/options.c.orig b/options.c.orig
+new file mode 100644
+index 00000000..2cc69820
+--- /dev/null
++++ b/options.c.orig
+@@ -0,0 +1,3153 @@
++/*
++ * Command-line (and received via daemon-socket) option parsing.
++ *
++ * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
++ * Copyright (C) 2000, 2001, 2002 Martin Pool <mbp@samba.org>
++ * Copyright (C) 2002-2023 Wayne Davison
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 3 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not, visit the http://fsf.org website.
++ */
++
++#include "rsync.h"
++#include "itypes.h"
++#include "ifuncs.h"
++#include <popt.h>
++
++extern int module_id;
++extern int local_server;
++extern int sanitize_paths;
++extern int trust_sender_args;
++extern int trust_sender_filter;
++extern unsigned int module_dirlen;
++extern filter_rule_list filter_list;
++extern filter_rule_list daemon_filter_list;
++
++int make_backups = 0;
++
++/**
++ * If 1, send the whole file as literal data rather than trying to
++ * create an incremental diff.
++ *
++ * If -1, then look at whether we're local or remote and go by that.
++ *
++ * @sa disable_deltas_p()
++ **/
++int whole_file = -1;
++
++int append_mode = 0;
++int keep_dirlinks = 0;
++int copy_dirlinks = 0;
++int copy_links = 0;
++int copy_devices = 0;
++int write_devices = 0;
++int preserve_links = 0;
++int preserve_hard_links = 0;
++int preserve_acls = 0;
++int preserve_xattrs = 0;
++int preserve_perms = 0;
++int preserve_executability = 0;
++int preserve_devices = 0;
++int preserve_specials = 0;
++int preserve_uid = 0;
++int preserve_gid = 0;
++int preserve_mtimes = 0;
++int preserve_atimes = 0;
++int preserve_crtimes = 0;
++int omit_dir_times = 0;
++int omit_link_times = 0;
++int trust_sender = 0;
++int update_only = 0;
++int open_noatime = 0;
++int cvs_exclude = 0;
++int dry_run = 0;
++int do_xfers = 1;
++int do_fsync = 0;
++int ignore_times = 0;
++int delete_mode = 0;
++int delete_during = 0;
++int delete_before = 0;
++int delete_after = 0;
++int delete_excluded = 0;
++int remove_source_files = 0;
++int one_file_system = 0;
++int protocol_version = PROTOCOL_VERSION;
++int sparse_files = 0;
++int preallocate_files = 0;
++int do_compression = 0;
++int do_compression_level = CLVL_NOT_SPECIFIED;
++int am_root = 0; /* 0 = normal, 1 = root, 2 = --super, -1 = --fake-super */
++int am_server = 0;
++int am_sender = 0;
++int am_starting_up = 1;
++int relative_paths = -1;
++int detect_renamed = 0;
++int implied_dirs = 1;
++int missing_args = 0; /* 0 = FERROR_XFER, 1 = ignore, 2 = delete */
++int numeric_ids = 0;
++int msgs2stderr = 2; /* Default: send errors to stderr for local & remote-shell transfers */
++int saw_stderr_opt = 0;
++int allow_8bit_chars = 0;
++int force_delete = 0;
++int io_timeout = 0;
++int prune_empty_dirs = 0;
++int use_qsort = 0;
++char *files_from = NULL;
++int filesfrom_fd = -1;
++char *filesfrom_host = NULL;
++int eol_nulls = 0;
++int protect_args = -1;
++int old_style_args = -1;
++int human_readable = 1;
++int recurse = 0;
++int mkpath_dest_arg = 0;
++int allow_inc_recurse = 1;
++int xfer_dirs = -1;
++int am_daemon = 0;
++int connect_timeout = 0;
++int keep_partial = 0;
++int safe_symlinks = 0;
++int copy_unsafe_links = 0;
++int munge_symlinks = 0;
++int size_only = 0;
++int daemon_bwlimit = 0;
++int bwlimit = 0;
++int fuzzy_basis = 0;
++size_t bwlimit_writemax = 0;
++int ignore_existing = 0;
++int ignore_non_existing = 0;
++int need_messages_from_generator = 0;
++int max_delete = INT_MIN;
++OFF_T max_size = -1;
++OFF_T min_size = -1;
++int ignore_errors = 0;
++int modify_window = 0;
++int blocking_io = -1;
++int checksum_seed = 0;
++int inplace = 0;
++int delay_updates = 0;
++int32 block_size = 0;
++time_t stop_at_utime = 0;
++char *skip_compress = NULL;
++char *copy_as = NULL;
++item_list dparam_list = EMPTY_ITEM_LIST;
++
++/** Network address family. **/
++int default_af_hint
++#ifdef INET6
++	= 0;		/* Any protocol */
++#else
++	= AF_INET;	/* Must use IPv4 */
++# ifdef AF_INET6
++#  undef AF_INET6
++# endif
++# define AF_INET6 AF_INET /* make -6 option a no-op */
++#endif
++
++/** Do not go into the background when run as --daemon.  Good
++ * for debugging and required for running as a service on W32,
++ * or under Unix process-monitors. **/
++int no_detach
++#if defined _WIN32 || defined __WIN32__
++	= 1;
++#else
++	= 0;
++#endif
++
++int write_batch = 0;
++int read_batch = 0;
++int backup_dir_len = 0;
++int backup_suffix_len;
++unsigned int backup_dir_remainder;
++
++char *backup_suffix = NULL;
++char *tmpdir = NULL;
++char *partial_dir = NULL;
++char *basis_dir[MAX_BASIS_DIRS+1];
++char *config_file = NULL;
++char *shell_cmd = NULL;
++char *logfile_name = NULL;
++char *logfile_format = NULL;
++char *stdout_format = NULL;
++char *password_file = NULL;
++char *early_input_file = NULL;
++char *rsync_path = RSYNC_PATH;
++char *backup_dir = NULL;
++char backup_dir_buf[MAXPATHLEN];
++char *sockopts = NULL;
++char *usermap = NULL;
++char *groupmap = NULL;
++int rsync_port = 0;
++int alt_dest_type = 0;
++int basis_dir_cnt = 0;
++
++#define DEFAULT_MAX_ALLOC (1024L * 1024 * 1024)
++size_t max_alloc = DEFAULT_MAX_ALLOC;
++char *max_alloc_arg;
++
++static int version_opt_cnt = 0;
++static int remote_option_alloc = 0;
++int remote_option_cnt = 0;
++const char **remote_options = NULL;
++const char *checksum_choice = NULL;
++const char *compress_choice = NULL;
++static const char *empty_argv[1];
++
++int quiet = 0;
++int output_motd = 1;
++int log_before_transfer = 0;
++int stdout_format_has_i = 0;
++int stdout_format_has_o_or_i = 0;
++int logfile_format_has_i = 0;
++int logfile_format_has_o_or_i = 0;
++int always_checksum = 0;
++int list_only = 0;
++
++#define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
++char *batch_name = NULL;
++
++int need_unsorted_flist = 0;
++char *iconv_opt =
++#ifdef ICONV_OPTION
++		ICONV_OPTION;
++#else
++		NULL;
++#endif
++
++struct chmod_mode_struct *chmod_modes = NULL;
++
++static const char *debug_verbosity[] = {
++	/*0*/ NULL,
++	/*1*/ NULL,
++	/*2*/ "BIND,CMD,CONNECT,DEL,DELTASUM,DUP,FILTER,FLIST,ICONV",
++	/*3*/ "ACL,BACKUP,CONNECT2,DELTASUM2,DEL2,EXIT,FILTER2,FLIST2,FUZZY,GENR,OWN,RECV,SEND,TIME",
++	/*4*/ "CMD2,DELTASUM3,DEL3,EXIT2,FLIST3,ICONV2,OWN2,PROTO,TIME2",
++	/*5*/ "CHDIR,DELTASUM4,FLIST4,FUZZY2,HASH,HLINK",
++};
++
++#define MAX_VERBOSITY ((int)(sizeof debug_verbosity / sizeof debug_verbosity[0]) - 1)
++
++static const char *info_verbosity[1+MAX_VERBOSITY] = {
++	/*0*/ "NONREG",
++	/*1*/ "COPY,DEL,FLIST,MISC,NAME,STATS,SYMSAFE",
++	/*2*/ "BACKUP,MISC2,MOUNT,NAME2,REMOVE,SKIP",
++};
++
++#define MAX_OUT_LEVEL 4 /* The largest N allowed for any flagN word. */
++
++short info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];
++
++#define DEFAULT_PRIORITY 0 	/* Default/implied/--verbose set values. */
++#define HELP_PRIORITY 1		/* The help output uses this level. */
++#define USER_PRIORITY 2		/* User-specified via --info or --debug */
++#define LIMIT_PRIORITY 3	/* Overriding priority when limiting values. */
++
++#define W_CLI (1<<0)	/* client side */
++#define W_SRV (1<<1)	/* server side */
++#define W_SND (1<<2)	/* sending side */
++#define W_REC (1<<3)	/* receiving side */
++
++struct output_struct {
++	char *name;	/* The name of the info/debug flag. */
++	char *help;	/* The description of the info/debug flag. */
++	uchar namelen;  /* The length of the name string. */
++	uchar flag;	/* The flag's value, for consistency check. */
++	uchar where;	/* Bits indicating where the flag is used. */
++	uchar priority; /* See *_PRIORITY defines. */
++};
++
++#define INFO_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, INFO_##flag, where, 0 }
++
++static struct output_struct info_words[COUNT_INFO+1] = {
++	INFO_WORD(BACKUP, W_REC, "Mention files backed up"),
++	INFO_WORD(COPY, W_REC, "Mention files copied locally on the receiving side"),
++	INFO_WORD(DEL, W_REC, "Mention deletions on the receiving side"),
++	INFO_WORD(FLIST, W_CLI, "Mention file-list receiving/sending (levels 1-2)"),
++	INFO_WORD(MISC, W_SND|W_REC, "Mention miscellaneous information (levels 1-2)"),
++	INFO_WORD(MOUNT, W_SND|W_REC, "Mention mounts that were found or skipped"),
++	INFO_WORD(NAME, W_SND|W_REC, "Mention 1) updated file/dir names, 2) unchanged names"),
++	INFO_WORD(NONREG, W_REC, "Mention skipped non-regular files (default 1, 0 disables)"),
++	INFO_WORD(PROGRESS, W_CLI, "Mention 1) per-file progress or 2) total transfer progress"),
++	INFO_WORD(REMOVE, W_SND, "Mention files removed on the sending side"),
++	INFO_WORD(SKIP, W_REC, "Mention files skipped due to transfer overrides (levels 1-2)"),
++	INFO_WORD(STATS, W_CLI|W_SRV, "Mention statistics at end of run (levels 1-3)"),
++	INFO_WORD(SYMSAFE, W_SND|W_REC, "Mention symlinks that are unsafe"),
++	{ NULL, "--info", 0, 0, 0, 0 }
++};
++
++#define DEBUG_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, DEBUG_##flag, where, 0 }
++
++static struct output_struct debug_words[COUNT_DEBUG+1] = {
++	DEBUG_WORD(ACL, W_SND|W_REC, "Debug extra ACL info"),
++	DEBUG_WORD(BACKUP, W_REC, "Debug backup actions (levels 1-2)"),
++	DEBUG_WORD(BIND, W_CLI, "Debug socket bind actions"),
++	DEBUG_WORD(CHDIR, W_CLI|W_SRV, "Debug when the current directory changes"),
++	DEBUG_WORD(CONNECT, W_CLI, "Debug connection events (levels 1-2)"),
++	DEBUG_WORD(CMD, W_CLI, "Debug commands+options that are issued (levels 1-2)"),
++	DEBUG_WORD(DEL, W_REC, "Debug delete actions (levels 1-3)"),
++	DEBUG_WORD(DELTASUM, W_SND|W_REC, "Debug delta-transfer checksumming (levels 1-4)"),
++	DEBUG_WORD(DUP, W_REC, "Debug weeding of duplicate names"),
++	DEBUG_WORD(EXIT, W_CLI|W_SRV, "Debug exit events (levels 1-3)"),
++	DEBUG_WORD(FILTER, W_SND|W_REC, "Debug filter actions (levels 1-3)"),
++	DEBUG_WORD(FLIST, W_SND|W_REC, "Debug file-list operations (levels 1-4)"),
++	DEBUG_WORD(FUZZY, W_REC, "Debug fuzzy scoring (levels 1-2)"),
++	DEBUG_WORD(GENR, W_REC, "Debug generator functions"),
++	DEBUG_WORD(HASH, W_SND|W_REC, "Debug hashtable code"),
++	DEBUG_WORD(HLINK, W_SND|W_REC, "Debug hard-link actions (levels 1-3)"),
++	DEBUG_WORD(ICONV, W_CLI|W_SRV, "Debug iconv character conversions (levels 1-2)"),
++	DEBUG_WORD(IO, W_CLI|W_SRV, "Debug I/O routines (levels 1-4)"),
++	DEBUG_WORD(NSTR, W_CLI|W_SRV, "Debug negotiation strings"),
++	DEBUG_WORD(OWN, W_REC, "Debug ownership changes in users & groups (levels 1-2)"),
++	DEBUG_WORD(PROTO, W_CLI|W_SRV, "Debug protocol information"),
++	DEBUG_WORD(RECV, W_REC, "Debug receiver functions"),
++	DEBUG_WORD(SEND, W_SND, "Debug sender functions"),
++	DEBUG_WORD(TIME, W_REC, "Debug setting of modified times (levels 1-2)"),
++	{ NULL, "--debug", 0, 0, 0, 0 }
++};
++
++static int verbose = 0;
++static int do_stats = 0;
++static int do_progress = 0;
++static int daemon_opt;   /* sets am_daemon after option error-reporting */
++static int F_option_cnt = 0;
++static int modify_window_set;
++static int itemize_changes = 0;
++static int refused_delete, refused_archive_part, refused_compress;
++static int refused_partial, refused_progress, refused_delete_before;
++static int refused_delete_during;
++static int refused_inplace, refused_no_iconv;
++static BOOL usermap_via_chown, groupmap_via_chown;
++static char *outbuf_mode;
++static char *bwlimit_arg, *max_size_arg, *min_size_arg;
++static char tmp_partialdir[] = ".~tmp~";
++
++/** Local address to bind.  As a character string because it's
++ * interpreted by the IPv6 layer: should be a numeric IP4 or IP6
++ * address, or a hostname. **/
++char *bind_address;
++
++static void output_item_help(struct output_struct *words);
++
++/* This constructs a string that represents all the options set for either
++ * the --info or --debug setting, skipping any implied options (by -v, etc.).
++ * This is used both when conveying the user's options to the server, and
++ * when the help output wants to tell the user what options are implied. */
++static char *make_output_option(struct output_struct *words, short *levels, uchar where)
++{
++	char *str = words == info_words ? "--info=" : "--debug=";
++	int j, counts[MAX_OUT_LEVEL+1], pos, skipped = 0, len = 0, max = 0, lev = 0;
++	int word_count = words == info_words ? COUNT_INFO : COUNT_DEBUG;
++	char *buf;
++
++	memset(counts, 0, sizeof counts);
++
++	for (j = 0; words[j].name; j++) {
++		if (words[j].flag != j) {
++			rprintf(FERROR, "rsync: internal error on %s%s: %d != %d\n",
++				words == info_words ? "INFO_" : "DEBUG_",
++				words[j].name, words[j].flag, j);
++			exit_cleanup(RERR_UNSUPPORTED);
++		}
++		if (!(words[j].where & where))
++			continue;
++		if (words[j].priority == DEFAULT_PRIORITY) {
++			/* Implied items don't need to be mentioned. */
++			skipped++;
++			continue;
++		}
++		len += len ? 1 : strlen(str);
++		len += strlen(words[j].name);
++		len += levels[j] == 1 ? 0 : 1;
++
++		if (words[j].priority == HELP_PRIORITY)
++			continue; /* no abbreviating for help */
++
++		assert(levels[j] <= MAX_OUT_LEVEL);
++		if (++counts[levels[j]] > max) {
++			/* Determine which level has the most items. */
++			lev = levels[j];
++			max = counts[lev];
++		}
++	}
++
++	/* Sanity check the COUNT_* define against the length of the table. */
++	if (j != word_count) {
++		rprintf(FERROR, "rsync: internal error: %s is wrong! (%d != %d)\n",
++			words == info_words ? "COUNT_INFO" : "COUNT_DEBUG",
++			j, word_count);
++		exit_cleanup(RERR_UNSUPPORTED);
++	}
++
++	if (!len)
++		return NULL;
++
++	len++;
++	buf = new_array(char, len);
++	pos = 0;
++
++	if (skipped || max < 5)
++		lev = -1;
++	else {
++		if (lev == 0)
++			pos += snprintf(buf, len, "%sNONE", str);
++		else if (lev == 1)
++			pos += snprintf(buf, len, "%sALL", str);
++		else
++			pos += snprintf(buf, len, "%sALL%d", str, lev);
++	}
++
++	for (j = 0; words[j].name && pos < len; j++) {
++		if (words[j].priority == DEFAULT_PRIORITY || levels[j] == lev || !(words[j].where & where))
++			continue;
++		if (pos)
++			buf[pos++] = ',';
++		else
++			pos += strlcpy(buf+pos, str, len-pos);
++		if (pos < len)
++			pos += strlcpy(buf+pos, words[j].name, len-pos);
++		/* Level 1 is implied by the name alone. */
++		if (levels[j] != 1 && pos < len)
++			buf[pos++] = '0' + levels[j];
++	}
++
++	buf[pos] = '\0';
++
++	return buf;
++}
++
++static void parse_output_words(struct output_struct *words, short *levels, const char *str, uchar priority)
++{
++	const char *s;
++	int j, len, lev;
++
++	for ( ; str; str = s) {
++		if ((s = strchr(str, ',')) != NULL)
++			len = s++ - str;
++		else
++			len = strlen(str);
++		if (!len)
++			continue;
++		if (!isDigit(str)) {
++			while (len && isDigit(str+len-1))
++				len--;
++		}
++		lev = isDigit(str+len) ? atoi(str+len) : 1;
++		if (lev > MAX_OUT_LEVEL)
++			lev = MAX_OUT_LEVEL;
++		if (len == 4 && strncasecmp(str, "help", 4) == 0) {
++			output_item_help(words);
++			exit_cleanup(0);
++		}
++		if (len == 4 && strncasecmp(str, "none", 4) == 0)
++			len = lev = 0;
++		else if (len == 3 && strncasecmp(str, "all", 3) == 0)
++			len = 0;
++		for (j = 0; words[j].name; j++) {
++			if (!len
++			 || (len == words[j].namelen && strncasecmp(str, words[j].name, len) == 0)) {
++				if (priority >= words[j].priority) {
++					words[j].priority = priority;
++					levels[j] = lev;
++				}
++				if (len)
++					break;
++			}
++		}
++		if (len && !words[j].name && !am_server) {
++			rprintf(FERROR, "Unknown %s item: \"%.*s\"\n",
++				words[j].help, len, str);
++			exit_cleanup(RERR_SYNTAX);
++		}
++	}
++}
++
++/* Tell the user what all the info or debug flags mean. */
++static void output_item_help(struct output_struct *words)
++{
++	short *levels = words == info_words ? info_levels : debug_levels;
++	const char **verbosity = words == info_words ? info_verbosity : debug_verbosity;
++	char buf[128], *opt, *fmt = "%-10s %s\n";
++	int j;
++
++	reset_output_levels();
++
++	rprintf(FINFO, "Use OPT or OPT1 for level 1 output, OPT2 for level 2, etc.; OPT0 silences.\n");
++	rprintf(FINFO, "\n");
++	for (j = 0; words[j].name; j++)
++		rprintf(FINFO, fmt, words[j].name, words[j].help);
++	rprintf(FINFO, "\n");
++
++	snprintf(buf, sizeof buf, "Set all %s options (e.g. all%d)",
++		 words[j].help, MAX_OUT_LEVEL);
++	rprintf(FINFO, fmt, "ALL", buf);
++
++	snprintf(buf, sizeof buf, "Silence all %s options (same as all0)",
++		 words[j].help);
++	rprintf(FINFO, fmt, "NONE", buf);
++
++	rprintf(FINFO, fmt, "HELP", "Output this help message");
++	rprintf(FINFO, "\n");
++	rprintf(FINFO, "Options added at each level of verbosity:\n");
++
++	for (j = 0; j <= MAX_VERBOSITY; j++) {
++		parse_output_words(words, levels, verbosity[j], HELP_PRIORITY);
++		opt = make_output_option(words, levels, W_CLI|W_SRV|W_SND|W_REC);
++		if (opt) {
++			rprintf(FINFO, "%d) %s\n", j, strchr(opt, '=')+1);
++			free(opt);
++		}
++		reset_output_levels();
++	}
++}
++
++/* The --verbose option now sets info+debug flags. */
++static void set_output_verbosity(int level, uchar priority)
++{
++	int j;
++
++	if (level > MAX_VERBOSITY)
++		level = MAX_VERBOSITY;
++
++	for (j = 0; j <= level; j++) {
++		parse_output_words(info_words, info_levels, info_verbosity[j], priority);
++		parse_output_words(debug_words, debug_levels, debug_verbosity[j], priority);
++	}
++}
++
++/* Limit the info+debug flag levels given a verbose-option level limit. */
++void limit_output_verbosity(int level)
++{
++	short info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];
++	int j;
++
++	if (level > MAX_VERBOSITY)
++		return;
++
++	memset(info_limits, 0, sizeof info_limits);
++	memset(debug_limits, 0, sizeof debug_limits);
++
++	/* Compute the level limits in the above arrays. */
++	for (j = 0; j <= level; j++) {
++		parse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);
++		parse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);
++	}
++
++	for (j = 0; j < COUNT_INFO; j++) {
++		if (info_levels[j] > info_limits[j])
++			info_levels[j] = info_limits[j];
++	}
++
++	for (j = 0; j < COUNT_DEBUG; j++) {
++		if (debug_levels[j] > debug_limits[j])
++			debug_levels[j] = debug_limits[j];
++	}
++}
++
++void reset_output_levels(void)
++{
++	int j;
++
++	memset(info_levels, 0, sizeof info_levels);
++	memset(debug_levels, 0, sizeof debug_levels);
++
++	for (j = 0; j < COUNT_INFO; j++)
++		info_words[j].priority = DEFAULT_PRIORITY;
++
++	for (j = 0; j < COUNT_DEBUG; j++)
++		debug_words[j].priority = DEFAULT_PRIORITY;
++}
++
++void negate_output_levels(void)
++{
++	int j;
++
++	for (j = 0; j < COUNT_INFO; j++)
++		info_levels[j] *= -1;
++
++	for (j = 0; j < COUNT_DEBUG; j++)
++		debug_levels[j] *= -1;
++}
++
++enum {OPT_SERVER = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
++      OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
++      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
++      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
++      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG, OPT_BLOCK_SIZE,
++      OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT, OPT_STDERR, OPT_CLONE_DEST,
++      OPT_OLD_COMPRESS, OPT_NEW_COMPRESS, OPT_NO_COMPRESS, OPT_OLD_ARGS,
++      OPT_STOP_AFTER, OPT_STOP_AT,
++      OPT_REFUSED_BASE = 9000};
++
++static struct poptOption long_options[] = {
++  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
++  {"help",             0,  POPT_ARG_NONE,   0, OPT_HELP, 0, 0 },
++  {"version",         'V', POPT_ARG_NONE,   0, 'V', 0, 0},
++  {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
++  {"no-verbose",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
++  {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
++  {"info",             0,  POPT_ARG_STRING, 0, OPT_INFO, 0, 0 },
++  {"debug",            0,  POPT_ARG_STRING, 0, OPT_DEBUG, 0, 0 },
++  {"stderr",           0,  POPT_ARG_STRING, 0, OPT_STDERR, 0, 0 },
++  {"msgs2stderr",      0,  POPT_ARG_VAL,    &msgs2stderr, 1, 0, 0 },
++  {"no-msgs2stderr",   0,  POPT_ARG_VAL,    &msgs2stderr, 0, 0, 0 },
++  {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
++  {"motd",             0,  POPT_ARG_VAL,    &output_motd, 1, 0, 0 },
++  {"no-motd",          0,  POPT_ARG_VAL,    &output_motd, 0, 0, 0 },
++  {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
++  {"human-readable",  'h', POPT_ARG_NONE,   0, 'h', 0, 0},
++  {"no-human-readable",0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},
++  {"no-h",             0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},
++  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
++  {"archive",         'a', POPT_ARG_NONE,   0, 'a', 0, 0 },
++  {"recursive",       'r', POPT_ARG_VAL,    &recurse, 2, 0, 0 },
++  {"no-recursive",     0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
++  {"no-r",             0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
++  {"inc-recursive",    0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },
++  {"no-inc-recursive", 0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
++  {"i-r",              0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },
++  {"no-i-r",           0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
++  {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
++  {"no-dirs",          0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
++  {"no-d",             0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
++  {"old-dirs",         0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },
++  {"old-d",            0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },
++  {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
++  {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
++  {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
++  {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
++  {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
++  {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
++  {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
++  {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
++  {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
++  {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
++  {"times",           't', POPT_ARG_VAL,    &preserve_mtimes, 1, 0, 0 },
++  {"no-times",         0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },
++  {"no-t",             0,  POPT_ARG_VAL,    &preserve_mtimes, 0, 0, 0 },
++  {"atimes",          'U', POPT_ARG_NONE,   0, 'U', 0, 0 },
++  {"no-atimes",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
++  {"no-U",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
++  {"open-noatime",     0,  POPT_ARG_VAL,    &open_noatime, 1, 0, 0 },
++  {"no-open-noatime",  0,  POPT_ARG_VAL,    &open_noatime, 0, 0, 0 },
++  {"crtimes",         'N', POPT_ARG_VAL,    &preserve_crtimes, 1, 0, 0 },
++  {"no-crtimes",       0,  POPT_ARG_VAL,    &preserve_crtimes, 0, 0, 0 },
++  {"no-N",             0,  POPT_ARG_VAL,    &preserve_crtimes, 0, 0, 0 },
++  {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 1, 0, 0 },
++  {"no-omit-dir-times",0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
++  {"no-O",             0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
++  {"omit-link-times", 'J', POPT_ARG_VAL,    &omit_link_times, 1, 0, 0 },
++  {"no-omit-link-times",0, POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },
++  {"no-J",             0,  POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },
++  {"modify-window",   '@', POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
++  {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
++  {"no-super",         0,  POPT_ARG_VAL,    &am_root, 0, 0, 0 },
++  {"fake-super",       0,  POPT_ARG_VAL,    &am_root, -1, 0, 0 },
++  {"owner",           'o', POPT_ARG_VAL,    &preserve_uid, 1, 0, 0 },
++  {"no-owner",         0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
++  {"no-o",             0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
++  {"group",           'g', POPT_ARG_VAL,    &preserve_gid, 1, 0, 0 },
++  {"no-group",         0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
++  {"no-g",             0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
++  {0,                 'D', POPT_ARG_NONE,   0, 'D', 0, 0 },
++  {"no-D",             0,  POPT_ARG_NONE,   0, OPT_NO_D, 0, 0 },
++  {"devices",          0,  POPT_ARG_VAL,    &preserve_devices, 1, 0, 0 },
++  {"no-devices",       0,  POPT_ARG_VAL,    &preserve_devices, 0, 0, 0 },
++  {"copy-devices",     0,  POPT_ARG_NONE,   &copy_devices, 0, 0, 0 },
++  {"write-devices",    0,  POPT_ARG_VAL,    &write_devices, 1, 0, 0 },
++  {"no-write-devices", 0,  POPT_ARG_VAL,    &write_devices, 0, 0, 0 },
++  {"specials",         0,  POPT_ARG_VAL,    &preserve_specials, 1, 0, 0 },
++  {"no-specials",      0,  POPT_ARG_VAL,    &preserve_specials, 0, 0, 0 },
++  {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
++  {"no-links",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
++  {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
++  {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
++  {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
++  {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
++  {"munge-links",      0,  POPT_ARG_VAL,    &munge_symlinks, 1, 0, 0 },
++  {"no-munge-links",   0,  POPT_ARG_VAL,    &munge_symlinks, 0, 0, 0 },
++  {"copy-dirlinks",   'k', POPT_ARG_NONE,   &copy_dirlinks, 0, 0, 0 },
++  {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
++  {"hard-links",      'H', POPT_ARG_NONE,   0, 'H', 0, 0 },
++  {"no-hard-links",    0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
++  {"no-H",             0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
++  {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
++  {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
++  {"no-R",             0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
++  {"implied-dirs",     0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },
++  {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
++  {"i-d",              0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },
++  {"no-i-d",           0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
++  {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
++  {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
++  {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
++  {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
++  {"no-one-file-system",0, POPT_ARG_VAL,    &one_file_system, 0, 0, 0 },
++  {"no-x",             0,  POPT_ARG_VAL,    &one_file_system, 0, 0, 0 },
++  {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
++  {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
++  {"ignore-non-existing",0,POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
++  {"ignore-existing",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },
++  {"max-size",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },
++  {"min-size",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },
++  {"max-alloc",        0,  POPT_ARG_STRING, &max_alloc_arg, 0, 0, 0 },
++  {"sparse",          'S', POPT_ARG_VAL,    &sparse_files, 1, 0, 0 },
++  {"no-sparse",        0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
++  {"no-S",             0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
++  {"preallocate",      0,  POPT_ARG_NONE,   &preallocate_files, 0, 0, 0},
++  {"inplace",          0,  POPT_ARG_VAL,    &inplace, 1, 0, 0 },
++  {"no-inplace",       0,  POPT_ARG_VAL,    &inplace, 0, 0, 0 },
++  {"append",           0,  POPT_ARG_NONE,   0, OPT_APPEND, 0, 0 },
++  {"append-verify",    0,  POPT_ARG_VAL,    &append_mode, 2, 0, 0 },
++  {"no-append",        0,  POPT_ARG_VAL,    &append_mode, 0, 0, 0 },
++  {"del",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
++  {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
++  {"delete-before",    0,  POPT_ARG_NONE,   &delete_before, 0, 0, 0 },
++  {"delete-during",    0,  POPT_ARG_VAL,    &delete_during, 1, 0, 0 },
++  {"delete-delay",     0,  POPT_ARG_VAL,    &delete_during, 2, 0, 0 },
++  {"delete-after",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },
++  {"delete-excluded",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },
++  {"delete-missing-args",0,POPT_BIT_SET,    &missing_args, 2, 0, 0 },
++  {"ignore-missing-args",0,POPT_BIT_SET,    &missing_args, 1, 0, 0 },
++  {"remove-sent-files",0,  POPT_ARG_VAL,    &remove_source_files, 2, 0, 0 }, /* deprecated */
++  {"remove-source-files",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },
++  {"force",            0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },
++  {"no-force",         0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },
++  {"ignore-errors",    0,  POPT_ARG_VAL,    &ignore_errors, 1, 0, 0 },
++  {"no-ignore-errors", 0,  POPT_ARG_VAL,    &ignore_errors, 0, 0, 0 },
++  {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
++  {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },
++  {"filter",          'f', POPT_ARG_STRING, 0, OPT_FILTER, 0, 0 },
++  {"exclude",          0,  POPT_ARG_STRING, 0, OPT_EXCLUDE, 0, 0 },
++  {"include",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },
++  {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
++  {"include-from",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },
++  {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
++  {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
++  {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
++  {"no-W",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
++  {"checksum",        'c', POPT_ARG_VAL,    &always_checksum, 1, 0, 0 },
++  {"no-checksum",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
++  {"no-c",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
++  {"checksum-choice",  0,  POPT_ARG_STRING, &checksum_choice, 0, 0, 0 },
++  {"cc",               0,  POPT_ARG_STRING, &checksum_choice, 0, 0, 0 },
++  {"block-size",      'B', POPT_ARG_STRING, 0, OPT_BLOCK_SIZE, 0, 0 },
++  {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
++  {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
++  {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
++  {"detect-renamed",   0,  POPT_ARG_NONE,   &detect_renamed, 0, 0, 0 },
++  {"clone-dest",       0,  POPT_ARG_STRING, 0, OPT_CLONE_DEST, 0, 0 },
++  {"fuzzy",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },
++  {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
++  {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
++  {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
++  {"old-compress",     0,  POPT_ARG_NONE,   0, OPT_OLD_COMPRESS, 0, 0 },
++  {"new-compress",     0,  POPT_ARG_NONE,   0, OPT_NEW_COMPRESS, 0, 0 },
++  {"no-compress",      0,  POPT_ARG_NONE,   0, OPT_NO_COMPRESS, 0, 0 },
++  {"no-z",             0,  POPT_ARG_NONE,   0, OPT_NO_COMPRESS, 0, 0 },
++  {"compress-choice",  0,  POPT_ARG_STRING, &compress_choice, 0, 0, 0 },
++  {"zc",               0,  POPT_ARG_STRING, &compress_choice, 0, 0, 0 },
++  {"skip-compress",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },
++  {"compress-level",   0,  POPT_ARG_INT,    &do_compression_level, 0, 0, 0 },
++  {"zl",               0,  POPT_ARG_INT,    &do_compression_level, 0, 0, 0 },
++  {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
++  {"progress",         0,  POPT_ARG_VAL,    &do_progress, 1, 0, 0 },
++  {"no-progress",      0,  POPT_ARG_VAL,    &do_progress, 0, 0, 0 },
++  {"partial",          0,  POPT_ARG_VAL,    &keep_partial, 1, 0, 0 },
++  {"no-partial",       0,  POPT_ARG_VAL,    &keep_partial, 0, 0, 0 },
++  {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
++  {"delay-updates",    0,  POPT_ARG_VAL,    &delay_updates, 1, 0, 0 },
++  {"no-delay-updates", 0,  POPT_ARG_VAL,    &delay_updates, 0, 0, 0 },
++  {"prune-empty-dirs",'m', POPT_ARG_VAL,    &prune_empty_dirs, 1, 0, 0 },
++  {"no-prune-empty-dirs",0,POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },
++  {"no-m",             0,  POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },
++  {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
++  {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
++  {"out-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 },
++  {"log-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 }, /* DEPRECATED */
++  {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
++  {"no-itemize-changes",0, POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
++  {"no-i",             0,  POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
++  {"bwlimit",          0,  POPT_ARG_STRING, &bwlimit_arg, OPT_BWLIMIT, 0, 0 },
++  {"no-bwlimit",       0,  POPT_ARG_VAL,    &bwlimit, 0, 0, 0 },
++  {"backup",          'b', POPT_ARG_VAL,    &make_backups, 1, 0, 0 },
++  {"no-backup",        0,  POPT_ARG_VAL,    &make_backups, 0, 0, 0 },
++  {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
++  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
++  {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
++  {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
++  {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
++  {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
++  {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
++  {"from0",           '0', POPT_ARG_VAL,    &eol_nulls, 1, 0, 0},
++  {"no-from0",         0,  POPT_ARG_VAL,    &eol_nulls, 0, 0, 0},
++  {"old-args",         0,  POPT_ARG_NONE,   0, OPT_OLD_ARGS, 0, 0},
++  {"no-old-args",      0,  POPT_ARG_VAL,    &old_style_args, 0, 0, 0},
++  {"secluded-args",   's', POPT_ARG_VAL,    &protect_args, 1, 0, 0},
++  {"no-secluded-args", 0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
++  {"protect-args",     0,  POPT_ARG_VAL,    &protect_args, 1, 0, 0},
++  {"no-protect-args",  0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
++  {"no-s",             0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
++  {"trust-sender",     0,  POPT_ARG_VAL,    &trust_sender, 1, 0, 0},
++  {"numeric-ids",      0,  POPT_ARG_VAL,    &numeric_ids, 1, 0, 0 },
++  {"no-numeric-ids",   0,  POPT_ARG_VAL,    &numeric_ids, 0, 0, 0 },
++  {"usermap",          0,  POPT_ARG_STRING, 0, OPT_USERMAP, 0, 0 },
++  {"groupmap",         0,  POPT_ARG_STRING, 0, OPT_GROUPMAP, 0, 0 },
++  {"chown",            0,  POPT_ARG_STRING, 0, OPT_CHOWN, 0, 0 },
++  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
++  {"no-timeout",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },
++  {"contimeout",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },
++  {"no-contimeout",    0,  POPT_ARG_VAL,    &connect_timeout, 0, 0, 0 },
++  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
++  {"stop-after",       0,  POPT_ARG_STRING, 0, OPT_STOP_AFTER, 0, 0 },
++  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_STOP_AFTER, 0, 0 }, /* earlier stop-after name */
++  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
++  {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
++  {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
++  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
++  {"iconv",            0,  POPT_ARG_STRING, &iconv_opt, 0, 0, 0 },
++  {"no-iconv",         0,  POPT_ARG_NONE,   0, OPT_NO_ICONV, 0, 0 },
++  {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
++  {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
++  {"8-bit-output",    '8', POPT_ARG_VAL,    &allow_8bit_chars, 1, 0, 0 },
++  {"no-8-bit-output",  0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },
++  {"no-8",             0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },
++  {"mkpath",           0,  POPT_ARG_VAL,    &mkpath_dest_arg, 1, 0, 0 },
++  {"no-mkpath",        0,  POPT_ARG_VAL,    &mkpath_dest_arg, 0, 0, 0 },
++  {"qsort",            0,  POPT_ARG_NONE,   &use_qsort, 0, 0, 0 },
++  {"copy-as",          0,  POPT_ARG_STRING, &copy_as, 0, 0, 0 },
++  {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
++  {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
++  {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
++  {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
++  {"early-input",      0,  POPT_ARG_STRING, &early_input_file, 0, 0, 0 },
++  {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
++  {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
++  {"outbuf",           0,  POPT_ARG_STRING, &outbuf_mode, 0, 0, 0 },
++  {"remote-option",   'M', POPT_ARG_STRING, 0, 'M', 0, 0 },
++  {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
++  {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
++  {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
++  {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
++  /* All the following options switch us into daemon-mode option-parsing. */
++  {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
++  {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
++  {"dparam",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
++  {"detach",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
++  {"no-detach",        0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
++  {0,0,0,0, 0, 0, 0}
++};
++
++static struct poptOption long_daemon_options[] = {
++  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
++  {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
++  {"bwlimit",          0,  POPT_ARG_INT,    &daemon_bwlimit, 0, 0, 0 },
++  {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
++  {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
++  {"dparam",          'M', POPT_ARG_STRING, 0, 'M', 0, 0 },
++  {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
++  {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
++  {"detach",           0,  POPT_ARG_VAL,    &no_detach, 0, 0, 0 },
++  {"no-detach",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },
++  {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
++  {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
++  {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
++  {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
++  {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
++  {"server",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },
++  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
++  {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
++  {"no-verbose",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
++  {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
++  {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
++  {0,0,0,0, 0, 0, 0}
++};
++
++
++static char err_buf[200];
++
++
++/**
++ * Store the option error message, if any, so that we can log the
++ * connection attempt (which requires parsing the options), and then
++ * show the error later on.
++ **/
++void option_error(void)
++{
++	if (!err_buf[0]) {
++		strlcpy(err_buf, "Error parsing options: option may "
++			"be supported on client but not on server?\n",
++			sizeof err_buf);
++	}
++
++	rprintf(FERROR, RSYNC_NAME ": %s", err_buf);
++	io_flush(MSG_FLUSH);
++	msleep(20);
++}
++
++
++static void parse_one_refuse_match(int negated, const char *ref, const struct poptOption *list_end)
++{
++	struct poptOption *op;
++	char shortName[2];
++	int is_wild = strpbrk(ref, "*?[") != NULL;
++	int found_match = 0;
++
++	shortName[1] = '\0';
++
++	if (strcmp("a", ref) == 0 || strcmp("archive", ref) == 0) {
++		ref = "[ardlptgoD]";
++		is_wild = 1;
++	}
++
++	for (op = long_options; op != list_end; op++) {
++		*shortName = op->shortName;
++		if ((op->longName && wildmatch(ref, op->longName))
++		 || (*shortName && wildmatch(ref, shortName))) {
++			if (op->descrip[1] == '*')
++				op->descrip = negated ? "a*" : "r*";
++			else if (!is_wild)
++				op->descrip = negated ? "a=" : "r=";
++			found_match = 1;
++			if (!is_wild)
++				break;
++		}
++	}
++
++	if (!found_match)
++		rprintf(FLOG, "No match for refuse-options string \"%s\"\n", ref);
++}
++
++
++/**
++ * Tweak the option table to disable all options that the rsyncd.conf
++ * file has told us to refuse.
++ **/
++static void set_refuse_options(void)
++{
++	struct poptOption *op, *list_end = NULL;
++	char *cp, *ref = lp_refuse_options(module_id);
++	int negated;
++
++	if (!ref)
++		ref = "";
++
++	if (!am_daemon)
++		ref = "";
++
++	/* We abuse the descrip field in poptOption to make it easy to flag which options
++	 * are refused (since we don't use it otherwise).  Start by marking all options
++	 * as "a"ccepted with a few options also marked as non-wild. */
++	for (op = long_options; ; op++) {
++		const char *longName = op->longName ? op->longName : "";
++		if (!op->longName && !op->shortName) {
++			list_end = op;
++			break;
++		}
++		if (!am_daemon
++		 || op->shortName == 'e' /* Required for compatibility flags */
++		 || op->shortName == '0' /* --from0 just modifies --files-from, so refuse that instead (or not) */
++		 || op->shortName == 's' /* --secluded-args is always OK */
++		 || op->shortName == 'n' /* --dry-run is always OK */
++		 || strcmp("iconv", longName) == 0
++		 || strcmp("no-iconv", longName) == 0
++		 || strcmp("checksum-seed", longName) == 0
++		 || strcmp("copy-devices", longName) == 0 /* disable wild-match (it gets refused below) */
++		 || strcmp("write-devices", longName) == 0 /* disable wild-match (it gets refused below) */
++		 || strcmp("log-format", longName) == 0 /* aka out-format (NOT log-file-format) */
++		 || strcmp("sender", longName) == 0
++		 || strcmp("server", longName) == 0)
++			op->descrip = "a="; /* exact-match only */
++		else
++			op->descrip = "a*"; /* wild-card-able */
++	}
++	assert(list_end != NULL);
++
++	if (am_daemon) { /* Refused by default, but can be accepted via a negated exact match. */
++		parse_one_refuse_match(0, "copy-devices", list_end);
++		parse_one_refuse_match(0, "write-devices", list_end);
++	}
++
++	while (1) {
++		while (*ref == ' ') ref++;
++		if (!*ref)
++			break;
++		if ((cp = strchr(ref, ' ')) != NULL)
++			*cp = '\0';
++		negated = *ref == '!';
++		if (negated && ref[1])
++			ref++;
++		parse_one_refuse_match(negated, ref, list_end);
++		if (!cp)
++			break;
++		*cp = ' ';
++		ref = cp + 1;
++	}
++
++	if (am_daemon) {
++#ifdef ICONV_OPTION
++		if (!*lp_charset(module_id))
++			parse_one_refuse_match(0, "iconv", list_end);
++#endif
++		parse_one_refuse_match(0, "log-file*", list_end);
++	}
++
++#ifndef SUPPORT_ATIMES
++	parse_one_refuse_match(0, "atimes", list_end);
++#endif
++#ifndef SUPPORT_HARD_LINKS
++	parse_one_refuse_match(0, "link-dest", list_end);
++#endif
++#ifndef FICLONE
++	parse_one_refuse_match(0, "clone-dest", list_end);
++#endif
++#ifndef HAVE_MKTIME
++	parse_one_refuse_match(0, "stop-at", list_end);
++#endif
++#ifndef ICONV_OPTION
++	parse_one_refuse_match(0, "iconv", list_end);
++#endif
++#ifndef HAVE_SETVBUF
++	parse_one_refuse_match(0, "outbuf", list_end);
++#endif
++#ifndef SUPPORT_CRTIMES
++	parse_one_refuse_match(0, "crtimes", list_end);
++#endif
++
++	/* Now we use the descrip values to actually mark the options for refusal. */
++	for (op = long_options; op != list_end; op++) {
++		int refused = op->descrip[0] == 'r';
++		op->descrip = NULL;
++		if (!refused)
++			continue;
++		if (op->argInfo == POPT_ARG_VAL)
++			op->argInfo = POPT_ARG_NONE;
++		op->val = (op - long_options) + OPT_REFUSED_BASE;
++		/* The following flags are set to let us easily check an implied option later in the code. */
++		switch (op->shortName) {
++		case 'r': case 'd': case 'l': case 'p':
++		case 't': case 'g': case 'o': case 'D':
++			refused_archive_part = op->val;
++			break;
++		case 'z':
++			refused_compress = op->val;
++			break;
++		case '\0':
++			if (strcmp("delete", op->longName) == 0)
++				refused_delete = op->val;
++			else if (strcmp("delete-before", op->longName) == 0)
++				refused_delete_before = op->val;
++			else if (strcmp("delete-during", op->longName) == 0)
++				refused_delete_during = op->val;
++			else if (strcmp("partial", op->longName) == 0)
++				refused_partial = op->val;
++			else if (strcmp("progress", op->longName) == 0)
++				refused_progress = op->val;
++			else if (strcmp("inplace", op->longName) == 0)
++				refused_inplace = op->val;
++			else if (strcmp("no-iconv", op->longName) == 0)
++				refused_no_iconv = op->val;
++			break;
++		}
++	}
++}
++
++
++static int count_args(const char **argv)
++{
++	int i = 0;
++
++	if (argv) {
++		while (argv[i] != NULL)
++			i++;
++	}
++
++	return i;
++}
++
++/* If the size_arg is an invalid string or the value is < min_value, an error
++ * is put into err_buf & the return is -1.  Note that this parser does NOT
++ * support negative numbers, so a min_value < 0 doesn't make any sense. */
++static ssize_t parse_size_arg(const char *size_arg, char def_suf, const char *opt_name,
++			      ssize_t min_value, ssize_t max_value, BOOL unlimited_0)
++{
++	int reps, mult, len;
++	const char *arg, *err = "invalid", *min_max = NULL;
++	ssize_t limit = -1, size = 1;
++
++	for (arg = size_arg; isDigit(arg); arg++) {}
++	if (*arg == '.' || *arg == get_decimal_point()) /* backward compatibility: always allow '.' */
++		for (arg++; isDigit(arg); arg++) {}
++	switch (*arg && *arg != '+' && *arg != '-' ? *arg++ : def_suf) {
++	case 'b': case 'B':
++		reps = 0;
++		break;
++	case 'k': case 'K':
++		reps = 1;
++		break;
++	case 'm': case 'M':
++		reps = 2;
++		break;
++	case 'g': case 'G':
++		reps = 3;
++		break;
++	case 't': case 'T':
++		reps = 4;
++		break;
++	case 'p': case 'P':
++		reps = 5;
++		break;
++	default:
++		goto failure;
++	}
++	if (*arg == 'b' || *arg == 'B')
++		mult = 1000, arg++;
++	else if (!*arg || *arg == '+' || *arg == '-')
++		mult = 1024;
++	else if (strncasecmp(arg, "ib", 2) == 0)
++		mult = 1024, arg += 2;
++	else
++		goto failure;
++	while (reps--)
++		size *= mult;
++	size *= atof(size_arg);
++	if ((*arg == '+' || *arg == '-') && arg[1] == '1' && arg != size_arg)
++		size += atoi(arg), arg += 2;
++	if (*arg)
++		goto failure;
++	if (size < 0 || (max_value >= 0 && size > max_value)) {
++		err = "too large";
++		min_max = "max";
++		limit = max_value;
++		goto failure;
++	}
++	if (size < min_value && (!unlimited_0 || size != 0)) {
++		err = "too small";
++		min_max = "min";
++		limit = min_value;
++		goto failure;
++	}
++	return size;
++
++failure:
++	len = snprintf(err_buf, sizeof err_buf - 1, "--%s=%s is %s", opt_name, size_arg, err);
++	if (min_max && limit >= 0 && len < (int)sizeof err_buf - 10) {
++		len += snprintf(err_buf + len, sizeof err_buf - len - 1, " (%s: %s%s)",
++			min_max, do_big_num(limit, 3, NULL),
++			unlimited_0 && min_max[1] == 'i' ? " or 0 for unlimited" : "");
++	}
++	err_buf[len] = '\n';
++	err_buf[len+1] = '\0';
++	return -1;
++}
++
++#ifdef HAVE_MKTIME
++/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while
++ * also allowing abbreviated data.  For instance, if the time is omitted,
++ * it defaults to midnight.  If the date is omitted, it defaults to the
++ * next possible date in the future with the specified time.  Even the
++ * year or year-month can be omitted, again defaulting to the next date
++ * in the future that matches the specified information.  A 2-digit year
++ * is also OK, as is using '/' instead of '-'. */
++static time_t parse_time(const char *arg)
++{
++	const char *cp;
++	time_t val, now = time(NULL);
++	struct tm t, *today = localtime(&now);
++	int in_date, old_mday, n;
++
++	memset(&t, 0, sizeof t);
++	t.tm_year = t.tm_mon = t.tm_mday = -1;
++	t.tm_hour = t.tm_min = t.tm_isdst = -1;
++	cp = arg;
++	if (*cp == 'T' || *cp == 't' || *cp == ':') {
++		in_date = *cp == ':' ? 0 : -1;
++		cp++;
++	} else
++		in_date = 1;
++	for ( ; ; cp++) {
++		if (!isDigit(cp))
++			return (time_t)-1;
++		n = 0;
++		do {
++			n = n * 10 + *cp++ - '0';
++		} while (isDigit(cp));
++		if (*cp == ':')
++			in_date = 0;
++		if (in_date > 0) {
++			if (t.tm_year != -1)
++				return (time_t)-1;
++			t.tm_year = t.tm_mon;
++			t.tm_mon = t.tm_mday;
++			t.tm_mday = n;
++			if (!*cp)
++				break;
++			if (*cp == 'T' || *cp == 't') {
++				if (!cp[1])
++					break;
++				in_date = -1;
++			} else if (*cp != '-' && *cp != '/')
++				return (time_t)-1;
++			continue;
++		}
++		if (t.tm_hour != -1)
++			return (time_t)-1;
++		t.tm_hour = t.tm_min;
++		t.tm_min = n;
++		if (!*cp) {
++			if (in_date < 0)
++				return (time_t)-1;
++			break;
++		}
++		if (*cp != ':')
++			return (time_t)-1;
++		in_date = 0;
++	}
++
++	in_date = 0;
++	if (t.tm_year < 0) {
++		t.tm_year = today->tm_year;
++		in_date = 1;
++	} else if (t.tm_year < 100) {
++		while (t.tm_year < today->tm_year)
++			t.tm_year += 100;
++	} else
++		t.tm_year -= 1900;
++	if (t.tm_mon < 0) {
++		t.tm_mon = today->tm_mon;
++		in_date = 2;
++	} else
++		t.tm_mon--;
++	if (t.tm_mday < 0) {
++		t.tm_mday = today->tm_mday;
++		in_date = 3;
++	}
++
++	n = 0;
++	if (t.tm_min < 0) {
++		t.tm_hour = t.tm_min = 0;
++	} else if (t.tm_hour < 0) {
++		if (in_date != 3)
++			return (time_t)-1;
++		in_date = 0;
++		t.tm_hour = today->tm_hour;
++		n = 60*60;
++	}
++
++	/* Note that mktime() might change a too-large tm_mday into the start of
++	 * the following month which we need to undo in the following code! */
++	old_mday = t.tm_mday;
++	if (t.tm_hour > 23 || t.tm_min > 59
++	    || t.tm_mon < 0 || t.tm_mon >= 12
++	    || t.tm_mday < 1 || t.tm_mday > 31
++	    || (val = mktime(&t)) == (time_t)-1)
++		return (time_t)-1;
++
++	while (in_date && (val <= now || t.tm_mday < old_mday)) {
++		switch (in_date) {
++		case 3:
++			old_mday = ++t.tm_mday;
++			break;
++		case 2:
++			if (t.tm_mday < old_mday)
++				t.tm_mday = old_mday; /* The month already got bumped forward */
++			else if (++t.tm_mon == 12) {
++				t.tm_mon = 0;
++				t.tm_year++;
++			}
++			break;
++		case 1:
++			if (t.tm_mday < old_mday) {
++				/* mon==1 mday==29 got bumped to mon==2 */
++				if (t.tm_mon != 2 || old_mday != 29)
++					return (time_t)-1;
++				t.tm_mon = 1;
++				t.tm_mday = 29;
++			}
++			t.tm_year++;
++			break;
++		}
++		if ((val = mktime(&t)) == (time_t)-1) {
++			/* This code shouldn't be needed, as mktime() should auto-round to the next month. */
++			if (in_date != 3 || t.tm_mday <= 28)
++				return (time_t)-1;
++			t.tm_mday = old_mday = 1;
++			in_date = 2;
++		}
++	}
++	if (n) {
++		while (val <= now)
++			val += n;
++	}
++	return val;
++}
++#endif
++
++static void create_refuse_error(int which)
++{
++	const char *msg;
++	if (am_daemon)
++		msg = "The server is configured to refuse";
++	else if (am_server)
++		msg = "The server does not support";
++	else
++		msg = "This rsync does not support";
++
++	/* The "which" value is the index + OPT_REFUSED_BASE. */
++	struct poptOption *op = &long_options[which - OPT_REFUSED_BASE];
++	int n = snprintf(err_buf, sizeof err_buf, "%s --%s\n", msg, op->longName) - 1;
++	if (op->shortName)
++		snprintf(err_buf + n, sizeof err_buf - n, " (-%c)\n", op->shortName);
++}
++
++/* This is used to make sure that --daemon & --server cannot be aliased to
++ * something else. These options have always disabled popt aliases for the
++ * parsing of a daemon or server command-line, but we have to make sure that
++ * these options cannot vanish so that the alias disabling can take effect. */
++static void popt_unalias(poptContext con, const char *opt)
++{
++	struct poptAlias unalias;
++
++	memset(&unalias, 0, sizeof unalias);
++
++	unalias.longName = opt + 2; /* point past the leading "--" */
++	unalias.argc = 1;
++	unalias.argv = new_array0(const char*, 2);
++	unalias.argv[0] = strdup(opt);
++
++	poptAddAlias(con, unalias, 0);
++}
++
++char *alt_dest_opt(int type)
++{
++	if (!type)
++		type = alt_dest_type;
++
++	switch (type) {
++	case COMPARE_DEST:
++		return "--compare-dest";
++	case COPY_DEST:
++		return "--copy-dest";
++	case LINK_DEST:
++		return "--link-dest";
++	case CLONE_DEST:
++		return "--clone-dest";
++	default:
++		NOISY_DEATH("Unknown alt_dest_opt type");
++	}
++}
++
++/**
++ * Process command line arguments.  Called on both local and remote.
++ *
++ * @retval 1 if all options are OK; with globals set to appropriate
++ * values
++ *
++ * @retval 0 on error, with err_buf containing an explanation
++ **/
++int parse_arguments(int *argc_p, const char ***argv_p)
++{
++	poptContext pc;
++	const char *arg, **argv = *argv_p;
++	int argc = *argc_p;
++	int opt, want_dest_type;
++	int orig_protect_args = protect_args;
++
++	if (argc == 0) {
++		strlcpy(err_buf, "argc is zero!\n", sizeof err_buf);
++		return 0;
++	}
++
++	set_refuse_options();
++
++#ifdef ICONV_OPTION
++	if (!am_daemon && protect_args <= 0 && (arg = getenv("RSYNC_ICONV")) != NULL && *arg)
++		iconv_opt = strdup(arg);
++#endif
++
++	/* TODO: Call poptReadDefaultConfig; handle errors. */
++
++	pc = poptGetContext(RSYNC_NAME, argc, argv, long_options, 0);
++	if (!am_server) {
++		poptReadDefaultConfig(pc, 0);
++		popt_unalias(pc, "--daemon");
++		popt_unalias(pc, "--server");
++	}
++
++	while ((opt = poptGetNextOpt(pc)) != -1) {
++		/* most options are handled automatically by popt;
++		 * only special cases are returned and listed here. */
++
++		switch (opt) {
++		case 'V':
++			version_opt_cnt++;
++			break;
++
++		case OPT_SERVER:
++			if (!am_server) {
++				/* Disable popt aliases on the server side and
++				 * then start parsing the options again. */
++				poptFreeContext(pc);
++				pc = poptGetContext(RSYNC_NAME, argc, argv, long_options, 0);
++				am_server = 1;
++			}
++#ifdef ICONV_OPTION
++			iconv_opt = NULL;
++#endif
++			break;
++
++		case OPT_SENDER:
++			if (!am_server) {
++				usage(FERROR);
++				exit_cleanup(RERR_SYNTAX);
++			}
++			am_sender = 1;
++			break;
++
++		case OPT_DAEMON:
++			if (am_daemon) {
++				strlcpy(err_buf,
++					"Attempt to hack rsync thwarted!\n",
++					sizeof err_buf);
++				goto cleanup;
++			}
++#ifdef ICONV_OPTION
++			iconv_opt = NULL;
++#endif
++			protect_args = 0;
++			poptFreeContext(pc);
++			pc = poptGetContext(RSYNC_NAME, argc, argv, long_daemon_options, 0);
++			while ((opt = poptGetNextOpt(pc)) != -1) {
++				char **cpp;
++				switch (opt) {
++				case 'h':
++					daemon_usage(FINFO);
++					exit_cleanup(0);
++
++				case 'M':
++					arg = poptGetOptArg(pc);
++					if (!strchr(arg, '=')) {
++						rprintf(FERROR,
++							"--dparam value is missing an '=': %s\n",
++							arg);
++						goto daemon_error;
++					}
++					cpp = EXPAND_ITEM_LIST(&dparam_list, char *, 4);
++					*cpp = strdup(arg);
++					break;
++
++				case 'v':
++					verbose++;
++					break;
++
++				default:
++					rprintf(FERROR,
++						"rsync: %s: %s (in daemon mode)\n",
++						poptBadOption(pc, POPT_BADOPTION_NOALIAS),
++						poptStrerror(opt));
++					goto daemon_error;
++				}
++			}
++
++			if (dparam_list.count && !set_dparams(1))
++				exit_cleanup(RERR_SYNTAX);
++
++			if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
++				snprintf(err_buf, sizeof err_buf,
++					 "the --temp-dir path is WAY too long.\n");
++				goto cleanup;
++			}
++
++			if (!daemon_opt) {
++				rprintf(FERROR, "Daemon option(s) used without --daemon.\n");
++			    daemon_error:
++				rprintf(FERROR, "(Type \"rsync --daemon --help\" for assistance with daemon mode.)\n");
++				exit_cleanup(RERR_SYNTAX);
++			}
++
++			argv = poptGetArgs(pc);
++			argc = count_args(argv);
++			if (!argc) {
++				*argv_p = empty_argv;
++				*argc_p = 0;
++			} else if (poptDupArgv(argc, argv, argc_p, argv_p) != 0)
++				out_of_memory("parse_arguments");
++			argv = *argv_p;
++			poptFreeContext(pc);
++
++			am_starting_up = 0;
++			daemon_opt = 0;
++			am_daemon = 1;
++			return 1;
++
++		case OPT_MODIFY_WINDOW:
++			/* The value has already been set by popt, but
++			 * we need to remember that we're using a
++			 * non-default setting. */
++			modify_window_set = 1;
++			break;
++
++		case OPT_FILTER:
++			parse_filter_str(&filter_list, poptGetOptArg(pc),
++					rule_template(0), 0);
++			break;
++
++		case OPT_EXCLUDE:
++			parse_filter_str(&filter_list, poptGetOptArg(pc),
++					rule_template(0), XFLG_OLD_PREFIXES);
++			break;
++
++		case OPT_INCLUDE:
++			parse_filter_str(&filter_list, poptGetOptArg(pc),
++					rule_template(FILTRULE_INCLUDE), XFLG_OLD_PREFIXES);
++			break;
++
++		case OPT_EXCLUDE_FROM:
++		case OPT_INCLUDE_FROM:
++			arg = poptGetOptArg(pc);
++			if (sanitize_paths)
++				arg = sanitize_path(NULL, arg, NULL, 0, SP_DEFAULT);
++			if (daemon_filter_list.head) {
++				int rej;
++				char *cp = strdup(arg);
++				if (!*cp)
++					rej = 1;
++				else {
++					char *dir = cp + (*cp == '/' ? module_dirlen : 0);
++					clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
++					rej = check_filter(&daemon_filter_list, FLOG, dir, 0) < 0;
++				}
++				free(cp);
++				if (rej)
++					goto options_rejected;
++			}
++			parse_filter_file(&filter_list, arg,
++				rule_template(opt == OPT_INCLUDE_FROM ? FILTRULE_INCLUDE : 0),
++				XFLG_FATAL_ERRORS | XFLG_OLD_PREFIXES);
++			break;
++
++		case 'a':
++			if (refused_archive_part) {
++				create_refuse_error(refused_archive_part);
++				goto cleanup;
++			}
++			if (!recurse) /* preserve recurse == 2 */
++				recurse = 1;
++#ifdef SUPPORT_LINKS
++			preserve_links = 1;
++#endif
++			preserve_perms = 1;
++			preserve_mtimes = 1;
++			preserve_gid = 1;
++			preserve_uid = 1;
++			preserve_devices = 1;
++			preserve_specials = 1;
++			break;
++
++		case 'D':
++			preserve_devices = preserve_specials = 1;
++			break;
++
++		case OPT_NO_D:
++			preserve_devices = preserve_specials = 0;
++			break;
++
++		case 'h':
++			human_readable++;
++			break;
++
++		case 'H':
++			preserve_hard_links++;
++			break;
++
++		case 'i':
++			itemize_changes++;
++			break;
++
++		case 'U':
++			if (++preserve_atimes > 1)
++				open_noatime = 1;
++			break;
++
++		case 'v':
++			verbose++;
++			break;
++
++		case 'y':
++			fuzzy_basis++;
++			break;
++
++		case 'q':
++			quiet++;
++			break;
++
++		case 'x':
++			one_file_system++;
++			break;
++
++		case 'F':
++			switch (++F_option_cnt) {
++			case 1:
++				parse_filter_str(&filter_list,": /.rsync-filter",rule_template(0),0);
++				break;
++			case 2:
++				parse_filter_str(&filter_list,"- .rsync-filter",rule_template(0),0);
++				break;
++			}
++			break;
++
++		case 'P':
++			if (refused_partial || refused_progress) {
++				create_refuse_error(refused_partial ? refused_partial : refused_progress);
++				goto cleanup;
++			}
++			do_progress = 1;
++			keep_partial = 1;
++			break;
++
++		case 'z':
++			do_compression++;
++			break;
++
++		case OPT_OLD_COMPRESS:
++			compress_choice = "zlib";
++			break;
++
++		case OPT_NEW_COMPRESS:
++			compress_choice = "zlibx";
++			break;
++
++		case OPT_NO_COMPRESS:
++			do_compression = 0;
++			compress_choice = NULL;
++			break;
++
++		case OPT_OLD_ARGS:
++			if (old_style_args <= 0)
++				old_style_args = 1;
++			else
++				old_style_args++;
++			break;
++
++		case 'M':
++			arg = poptGetOptArg(pc);
++			if (*arg != '-') {
++				snprintf(err_buf, sizeof err_buf,
++					"Remote option must start with a dash: %s\n", arg);
++				goto cleanup;
++			}
++			if (remote_option_cnt+2 >= remote_option_alloc) {
++				remote_option_alloc += 16;
++				remote_options = realloc_array(remote_options,
++							const char *, remote_option_alloc);
++				if (!remote_option_cnt)
++					remote_options[0] = "ARG0";
++			}
++			remote_options[++remote_option_cnt] = arg;
++			remote_options[remote_option_cnt+1] = NULL;
++			break;
++
++		case OPT_WRITE_BATCH:
++			/* batch_name is already set */
++			write_batch = 1;
++			break;
++
++		case OPT_ONLY_WRITE_BATCH:
++			/* batch_name is already set */
++			write_batch = -1;
++			break;
++
++		case OPT_READ_BATCH:
++			/* batch_name is already set */
++			read_batch = 1;
++			break;
++
++		case OPT_NO_ICONV:
++#ifdef ICONV_OPTION
++			iconv_opt = NULL;
++#endif
++			break;
++
++		case OPT_BLOCK_SIZE: {
++			/* We may not know the real protocol_version at this point if this is the client
++			 * option parsing, but we still want to check it so that the client can specify
++			 * a --protocol=29 option with a larger block size. */
++			int max_blength = protocol_version < 30 ? OLD_MAX_BLOCK_SIZE : MAX_BLOCK_SIZE;
++			ssize_t size;
++			arg = poptGetOptArg(pc);
++			if ((size = parse_size_arg(arg, 'b', "block-size", 0, max_blength, False)) < 0)
++				goto cleanup;
++			block_size = (int32)size;
++			break;
++		}
++
++		case OPT_MAX_SIZE:
++			if ((max_size = parse_size_arg(max_size_arg, 'b', "max-size", 0, -1, False)) < 0)
++				goto cleanup;
++			max_size_arg = strdup(do_big_num(max_size, 0, NULL));
++			break;
++
++		case OPT_MIN_SIZE:
++			if ((min_size = parse_size_arg(min_size_arg, 'b', "min-size", 0, -1, False)) < 0)
++				goto cleanup;
++			min_size_arg = strdup(do_big_num(min_size, 0, NULL));
++			break;
++
++		case OPT_BWLIMIT: {
++			ssize_t size = parse_size_arg(bwlimit_arg, 'K', "bwlimit", 512, -1, True);
++			if (size < 0)
++				goto cleanup;
++			bwlimit_arg = strdup(do_big_num(size, 0, NULL));
++			bwlimit = (size + 512) / 1024;
++			break;
++		}
++
++		case OPT_APPEND:
++			if (am_server)
++				append_mode++;
++			else
++				append_mode = 1;
++			break;
++
++		case OPT_LINK_DEST:
++			want_dest_type = LINK_DEST;
++			goto set_dest_dir;
++
++		case OPT_CLONE_DEST:
++			want_dest_type = CLONE_DEST;
++			goto set_dest_dir;
++
++		case OPT_COPY_DEST:
++			want_dest_type = COPY_DEST;
++			goto set_dest_dir;
++
++		case OPT_COMPARE_DEST:
++			want_dest_type = COMPARE_DEST;
++
++		set_dest_dir:
++			if (alt_dest_type && alt_dest_type != want_dest_type) {
++				snprintf(err_buf, sizeof err_buf,
++					"ERROR: the %s option conflicts with the %s option\n",
++					alt_dest_opt(want_dest_type), alt_dest_opt(0));
++				goto cleanup;
++			}
++			alt_dest_type = want_dest_type;
++
++			if (basis_dir_cnt >= MAX_BASIS_DIRS) {
++				snprintf(err_buf, sizeof err_buf,
++					"ERROR: at most %d %s args may be specified\n",
++					MAX_BASIS_DIRS, alt_dest_opt(0));
++				goto cleanup;
++			}
++			/* We defer sanitizing this arg until we know what
++			 * our destination directory is going to be. */
++			basis_dir[basis_dir_cnt++] = (char *)poptGetOptArg(pc);
++			break;
++
++		case OPT_CHMOD:
++			arg = poptGetOptArg(pc);
++			if (!parse_chmod(arg, &chmod_modes)) {
++				snprintf(err_buf, sizeof err_buf,
++					"Invalid argument passed to --chmod (%s)\n",
++					arg);
++				goto cleanup;
++			}
++			break;
++
++		case OPT_INFO:
++			arg = poptGetOptArg(pc);
++			parse_output_words(info_words, info_levels, arg, USER_PRIORITY);
++			break;
++
++		case OPT_DEBUG:
++			arg = poptGetOptArg(pc);
++			parse_output_words(debug_words, debug_levels, arg, USER_PRIORITY);
++			break;
++
++		case OPT_USERMAP:
++			if (usermap) {
++				if (usermap_via_chown) {
++					snprintf(err_buf, sizeof err_buf,
++						"--usermap conflicts with prior --chown.\n");
++					goto cleanup;
++				}
++				snprintf(err_buf, sizeof err_buf,
++					"You can only specify --usermap once.\n");
++				goto cleanup;
++			}
++			usermap = (char *)poptGetOptArg(pc);
++			usermap_via_chown = False;
++			preserve_uid = 1;
++			break;
++
++		case OPT_GROUPMAP:
++			if (groupmap) {
++				if (groupmap_via_chown) {
++					snprintf(err_buf, sizeof err_buf,
++						"--groupmap conflicts with prior --chown.\n");
++					goto cleanup;
++				}
++				snprintf(err_buf, sizeof err_buf,
++					"You can only specify --groupmap once.\n");
++				goto cleanup;
++			}
++			groupmap = (char *)poptGetOptArg(pc);
++			groupmap_via_chown = False;
++			preserve_gid = 1;
++			break;
++
++		case OPT_CHOWN: {
++			const char *chown = poptGetOptArg(pc);
++			int len;
++			if ((arg = strchr(chown, ':')) != NULL)
++				len = arg++ - chown;
++			else
++				len = strlen(chown);
++			if (len) {
++				if (usermap) {
++					if (!usermap_via_chown) {
++						snprintf(err_buf, sizeof err_buf,
++							"--chown conflicts with prior --usermap.\n");
++						goto cleanup;
++					}
++					snprintf(err_buf, sizeof err_buf,
++						"You can only specify a user-affecting --chown once.\n");
++					goto cleanup;
++				}
++				if (asprintf(&usermap, "*:%.*s", len, chown) < 0)
++					out_of_memory("parse_arguments");
++				usermap_via_chown = True;
++				preserve_uid = 1;
++			}
++			if (arg && *arg) {
++				if (groupmap) {
++					if (!groupmap_via_chown) {
++						snprintf(err_buf, sizeof err_buf,
++							"--chown conflicts with prior --groupmap.\n");
++						goto cleanup;
++					}
++					snprintf(err_buf, sizeof err_buf,
++						"You can only specify a group-affecting --chown once.\n");
++					goto cleanup;
++				}
++				if (asprintf(&groupmap, "*:%s", arg) < 0)
++					out_of_memory("parse_arguments");
++				groupmap_via_chown = True;
++				preserve_gid = 1;
++			}
++			break;
++		}
++
++		case OPT_HELP:
++			usage(FINFO);
++			exit_cleanup(0);
++
++		case 'A':
++#ifdef SUPPORT_ACLS
++			preserve_acls = 1;
++			preserve_perms = 1;
++			break;
++#else
++			/* FIXME: this should probably be ignored with a
++			 * warning and then countermeasures taken to
++			 * restrict group and other access in the presence
++			 * of any more restrictive ACLs, but this is safe
++			 * for now */
++			snprintf(err_buf,sizeof(err_buf),
++				 "ACLs are not supported on this %s\n",
++				 am_server ? "server" : "client");
++			goto cleanup;
++#endif
++
++		case 'X':
++#ifdef SUPPORT_XATTRS
++			preserve_xattrs++;
++			break;
++#else
++			snprintf(err_buf,sizeof(err_buf),
++				 "extended attributes are not supported on this %s\n",
++				 am_server ? "server" : "client");
++			goto cleanup;
++#endif
++
++		case OPT_STOP_AFTER: {
++			long val;
++			arg = poptGetOptArg(pc);
++			stop_at_utime = time(NULL);
++			if ((val = atol(arg) * 60) <= 0 || LONG_MAX - val < stop_at_utime || (long)(time_t)val != val) {
++				snprintf(err_buf, sizeof err_buf, "invalid --stop-after value: %s\n", arg);
++				goto cleanup;
++			}
++			stop_at_utime += val;
++			break;
++		}
++
++#ifdef HAVE_MKTIME
++		case OPT_STOP_AT:
++			arg = poptGetOptArg(pc);
++			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
++				snprintf(err_buf, sizeof err_buf, "invalid --stop-at format: %s\n", arg);
++				goto cleanup;
++			}
++			if (stop_at_utime <= time(NULL)) {
++				snprintf(err_buf, sizeof err_buf, "--stop-at time is not in the future: %s\n", arg);
++				goto cleanup;
++			}
++			break;
++#endif
++
++		case OPT_STDERR: {
++			int len;
++			arg = poptGetOptArg(pc);
++			len = strlen(arg);
++			if (len && strncmp("errors", arg, len) == 0)
++				msgs2stderr = 2;
++			else if (len && strncmp("all", arg, len) == 0)
++				msgs2stderr = 1;
++			else if (len && strncmp("client", arg, len) == 0)
++				msgs2stderr = 0;
++			else {
++				snprintf(err_buf, sizeof err_buf,
++					"--stderr mode \"%s\" is not one of errors, all, or client\n", arg);
++				goto cleanup;
++			}
++			saw_stderr_opt = 1;
++			break;
++		}
++
++		default:
++			/* A large opt value means that set_refuse_options()
++			 * turned this option off. */
++			if (opt >= OPT_REFUSED_BASE) {
++				create_refuse_error(opt);
++				goto cleanup;
++			}
++			snprintf(err_buf, sizeof err_buf, "%s%s: %s\n",
++				 am_server ? "on remote machine: " : "",
++				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
++				 poptStrerror(opt));
++			goto cleanup;
++		}
++	}
++
++	if (msgs2stderr != 2)
++		saw_stderr_opt = 1;
++
++	if (version_opt_cnt) {
++		print_rsync_version(version_opt_cnt > 1 && !am_server ? FNONE : FINFO);
++		exit_cleanup(0);
++	}
++
++	if (!max_alloc_arg) {
++		max_alloc_arg = getenv("RSYNC_MAX_ALLOC");
++		if (max_alloc_arg && !*max_alloc_arg)
++			max_alloc_arg = NULL;
++	}
++	if (max_alloc_arg) {
++		ssize_t size = parse_size_arg(max_alloc_arg, 'B', "max-alloc", 1024*1024, -1, True);
++		if (size < 0)
++			goto cleanup;
++		max_alloc = size;
++	}
++	if (!max_alloc)
++		max_alloc = SIZE_MAX;
++
++	if (old_style_args < 0) {
++		if (!am_server && protect_args <= 0 && (arg = getenv("RSYNC_OLD_ARGS")) != NULL && *arg) {
++			protect_args = 0;
++			old_style_args = atoi(arg);
++		} else
++			old_style_args = 0;
++	} else if (old_style_args) {
++		if (protect_args > 0) {
++			snprintf(err_buf, sizeof err_buf,
++				 "--secluded-args conflicts with --old-args.\n");
++			goto cleanup;
++		}
++		protect_args = 0;
++	}
++
++	if (protect_args < 0) {
++		if (am_server)
++			protect_args = 0;
++		else if ((arg = getenv("RSYNC_PROTECT_ARGS")) != NULL && *arg)
++			protect_args = atoi(arg) ? 1 : 0;
++		else {
++#ifdef RSYNC_USE_SECLUDED_ARGS
++			protect_args = 1;
++#else
++			protect_args = 0;
++#endif
++		}
++	}
++
++	if (checksum_choice && strcasecmp(checksum_choice, "auto") != 0 && strcasecmp(checksum_choice, "auto,auto") != 0) {
++		/* Call this early to verify the args and figure out if we need to force
++		 * --whole-file. Note that the parse function will get called again later,
++		 * just in case an "auto" choice needs to know the protocol_version. */
++		parse_checksum_choice(0);
++	} else
++		checksum_choice = NULL;
++
++	if (human_readable > 1 && argc == 2 && !am_server) {
++		/* Allow the old meaning of 'h' (--help) on its own. */
++		usage(FINFO);
++		exit_cleanup(0);
++	}
++
++	if (!compress_choice && do_compression > 1)
++		compress_choice = "zlibx";
++	if (compress_choice && strcasecmp(compress_choice, "auto") != 0)
++		parse_compress_choice(0); /* Twiddles do_compression and can possibly NULL-out compress_choice. */
++	else
++		compress_choice = NULL;
++
++	if (do_compression || do_compression_level != CLVL_NOT_SPECIFIED) {
++		if (!do_compression)
++			do_compression = CPRES_AUTO;
++		if (do_compression && refused_compress) {
++			create_refuse_error(refused_compress);
++			goto cleanup;
++		}
++	}
++
++#ifdef HAVE_SETVBUF
++	if (outbuf_mode && !am_server) {
++		int mode = *(uchar *)outbuf_mode;
++		if (islower(mode))
++			mode = toupper(mode);
++		fflush(stdout); /* Just in case... */
++		switch (mode) {
++		case 'N': /* None */
++		case 'U': /* Unbuffered */
++			mode = _IONBF;
++			break;
++		case 'L': /* Line */
++			mode = _IOLBF;
++			break;
++		case 'B': /* Block */
++		case 'F': /* Full */
++			mode = _IOFBF;
++			break;
++		default:
++			snprintf(err_buf, sizeof err_buf,
++				"Invalid --outbuf setting -- specify N, L, or B.\n");
++			goto cleanup;
++		}
++		setvbuf(stdout, (char *)NULL, mode, 0);
++	}
++
++	if (msgs2stderr == 1) { /* Are all messages going to stderr? */
++		/* Make stderr line buffered for better sharing of the stream. */
++		fflush(stderr); /* Just in case... */
++		setvbuf(stderr, (char *)NULL, _IOLBF, 0);
++	}
++#endif
++
++	set_output_verbosity(verbose, DEFAULT_PRIORITY);
++
++	if (do_stats) {
++		parse_output_words(info_words, info_levels,
++			verbose > 1 ? "stats3" : "stats2", DEFAULT_PRIORITY);
++	}
++
++#ifdef ICONV_OPTION
++	if (iconv_opt && protect_args != 2) {
++		if (!am_server && strcmp(iconv_opt, "-") == 0)
++			iconv_opt = NULL;
++		else
++			need_unsorted_flist = 1;
++	}
++	if (refused_no_iconv && !iconv_opt) {
++		create_refuse_error(refused_no_iconv);
++		goto cleanup;
++	}
++#endif
++
++	if (fuzzy_basis > 1)
++		fuzzy_basis = basis_dir_cnt + 1;
++
++	/* Don't let the client reset protect_args if it was already processed */
++	if (orig_protect_args == 2 && am_server)
++		protect_args = orig_protect_args;
++
++	if (protect_args == 1 && am_server) {
++		poptFreeContext(pc);
++		return 1;
++	}
++
++	/* Because popt 1.19 has started to free the returned args data, we now
++	 * make a copy of the array and then do an immediate cleanup. */
++	argv = poptGetArgs(pc);
++	argc = count_args(argv);
++	if (!argc) {
++		*argv_p = empty_argv;
++		*argc_p = 0;
++	} else if (poptDupArgv(argc, argv, argc_p, argv_p) != 0)
++		out_of_memory("parse_arguments");
++	argv = *argv_p;
++	poptFreeContext(pc);
++	pc = NULL;
++
++#ifndef SUPPORT_LINKS
++	if (preserve_links && !am_sender) {
++		snprintf(err_buf, sizeof err_buf,
++			 "symlinks are not supported on this %s\n",
++			 am_server ? "server" : "client");
++		goto cleanup;
++	}
++#endif
++
++#ifndef SUPPORT_HARD_LINKS
++	if (preserve_hard_links) {
++		snprintf(err_buf, sizeof err_buf,
++			 "hard links are not supported on this %s\n",
++			 am_server ? "server" : "client");
++		goto cleanup;
++	}
++#endif
++
++#ifdef SUPPORT_XATTRS
++	if (am_root < 0 && preserve_xattrs > 1) {
++		snprintf(err_buf, sizeof err_buf,
++			 "--fake-super conflicts with -XX\n");
++		goto cleanup;
++	}
++#else
++	if (am_root < 0) {
++		snprintf(err_buf, sizeof err_buf,
++			 "--fake-super requires an rsync with extended attributes enabled\n");
++		goto cleanup;
++	}
++#endif
++
++	if (write_batch && read_batch) {
++		snprintf(err_buf, sizeof err_buf,
++			"--write-batch and --read-batch can not be used together\n");
++		goto cleanup;
++	}
++	if (write_batch > 0 || read_batch) {
++		if (am_server) {
++			rprintf(FINFO,
++				"ignoring --%s-batch option sent to server\n",
++				write_batch ? "write" : "read");
++			/* We don't actually exit_cleanup(), so that we can
++			 * still service older version clients that still send
++			 * batch args to server. */
++			read_batch = write_batch = 0;
++			batch_name = NULL;
++		} else if (dry_run)
++			write_batch = 0;
++	} else if (write_batch < 0 && dry_run)
++		write_batch = 0;
++	if (read_batch && files_from) {
++		snprintf(err_buf, sizeof err_buf,
++			"--read-batch cannot be used with --files-from\n");
++		goto cleanup;
++	}
++	if (read_batch && remove_source_files) {
++		snprintf(err_buf, sizeof err_buf,
++			"--read-batch cannot be used with --remove-%s-files\n",
++			remove_source_files == 1 ? "source" : "sent");
++		goto cleanup;
++	}
++	if (batch_name && strlen(batch_name) > MAX_BATCH_NAME_LEN) {
++		snprintf(err_buf, sizeof err_buf,
++			"the batch-file name must be %d characters or less.\n",
++			MAX_BATCH_NAME_LEN);
++		goto cleanup;
++	}
++
++	if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
++		snprintf(err_buf, sizeof err_buf,
++			 "the --temp-dir path is WAY too long.\n");
++		goto cleanup;
++	}
++
++	if (max_delete < 0 && max_delete != INT_MIN) {
++		/* Negative numbers are treated as "no deletions". */
++		max_delete = 0;
++	}
++
++	if (files_from) {
++		if (recurse == 1) /* preserve recurse == 2 */
++			recurse = 0;
++		if (xfer_dirs < 0)
++			xfer_dirs = 1;
++	}
++
++	if (argc < 2 && !read_batch && !am_server)
++		list_only |= 1;
++
++	if (xfer_dirs >= 4) {
++		parse_filter_str(&filter_list, "- /*/*", rule_template(0), 0);
++		recurse = xfer_dirs = 1;
++	} else if (recurse)
++		xfer_dirs = 1;
++	else if (xfer_dirs < 0)
++		xfer_dirs = list_only ? 1 : 0;
++
++	if (relative_paths < 0)
++		relative_paths = files_from? 1 : 0;
++	if (!relative_paths)
++		implied_dirs = 0;
++
++	if (delete_before + !!delete_during + delete_after > 1) {
++		snprintf(err_buf, sizeof err_buf,
++			"You may not combine multiple --delete-WHEN options.\n");
++		goto cleanup;
++	}
++	if (delete_before || delete_during || delete_after)
++		delete_mode = 1;
++	else if (delete_mode || delete_excluded) {
++		/* Only choose now between before & during if one is refused. */
++		if (refused_delete_before) {
++			if (!refused_delete_during)
++				delete_during = 1;
++			else {
++				create_refuse_error(refused_delete_before);
++				goto cleanup;
++			}
++		} else if (refused_delete_during)
++			delete_before = 1;
++		delete_mode = 1;
++	}
++	if (!xfer_dirs && delete_mode) {
++		snprintf(err_buf, sizeof err_buf,
++			"--delete does not work without --recursive (-r) or --dirs (-d).\n");
++		goto cleanup;
++	}
++
++	if (missing_args == 3) /* simplify if both options were specified */
++		missing_args = 2;
++	if (refused_delete && (delete_mode || missing_args == 2)) {
++		create_refuse_error(refused_delete);
++		goto cleanup;
++	}
++
++	if (remove_source_files) {
++		/* We only want to infer this refusal of --remove-source-files
++		 * via the refusal of "delete", not any of the "delete-FOO"
++		 * options. */
++		if (refused_delete && am_sender) {
++			create_refuse_error(refused_delete);
++			goto cleanup;
++		}
++		need_messages_from_generator = 1;
++	}
++
++	if (munge_symlinks && !am_daemon) {
++		STRUCT_STAT st;
++		char prefix[SYMLINK_PREFIX_LEN]; /* NOT +1 ! */
++		strlcpy(prefix, SYMLINK_PREFIX, sizeof prefix); /* trim the trailing slash */
++		if (do_stat(prefix, &st) == 0 && S_ISDIR(st.st_mode)) {
++			rprintf(FERROR, "Symlink munging is unsafe when a %s directory exists.\n",
++				prefix);
++			exit_cleanup(RERR_UNSUPPORTED);
++		}
++	}
++
++	if (sanitize_paths) {
++		int i;
++		for (i = argc; i-- > 0; )
++			argv[i] = sanitize_path(NULL, argv[i], "", 0, SP_KEEP_DOT_DIRS);
++		if (tmpdir)
++			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0, SP_DEFAULT);
++		if (backup_dir)
++			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0, SP_DEFAULT);
++	}
++	if (daemon_filter_list.head && !am_sender) {
++		filter_rule_list *elp = &daemon_filter_list;
++		if (tmpdir) {
++			char *dir;
++			if (!*tmpdir)
++				goto options_rejected;
++			dir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);
++			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
++			if (check_filter(elp, FLOG, dir, 1) < 0)
++				goto options_rejected;
++		}
++		if (backup_dir) {
++			char *dir;
++			if (!*backup_dir)
++				goto options_rejected;
++			dir = backup_dir + (*backup_dir == '/' ? module_dirlen : 0);
++			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
++			if (check_filter(elp, FLOG, dir, 1) < 0)
++				goto options_rejected;
++		}
++	}
++
++	if (!backup_suffix)
++		backup_suffix = backup_dir ? "" : BACKUP_SUFFIX;
++	backup_suffix_len = strlen(backup_suffix);
++	if (strchr(backup_suffix, '/') != NULL) {
++		snprintf(err_buf, sizeof err_buf,
++			"--suffix cannot contain slashes: %s\n",
++			backup_suffix);
++		goto cleanup;
++	}
++	if (backup_dir) {
++		size_t len;
++		make_backups = 1; /* --backup-dir implies --backup */
++		while (*backup_dir == '.' && backup_dir[1] == '/')
++			backup_dir += 2;
++		if (*backup_dir == '.' && backup_dir[1] == '\0')
++			backup_dir++;
++		len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
++		if (len > sizeof backup_dir_buf - 128) {
++			snprintf(err_buf, sizeof err_buf,
++				"the --backup-dir path is WAY too long.\n");
++			goto cleanup;
++		}
++		backup_dir_len = (int)len;
++		if (!backup_dir_len) {
++			backup_dir_len = -1;
++			backup_dir = NULL;
++		} else if (backup_dir_buf[backup_dir_len - 1] != '/') {
++			backup_dir_buf[backup_dir_len++] = '/';
++			backup_dir_buf[backup_dir_len] = '\0';
++		}
++		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
++	}
++	if (backup_dir) {
++		/* No need for a suffix or a protect rule. */
++	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
++		snprintf(err_buf, sizeof err_buf,
++			"--suffix cannot be empty %s\n", backup_dir_len < 0
++			? "when --backup-dir is the same as the dest dir"
++			: "without a --backup-dir");
++		goto cleanup;
++	} else if (make_backups && delete_mode && !delete_excluded && !am_server) {
++		snprintf(backup_dir_buf, sizeof backup_dir_buf,
++			"P *%s", backup_suffix);
++		parse_filter_str(&filter_list, backup_dir_buf, rule_template(0), 0);
++	}
++
++	if (make_backups && !backup_dir)
++		omit_dir_times = -1; /* Implied, so avoid -O to sender. */
++
++	if (stdout_format) {
++		if (am_server && log_format_has(stdout_format, 'I'))
++			stdout_format_has_i = 2;
++		else if (log_format_has(stdout_format, 'i'))
++			stdout_format_has_i = itemize_changes | 1;
++		if (!log_format_has(stdout_format, 'b')
++		 && !log_format_has(stdout_format, 'c')
++		 && !log_format_has(stdout_format, 'C'))
++			log_before_transfer = !am_server;
++	} else if (itemize_changes) {
++		stdout_format = "%i %n%L";
++		stdout_format_has_i = itemize_changes;
++		log_before_transfer = !am_server;
++	}
++
++	if (do_progress && !am_server) {
++		if (!log_before_transfer && INFO_EQ(NAME, 0))
++			parse_output_words(info_words, info_levels, "name", DEFAULT_PRIORITY);
++		parse_output_words(info_words, info_levels, "FLIST2,PROGRESS", DEFAULT_PRIORITY);
++	}
++
++	if (dry_run)
++		do_xfers = 0;
++
++	set_io_timeout(io_timeout);
++
++	if (INFO_GTE(NAME, 1) && !stdout_format) {
++		stdout_format = "%n%L";
++		log_before_transfer = !am_server;
++	}
++	if (stdout_format_has_i || log_format_has(stdout_format, 'o'))
++		stdout_format_has_o_or_i = 1;
++
++	if (logfile_name && !am_daemon) {
++		if (!logfile_format) {
++			logfile_format = "%i %n%L";
++			logfile_format_has_i = logfile_format_has_o_or_i = 1;
++		} else {
++			if (log_format_has(logfile_format, 'i'))
++				logfile_format_has_i = 1;
++			if (logfile_format_has_i || log_format_has(logfile_format, 'o'))
++				logfile_format_has_o_or_i = 1;
++		}
++		log_init(0);
++	} else if (!am_daemon)
++		logfile_format = NULL;
++
++	if (daemon_bwlimit && (!bwlimit || bwlimit > daemon_bwlimit))
++		bwlimit = daemon_bwlimit;
++	if (bwlimit) {
++		bwlimit_writemax = (size_t)bwlimit * 128;
++		if (bwlimit_writemax < 512)
++			bwlimit_writemax = 512;
++	}
++
++	if (append_mode) {
++		if (whole_file > 0) {
++			snprintf(err_buf, sizeof err_buf,
++				 "--append cannot be used with --whole-file\n");
++			goto cleanup;
++		}
++		if (refused_inplace) {
++			create_refuse_error(refused_inplace);
++			goto cleanup;
++		}
++		inplace = 1;
++	}
++
++	if (write_devices) {
++		if (refused_inplace) {
++			create_refuse_error(refused_inplace);
++			goto cleanup;
++		}
++		inplace = 1;
++	}
++
++	if ((delay_updates || detect_renamed) && !partial_dir)
++		partial_dir = tmp_partialdir;
++
++	if (inplace) {
++#ifdef HAVE_FTRUNCATE
++		if (partial_dir) {
++			snprintf(err_buf, sizeof err_buf,
++				 "--%s cannot be used with --%s\n",
++				 append_mode ? "append" : "inplace",
++				 detect_renamed ? "detect-renamed" :
++				 delay_updates ? "delay-updates" : "partial-dir");
++			goto cleanup;
++		}
++		/* --inplace implies --partial for refusal purposes, but we
++		 * clear the keep_partial flag for internal logic purposes. */
++		if (refused_partial) {
++			create_refuse_error(refused_partial);
++			goto cleanup;
++		}
++		keep_partial = 0;
++#else
++		snprintf(err_buf, sizeof err_buf,
++			 "--%s is not supported on this %s\n",
++			 append_mode ? "append" : "inplace",
++			 am_server ? "server" : "client");
++		goto cleanup;
++#endif
++	} else {
++		if (keep_partial && !partial_dir && !am_server) {
++			if ((arg = getenv("RSYNC_PARTIAL_DIR")) != NULL && *arg)
++				partial_dir = strdup(arg);
++		}
++		if (partial_dir) {
++			if (*partial_dir)
++				clean_fname(partial_dir, CFN_COLLAPSE_DOT_DOT_DIRS);
++			if (!*partial_dir || strcmp(partial_dir, ".") == 0)
++				partial_dir = NULL;
++			if (!partial_dir && refused_partial) {
++				create_refuse_error(refused_partial);
++				goto cleanup;
++			}
++			keep_partial = 1;
++		}
++	}
++
++	if (files_from) {
++		char *h, *p;
++		int q;
++		if (argc > 2 || (!am_daemon && !am_server && argc == 1)) {
++			usage(FERROR);
++			exit_cleanup(RERR_SYNTAX);
++		}
++		if (strcmp(files_from, "-") == 0) {
++			filesfrom_fd = 0;
++			if (am_server)
++				filesfrom_host = ""; /* reading from socket */
++		} else if ((p = check_for_hostspec(files_from, &h, &q)) != 0) {
++			if (am_server) {
++				snprintf(err_buf, sizeof err_buf,
++					"The --files-from sent to the server cannot specify a host.\n");
++				goto cleanup;
++			}
++			files_from = p;
++			filesfrom_host = h;
++			if (strcmp(files_from, "-") == 0) {
++				snprintf(err_buf, sizeof err_buf,
++					"Invalid --files-from remote filename\n");
++				goto cleanup;
++			}
++		} else {
++			if (sanitize_paths)
++				files_from = sanitize_path(NULL, files_from, NULL, 0, SP_DEFAULT);
++			if (daemon_filter_list.head) {
++				char *dir;
++				if (!*files_from)
++					goto options_rejected;
++				dir = files_from + (*files_from == '/' ? module_dirlen : 0);
++				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
++				if (check_filter(&daemon_filter_list, FLOG, dir, 0) < 0)
++					goto options_rejected;
++			}
++			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
++			if (filesfrom_fd < 0) {
++				snprintf(err_buf, sizeof err_buf,
++					"failed to open files-from file %s: %s\n",
++					files_from, strerror(errno));
++				goto cleanup;
++			}
++		}
++	}
++
++	if (trust_sender || am_server || read_batch)
++		trust_sender_args = trust_sender_filter = 1;
++	else if (old_style_args || filesfrom_host != NULL)
++		trust_sender_args = 1;
++
++	am_starting_up = 0;
++
++	return 1;
++
++  options_rejected:
++	snprintf(err_buf, sizeof err_buf,
++		"Your options have been rejected by the server.\n");
++  cleanup:
++	if (pc)
++		poptFreeContext(pc);
++	return 0;
++}
++
++
++static char SPLIT_ARG_WHEN_OLD[1];
++
++/**
++ * Do backslash quoting of any weird chars in "arg", append the resulting
++ * string to the end of the "opt" (which gets a "=" appended if it is not
++ * an empty or NULL string), and return the (perhaps malloced) result.
++ * If opt is NULL, arg is considered a filename arg that allows wildcards.
++ * If it is "" or any other value, it is considered an option.
++ **/
++char *safe_arg(const char *opt, const char *arg)
++{
++#define SHELL_CHARS "!#$&;|<>(){}\"'` \t\\"
++#define WILD_CHARS  "*?[]" /* We don't allow remote brace expansion */
++	BOOL is_filename_arg = !opt;
++	char *escapes = is_filename_arg ? SHELL_CHARS : WILD_CHARS SHELL_CHARS;
++	BOOL escape_leading_dash = is_filename_arg && *arg == '-';
++	BOOL escape_leading_tilde = 0;
++	int len1 = opt && *opt ? strlen(opt) + 1 : 0;
++	int len2 = strlen(arg);
++	int extras = escape_leading_dash ? 2 : 0;
++	char *ret;
++	if (!protect_args && old_style_args < 2 && (!old_style_args || (!is_filename_arg && opt != SPLIT_ARG_WHEN_OLD))) {
++		const char *f;
++		if (*arg == '~' && is_filename_arg && !am_sender && !trust_sender_args
++		 && ((relative_paths && !strstr(arg, "/./"))
++		  || !strchr(arg, '/'))) {
++			extras++;
++			escape_leading_tilde = 1;
++		}
++		for (f = arg; *f; f++) {
++			if (strchr(escapes, *f))
++				extras++;
++		}
++	}
++	if (!len1 && !extras)
++		return (char*)arg;
++	ret = new_array(char, len1 + len2 + extras + 1);
++	if (len1) {
++		memcpy(ret, opt, len1-1);
++		ret[len1-1] = '=';
++	}
++	if (escape_leading_dash) {
++		ret[len1++] = '.';
++		ret[len1++] = '/';
++		extras -= 2;
++	}
++	if (!extras)
++		memcpy(ret + len1, arg, len2);
++	else {
++		const char *f = arg;
++		char *t = ret + len1;
++		if (escape_leading_tilde)
++			*t++ = '\\';
++		while (*f) {
++                        if (*f == '\\') {
++				if (!is_filename_arg || !strchr(WILD_CHARS, f[1]))
++					*t++ = '\\';
++			} else if (strchr(escapes, *f))
++				*t++ = '\\';
++			*t++ = *f++;
++		}
++	}
++	ret[len1+len2+extras] = '\0';
++	return ret;
++}
++
++
++/**
++ * Construct a filtered list of options to pass through from the
++ * client to the server.
++ *
++ * This involves setting options that will tell the server how to
++ * behave, and also filtering out options that are processed only
++ * locally.
++ **/
++void server_options(char **args, int *argc_p)
++{
++	static char argstr[64];
++	int ac = *argc_p;
++	uchar where;
++	char *arg;
++	int i, x;
++
++	/* This should always remain first on the server's command-line. */
++	args[ac++] = "--server";
++
++	if (!am_sender)
++		args[ac++] = "--sender";
++
++	x = 1;
++	argstr[0] = '-';
++
++	if (protect_args)
++		argstr[x++] = 's';
++
++	for (i = 0; i < verbose; i++)
++		argstr[x++] = 'v';
++
++	if (quiet && msgs2stderr)
++		argstr[x++] = 'q';
++	if (make_backups)
++		argstr[x++] = 'b';
++	if (update_only)
++		argstr[x++] = 'u';
++	if (!do_xfers) /* Note: NOT "dry_run"! */
++		argstr[x++] = 'n';
++	if (preserve_links)
++		argstr[x++] = 'l';
++	if ((xfer_dirs >= 2 && xfer_dirs < 4)
++	 || (xfer_dirs && !recurse && (list_only || (delete_mode && am_sender))))
++		argstr[x++] = 'd';
++	if (am_sender) {
++		if (keep_dirlinks)
++			argstr[x++] = 'K';
++		if (prune_empty_dirs)
++			argstr[x++] = 'm';
++		if (omit_dir_times > 0)
++			argstr[x++] = 'O';
++		if (omit_link_times)
++			argstr[x++] = 'J';
++		if (fuzzy_basis) {
++			argstr[x++] = 'y';
++			if (fuzzy_basis > 1)
++				argstr[x++] = 'y';
++		}
++	} else {
++		if (copy_links)
++			argstr[x++] = 'L';
++		if (copy_dirlinks)
++			argstr[x++] = 'k';
++	}
++
++	if (whole_file > 0)
++		argstr[x++] = 'W';
++	/* We don't need to send --no-whole-file, because it's the
++	 * default for remote transfers, and in any case old versions
++	 * of rsync will not understand it. */
++
++	if (preserve_hard_links) {
++		argstr[x++] = 'H';
++		if (preserve_hard_links > 1)
++			argstr[x++] = 'H';
++	}
++	if (preserve_uid)
++		argstr[x++] = 'o';
++	if (preserve_gid)
++		argstr[x++] = 'g';
++	if (preserve_devices) /* ignore preserve_specials here */
++		argstr[x++] = 'D';
++	if (preserve_mtimes)
++		argstr[x++] = 't';
++	if (preserve_atimes) {
++		argstr[x++] = 'U';
++		if (preserve_atimes > 1)
++			argstr[x++] = 'U';
++	}
++#ifdef SUPPORT_CRTIMES
++	if (preserve_crtimes)
++		argstr[x++] = 'N';
++#endif
++	if (preserve_perms)
++		argstr[x++] = 'p';
++	else if (preserve_executability && am_sender)
++		argstr[x++] = 'E';
++#ifdef SUPPORT_ACLS
++	if (preserve_acls)
++		argstr[x++] = 'A';
++#endif
++#ifdef SUPPORT_XATTRS
++	if (preserve_xattrs) {
++		argstr[x++] = 'X';
++		if (preserve_xattrs > 1)
++			argstr[x++] = 'X';
++	}
++#endif
++	if (recurse)
++		argstr[x++] = 'r';
++	if (always_checksum)
++		argstr[x++] = 'c';
++	if (cvs_exclude)
++		argstr[x++] = 'C';
++	if (ignore_times)
++		argstr[x++] = 'I';
++	if (relative_paths)
++		argstr[x++] = 'R';
++	if (one_file_system) {
++		argstr[x++] = 'x';
++		if (one_file_system > 1)
++			argstr[x++] = 'x';
++	}
++	if (sparse_files)
++		argstr[x++] = 'S';
++	if (do_compression == CPRES_ZLIB)
++		argstr[x++] = 'z';
++
++	set_allow_inc_recurse();
++
++	/* This '\0'-terminates argstr and makes sure it didn't overflow. */
++	x += maybe_add_e_option(argstr + x, (int)sizeof argstr - x);
++
++	if (x > 1)
++		args[ac++] = argstr;
++
++#ifdef ICONV_OPTION
++	if (iconv_opt) {
++		char *set = strchr(iconv_opt, ',');
++		if (set)
++			set++;
++		else
++			set = iconv_opt;
++		args[ac++] = safe_arg("--iconv", set);
++	}
++#endif
++
++	if (protect_args && !local_server) /* unprotected args stop here */
++		args[ac++] = NULL;
++
++	if (list_only > 1)
++		args[ac++] = "--list-only";
++
++	/* This makes sure that the remote rsync can handle deleting with -d
++	 * sans -r because the --no-r option was added at the same time. */
++	if (xfer_dirs && !recurse && delete_mode && am_sender)
++		args[ac++] = "--no-r";
++
++	if (do_compression && do_compression_level != CLVL_NOT_SPECIFIED) {
++		if (asprintf(&arg, "--compress-level=%d", do_compression_level) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (preserve_devices) {
++		/* Note: sending "--devices" would not be backward-compatible. */
++		if (!preserve_specials)
++			args[ac++] = "--no-specials"; /* -D is already set. */
++	} else if (preserve_specials)
++		args[ac++] = "--specials";
++
++	/* The server side doesn't use our log-format, but in certain
++	 * circumstances they need to know a little about the option. */
++	if (stdout_format && am_sender) {
++		/* Use --log-format, not --out-format, for compatibility. */
++		if (stdout_format_has_i > 1)
++			args[ac++] = "--log-format=%i%I";
++		else if (stdout_format_has_i)
++			args[ac++] = "--log-format=%i";
++		else if (stdout_format_has_o_or_i)
++			args[ac++] = "--log-format=%o";
++		else if (!verbose)
++			args[ac++] = "--log-format=X";
++	}
++
++	if (msgs2stderr == 1)
++		args[ac++] = "--msgs2stderr";
++	else if (msgs2stderr == 0)
++		args[ac++] = "--no-msgs2stderr";
++
++	if (block_size) {
++		if (asprintf(&arg, "-B%u", (int)block_size) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (io_timeout) {
++		if (asprintf(&arg, "--timeout=%d", io_timeout) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (bwlimit) {
++		if (asprintf(&arg, "--bwlimit=%d", bwlimit) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (backup_dir) {
++		/* This split idiom allows for ~/path expansion via the shell. */
++		args[ac++] = "--backup-dir";
++		args[ac++] = safe_arg("", backup_dir);
++	}
++
++	/* Only send --suffix if it specifies a non-default value. */
++	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0)
++		args[ac++] = safe_arg("--suffix", backup_suffix);
++
++	if (checksum_choice)
++		args[ac++] = safe_arg("--checksum-choice", checksum_choice);
++
++	if (do_compression == CPRES_ZLIBX)
++		args[ac++] = "--new-compress";
++	else if (compress_choice && do_compression == CPRES_ZLIB)
++		args[ac++] = "--old-compress";
++	else if (compress_choice)
++		args[ac++] = safe_arg("--compress-choice", compress_choice);
++
++	if (am_sender) {
++		if (max_delete > 0) {
++			if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
++				goto oom;
++			args[ac++] = arg;
++		} else if (max_delete == 0)
++			args[ac++] = "--max-delete=-1";
++		if (min_size >= 0)
++			args[ac++] = safe_arg("--min-size", min_size_arg);
++		if (max_size >= 0)
++			args[ac++] = safe_arg("--max-size", max_size_arg);
++		if (delete_before)
++			args[ac++] = "--delete-before";
++		else if (delete_during == 2)
++			args[ac++] = "--delete-delay";
++		else if (delete_during)
++			args[ac++] = "--delete-during";
++		else if (delete_after)
++			args[ac++] = "--delete-after";
++		else if (delete_mode && !delete_excluded)
++			args[ac++] = "--delete";
++		if (delete_excluded)
++			args[ac++] = "--delete-excluded";
++		if (force_delete)
++			args[ac++] = "--force";
++		if (write_batch < 0)
++			args[ac++] = "--only-write-batch=X";
++		if (am_root > 1)
++			args[ac++] = "--super";
++		if (size_only)
++			args[ac++] = "--size-only";
++		if (detect_renamed)
++			args[ac++] = "--detect-renamed";
++		if (do_stats)
++			args[ac++] = "--stats";
++	} else {
++		if (skip_compress)
++			args[ac++] = safe_arg("--skip-compress", skip_compress);
++	}
++
++	if (max_alloc_arg && max_alloc != DEFAULT_MAX_ALLOC)
++		args[ac++] = safe_arg("--max-alloc", max_alloc_arg);
++
++	/* --delete-missing-args needs the cooperation of both sides, but
++	 * the sender can handle --ignore-missing-args by itself. */
++	if (missing_args == 2)
++		args[ac++] = "--delete-missing-args";
++	else if (missing_args == 1 && !am_sender)
++		args[ac++] = "--ignore-missing-args";
++
++	if (modify_window_set && am_sender) {
++		char *fmt = modify_window < 0 ? "-@%d" : "--modify-window=%d";
++		if (asprintf(&arg, fmt, modify_window) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (checksum_seed) {
++		if (asprintf(&arg, "--checksum-seed=%d", checksum_seed) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
++	if (partial_dir && am_sender) {
++		if (partial_dir != tmp_partialdir) {
++			args[ac++] = "--partial-dir";
++			args[ac++] = safe_arg("", partial_dir);
++		}
++		if (delay_updates)
++			args[ac++] = "--delay-updates";
++	} else if (keep_partial && am_sender)
++		args[ac++] = "--partial";
++
++	if (ignore_errors)
++		args[ac++] = "--ignore-errors";
++
++	if (copy_unsafe_links)
++		args[ac++] = "--copy-unsafe-links";
++
++	if (safe_symlinks)
++		args[ac++] = "--safe-links";
++
++	if (numeric_ids)
++		args[ac++] = "--numeric-ids";
++
++	if (use_qsort)
++		args[ac++] = "--use-qsort";
++
++	if (am_sender) {
++		if (usermap)
++			args[ac++] = safe_arg("--usermap", usermap);
++
++		if (groupmap)
++			args[ac++] = safe_arg("--groupmap", groupmap);
++
++		if (ignore_existing)
++			args[ac++] = "--ignore-existing";
++
++		/* Backward compatibility: send --existing, not --ignore-non-existing. */
++		if (ignore_non_existing)
++			args[ac++] = "--existing";
++
++		if (tmpdir) {
++			args[ac++] = "--temp-dir";
++			args[ac++] = safe_arg("", tmpdir);
++		}
++
++		if (do_fsync)
++			args[ac++] = "--fsync";
++
++		if (basis_dir[0]) {
++			/* the server only needs this option if it is not the sender,
++			 *   and it may be an older version that doesn't know this
++			 *   option, so don't send it if client is the sender.
++			 */
++			for (i = 0; i < basis_dir_cnt; i++) {
++				args[ac++] = alt_dest_opt(0);
++				args[ac++] = safe_arg("", basis_dir[i]);
++			}
++		}
++	}
++
++	/* What flags do we need to send to the other side? */
++	where = (am_server ? W_CLI : W_SRV) | (am_sender ? W_REC : W_SND);
++	arg = make_output_option(info_words, info_levels, where);
++	if (arg)
++		args[ac++] = arg;
++
++	if (append_mode) {
++		if (append_mode > 1)
++			args[ac++] = "--append";
++		args[ac++] = "--append";
++	} else if (inplace) {
++		args[ac++] = "--inplace";
++		/* Work around a bug in older rsync versions (on the remote side) for --inplace --sparse */
++		if (sparse_files && !whole_file && am_sender)
++			args[ac++] = "--no-W";
++	}
++
++	if (files_from && (!am_sender || filesfrom_host)) {
++		if (filesfrom_host) {
++			args[ac++] = "--files-from";
++			args[ac++] = safe_arg("", files_from);
++			if (eol_nulls)
++				args[ac++] = "--from0";
++		} else {
++			args[ac++] = "--files-from=-";
++			args[ac++] = "--from0";
++		}
++		if (!relative_paths)
++			args[ac++] = "--no-relative";
++	}
++	/* It's OK that this checks the upper-bound of the protocol_version. */
++	if (relative_paths && !implied_dirs && (!am_sender || protocol_version >= 30))
++		args[ac++] = "--no-implied-dirs";
++
++	if (write_devices && am_sender)
++		args[ac++] = "--write-devices";
++
++	if (remove_source_files == 1)
++		args[ac++] = "--remove-source-files";
++	else if (remove_source_files)
++		args[ac++] = "--remove-sent-files";
++
++	if (copy_devices && !am_sender)
++		args[ac++] = "--copy-devices";
++
++	if (preallocate_files && am_sender)
++		args[ac++] = "--preallocate";
++
++	if (open_noatime && preserve_atimes <= 1)
++		args[ac++] = "--open-noatime";
++
++	if (mkpath_dest_arg && am_sender)
++		args[ac++] = "--mkpath";
++
++	if (ac > MAX_SERVER_ARGS) { /* Not possible... */
++		rprintf(FERROR, "argc overflow in server_options().\n");
++		exit_cleanup(RERR_MALLOC);
++	}
++
++	if (remote_option_cnt) {
++		int j;
++		if (ac + remote_option_cnt > MAX_SERVER_ARGS) {
++			rprintf(FERROR, "too many remote options specified.\n");
++			exit_cleanup(RERR_SYNTAX);
++		}
++		for (j = 1; j <= remote_option_cnt; j++)
++			args[ac++] = safe_arg(SPLIT_ARG_WHEN_OLD, remote_options[j]);
++	}
++
++	*argc_p = ac;
++	return;
++
++    oom:
++	out_of_memory("server_options");
++}
++
++int maybe_add_e_option(char *buf, int buf_len)
++{
++	int x = 0;
++
++	/* We don't really know the actual protocol_version at this point,
++	 * but checking the pre-negotiated value allows the user to use a
++	 * --protocol=29 override to avoid the use of this -eFLAGS opt. */
++	if (protocol_version >= 30 && buf_len > 0) {
++		/* We make use of the -e option to let the server know about
++		 * any pre-release protocol version && some behavior flags. */
++		buf[x++] = 'e';
++
++#if SUBPROTOCOL_VERSION != 0
++		if (protocol_version == PROTOCOL_VERSION)
++			x += snprintf(buf + x, buf_len - x, "%d.%d", PROTOCOL_VERSION, SUBPROTOCOL_VERSION);
++		else
++#endif
++			buf[x++] = '.';
++		if (allow_inc_recurse)
++			buf[x++] = 'i';
++#ifdef CAN_SET_SYMLINK_TIMES
++		buf[x++] = 'L'; /* symlink time-setting support */
++#endif
++#ifdef ICONV_OPTION
++		buf[x++] = 's'; /* symlink iconv translation support */
++#endif
++		buf[x++] = 'f'; /* flist I/O-error safety support */
++		buf[x++] = 'x'; /* xattr hardlink optimization not desired */
++		buf[x++] = 'C'; /* support checksum seed order fix */
++		buf[x++] = 'I'; /* support inplace_partial behavior */
++		buf[x++] = 'v'; /* use varint for flist & compat flags; negotiate checksum */
++		buf[x++] = 'u'; /* include name of uid 0 & gid 0 in the id map */
++
++		/* NOTE: Avoid using 'V' -- it was represented with the high bit of a write_byte() that became a write_varint(). */
++	}
++
++	if (x >= buf_len) { /* Not possible... */
++		rprintf(FERROR, "overflow in add_e_flags().\n");
++		exit_cleanup(RERR_MALLOC);
++	}
++
++	buf[x] = '\0';
++
++	return x;
++}
++
++/* If str points to a valid hostspec, return allocated memory containing the
++ * [USER@]HOST part of the string, and set the path_start_ptr to the part of
++ * the string after the host part.  Otherwise, return NULL.  If port_ptr is
++ * non-NULL, we must be parsing an rsync:// URL hostname, and we will set
++ * *port_ptr if a port number is found.  Note that IPv6 IPs will have their
++ * (required for parsing) [ and ] chars elided from the returned string. */
++static char *parse_hostspec(char *str, char **path_start_ptr, int *port_ptr)
++{
++	char *s, *host_start = str;
++	int hostlen = 0, userlen = 0;
++	char *ret;
++
++	for (s = str; ; s++) {
++		if (!*s) {
++			/* It is only OK if we run out of string with rsync:// */
++			if (!port_ptr)
++				return NULL;
++			if (!hostlen)
++				hostlen = s - host_start;
++			break;
++		}
++		if (*s == ':' || *s == '/') {
++			if (!hostlen)
++				hostlen = s - host_start;
++			if (*s++ == '/') {
++				if (!port_ptr)
++					return NULL;
++			} else if (port_ptr) {
++				*port_ptr = atoi(s);
++				while (isDigit(s)) s++;
++				if (*s && *s++ != '/')
++					return NULL;
++			}
++			break;
++		}
++		if (*s == '@') {
++			userlen = s - str + 1;
++			host_start = s + 1;
++		} else if (*s == '[') {
++			if (s != host_start++)
++				return NULL;
++			while (*s && *s != ']' && *s != '/') s++; /*SHARED ITERATOR*/
++			hostlen = s - host_start;
++			if (*s != ']' || (s[1] && s[1] != '/' && s[1] != ':') || !hostlen)
++				return NULL;
++		}
++	}
++
++	*path_start_ptr = s;
++	ret = new_array(char, userlen + hostlen + 1);
++	if (userlen)
++		strlcpy(ret, str, userlen + 1);
++	strlcpy(ret + userlen, host_start, hostlen + 1);
++	return ret;
++}
++
++/* Look for a HOST specification of the form "HOST:PATH", "HOST::PATH", or
++ * "rsync://HOST:PORT/PATH".  If found, *host_ptr will be set to some allocated
++ * memory with the HOST.  If a daemon-accessing spec was specified, the value
++ * of *port_ptr will contain a non-0 port number, otherwise it will be set to
++ * 0.  The return value is a pointer to the PATH.  Note that the HOST spec can
++ * be an IPv6 literal address enclosed in '[' and ']' (such as "[::1]" or
++ * "[::ffff:127.0.0.1]") which is returned without the '[' and ']'. */
++char *check_for_hostspec(char *s, char **host_ptr, int *port_ptr)
++{
++	char *path;
++
++	if (port_ptr && strncasecmp(URL_PREFIX, s, strlen(URL_PREFIX)) == 0) {
++		*host_ptr = parse_hostspec(s + strlen(URL_PREFIX), &path, port_ptr);
++		if (*host_ptr) {
++			if (!*port_ptr)
++				*port_ptr = -1; /* -1 indicates they want the default */
++			return path;
++		}
++	}
++
++	*host_ptr = parse_hostspec(s, &path, NULL);
++	if (!*host_ptr)
++		return NULL;
++
++	if (*path == ':') {
++		if (port_ptr && !*port_ptr)
++			*port_ptr = -1;
++		return path + 1;
++	}
++	if (port_ptr)
++		*port_ptr = 0;
++
++	return path;
++}
+diff --git a/options.c.rej b/options.c.rej
+new file mode 100644
+index 00000000..d86868e6
+--- /dev/null
++++ b/options.c.rej
+@@ -0,0 +1,13 @@
++--- options.c
+++++ options.c
++@@ -744,7 +744,9 @@ static struct poptOption long_options[] = {
++   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
++   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
++   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
++-  {"detect-renamed",   0,  POPT_ARG_NONE,   &detect_renamed, 0, 0, 0 },
+++  {"detect-renamed",   0,  POPT_ARG_VAL,    &detect_renamed, 1, 0, 0 },
+++  {"detect-renamed-lax",0, POPT_ARG_VAL,    &detect_renamed, 2, 0, 0 },
+++  {"detect-moved",     0,  POPT_ARG_VAL,    &detect_renamed, 3, 0, 0 },
++   {"fuzzy",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },
++   {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
++   {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
+diff --git a/receiver.c b/receiver.c
+index 6b4b369e..c7caef77 100644
+--- a/receiver.c
++++ b/receiver.c
+@@ -220,7 +220,7 @@ int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file)
+ 	 * information should have been previously transferred, but that may
+ 	 * not be the case with -R */
+ 	if (fd == -1 && relative_paths && errno == ENOENT
+-	 && make_path(fnametmp, MKP_SKIP_SLASH | MKP_DROP_NAME) == 0) {
++	 && make_path(fnametmp, ACCESSPERMS, MKP_SKIP_SLASH | MKP_DROP_NAME) == 0) {
+ 		/* Get back to name with XXXXXX in it. */
+ 		get_tmpname(fnametmp, fname, False);
+ 		fd = do_mkstemp(fnametmp, (file->mode|added_perms) & INITACCESSPERMS);
+diff --git a/rsync.1.md b/rsync.1.md
+index 2ae6f481..c1f2c50c 100644
+--- a/rsync.1.md
++++ b/rsync.1.md
+@@ -507,9 +507,13 @@ has its own detailed description later in this manpage.
+ --modify-window=NUM, -@  set the accuracy for mod-time comparisons
+ --temp-dir=DIR, -T       create temporary files in directory DIR
+ --fuzzy, -y              find similar file for basis if no dest file
++--detect-renamed         try to find renamed files to speed the xfer
++--detect-renamed-lax     ...& assume identical to src files (risky!)
++--detect-moved           ... only if basenames match (less risky)
+ --compare-dest=DIR       also compare destination files relative to DIR
+ --copy-dest=DIR          ... and include copies of unchanged files
+ --link-dest=DIR          hardlink to files in DIR when unchanged
++--clone-dest=DIR         clone (reflink) files from DIR when unchanged
+ --compress, -z           compress file data during the transfer
+ --compress-choice=STR    choose the compression algorithm (aka --zc)
+ --compress-level=NUM     explicitly set compression level (aka --zl)
+@@ -2635,6 +2639,36 @@ expand it.
+     potential fuzzy-match files, so either use [`--delete-after`](#opt) or
+     specify some filename exclusions if you need to prevent this.
+ 
++0.  `--detect-renamed`
++
++    With this option, for each new source file (call it `src/S`), rsync looks
++    for a file `dest/D` anywhere in the destination that passes the quick check
++    with `src/S`.  If such a `dest/D` is found, rsync uses it as an alternate
++    basis for transferring `S`.  The idea is that if `src/S` was renamed from
++    `src/D` (as opposed to `src/S` passing the quick check with `dest/D` by
++    coincidence), the delta-transfer algorithm will find that all the data
++    matches between `src/S` and `dest/D`, and the transfer will be really fast.
++
++    By default, alternate-basis files are hard-linked into a directory named
++    ".~tmp~" in each file's destination directory, but if you've specified the
++    [`--partial-dir`](#opt) option, that directory will be used instead.  These
++    otential alternate-basis files will be removed as the transfer progresses.
++    This option conflicts with [`--inplace`](#opt) and [`--append`](#opt).
++
++0.  `--detect-renamed-lax`
++
++    This version of [`--detect-renamed`](#opt) makes rsync hard-link `dest/D`
++    to `dest/S` without verifying that `src/S` and `dest/S` have the same data.
++    This poses a significant risk of corrupting the destination by representing
++    a new source file by an unrelated destination file that coincidentally
++    passes the quick check with the source file.  Use this option only if you
++    accept the risk and disk I/O is a bottleneck.
++
++0.  `--detect-moved`
++
++    A less risky variant of [`--detect-renamed-lax`](#opt) that only uses a
++    destination file that has the same basename as the new source file.
++
+ 0.  `--compare-dest=DIR`
+ 
+     This option instructs rsync to use _DIR_ on the destination machine as an
+@@ -2720,6 +2754,18 @@ expand it.
+     this bug by avoiding the `-o` option (or using `--no-o`) when sending to an
+     old rsync.
+ 
++0.  `--clone-dest=DIR`
++
++    This option behaves like [`--link-dest`](#opt), but unchanged files are
++    reflinked from _DIR_ to the destination directory.  The files do not need
++    to match in attributes, as the data is cloned separately from the
++    attributes.
++
++    If _DIR_ is a relative path, it is relative to the destination directory.
++    See also [`--compare-dest`](#opt) and [`--copy-dest`](#opt).
++
++    All non-regular files are hard-linked (when possible).
++
+ 0.  `--compress`, `-z`
+ 
+     With this option, rsync compresses the file data as it is sent to the
+diff --git a/rsync.1.md.orig b/rsync.1.md.orig
+new file mode 100644
+index 00000000..4d25a8ec
+--- /dev/null
++++ b/rsync.1.md.orig
+@@ -0,0 +1,4875 @@
++## NAME
++
++rsync - a fast, versatile, remote (and local) file-copying tool
++
++## SYNOPSIS
++
++```
++Local:
++    rsync [OPTION...] SRC... [DEST]
++
++Access via remote shell:
++    Pull:
++        rsync [OPTION...] [USER@]HOST:SRC... [DEST]
++    Push:
++        rsync [OPTION...] SRC... [USER@]HOST:DEST
++
++Access via rsync daemon:
++    Pull:
++        rsync [OPTION...] [USER@]HOST::SRC... [DEST]
++        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
++    Push:
++        rsync [OPTION...] SRC... [USER@]HOST::DEST
++        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)
++```
++
++Usages with just one SRC arg and no DEST arg will list the source files instead
++of copying.
++
++The online version of this manpage (that includes cross-linking of topics)
++is available at <https://download.samba.org/pub/rsync/rsync.1>.
++
++## DESCRIPTION
++
++Rsync is a fast and extraordinarily versatile file copying tool.  It can copy
++locally, to/from another host over any remote shell, or to/from a remote rsync
++daemon.  It offers a large number of options that control every aspect of its
++behavior and permit very flexible specification of the set of files to be
++copied.  It is famous for its delta-transfer algorithm, which reduces the
++amount of data sent over the network by sending only the differences between
++the source files and the existing files in the destination.  Rsync is widely
++used for backups and mirroring and as an improved copy command for everyday
++use.
++
++Rsync finds files that need to be transferred using a "quick check" algorithm
++(by default) that looks for files that have changed in size or in last-modified
++time.  Any changes in the other preserved attributes (as requested by options)
++are made on the destination file directly when the quick check indicates that
++the file's data does not need to be updated.
++
++Some of the additional features of rsync are:
++
++- support for copying links, devices, owners, groups, and permissions
++- exclude and exclude-from options similar to GNU tar
++- a CVS exclude mode for ignoring the same files that CVS would ignore
++- can use any transparent remote shell, including ssh or rsh
++- does not require super-user privileges
++- pipelining of file transfers to minimize latency costs
++- support for anonymous or authenticated rsync daemons (ideal for mirroring)
++
++## GENERAL
++
++Rsync copies files either to or from a remote host, or locally on the current
++host (it does not support copying files between two remote hosts).
++
++There are two different ways for rsync to contact a remote system: using a
++remote-shell program as the transport (such as ssh or rsh) or contacting an
++rsync daemon directly via TCP.  The remote-shell transport is used whenever the
++source or destination path contains a single colon (:) separator after a host
++specification.  Contacting an rsync daemon directly happens when the source or
++destination path contains a double colon (::) separator after a host
++specification, OR when an rsync:// URL is specified (see also the [USING
++RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION](#) section for an
++exception to this latter rule).
++
++As a special case, if a single source arg is specified without a destination,
++the files are listed in an output format similar to "`ls -l`".
++
++As expected, if neither the source or destination path specify a remote host,
++the copy occurs locally (see also the [`--list-only`](#opt) option).
++
++Rsync refers to the local side as the client and the remote side as the server.
++Don't confuse server with an rsync daemon.  A daemon is always a server, but a
++server can be either a daemon or a remote-shell spawned process.
++
++## SETUP
++
++See the file README.md for installation instructions.
++
++Once installed, you can use rsync to any machine that you can access via a
++remote shell (as well as some that you can access using the rsync daemon-mode
++protocol).  For remote transfers, a modern rsync uses ssh for its
++communications, but it may have been configured to use a different remote shell
++by default, such as rsh or remsh.
++
++You can also specify any remote shell you like, either by using the [`-e`](#opt)
++command line option, or by setting the [`RSYNC_RSH`](#) environment variable.
++
++Note that rsync must be installed on both the source and destination machines.
++
++## USAGE
++
++You use rsync in the same way you use rcp.  You must specify a source and a
++destination, one of which may be remote.
++
++Perhaps the best way to explain the syntax is with some examples:
++
++>     rsync -t *.c foo:src/
++
++This would transfer all files matching the pattern `*.c` from the current
++directory to the directory src on the machine foo.  If any of the files already
++exist on the remote system then the rsync remote-update protocol is used to
++update the file by sending only the differences in the data.  Note that the
++expansion of wildcards on the command-line (`*.c`) into a list of files is
++handled by the shell before it runs rsync and not by rsync itself (exactly the
++same as all other Posix-style programs).
++
++>     rsync -avz foo:src/bar /data/tmp
++
++This would recursively transfer all files from the directory src/bar on the
++machine foo into the /data/tmp/bar directory on the local machine.  The files
++are transferred in archive mode, which ensures that symbolic links, devices,
++attributes, permissions, ownerships, etc. are preserved in the transfer.
++Additionally, compression will be used to reduce the size of data portions of
++the transfer.
++
++>     rsync -avz foo:src/bar/ /data/tmp
++
++A trailing slash on the source changes this behavior to avoid creating an
++additional directory level at the destination.  You can think of a trailing /
++on a source as meaning "copy the contents of this directory" as opposed to
++"copy the directory by name", but in both cases the attributes of the
++containing directory are transferred to the containing directory on the
++destination.  In other words, each of the following commands copies the files
++in the same way, including their setting of the attributes of /dest/foo:
++
++>     rsync -av /src/foo /dest
++>     rsync -av /src/foo/ /dest/foo
++
++Note also that host and module references don't require a trailing slash to
++copy the contents of the default directory.  For example, both of these copy
++the remote directory's contents into "/dest":
++
++>     rsync -av host: /dest
++>     rsync -av host::module /dest
++
++You can also use rsync in local-only mode, where both the source and
++destination don't have a ':' in the name.  In this case it behaves like an
++improved copy command.
++
++Finally, you can list all the (listable) modules available from a particular
++rsync daemon by leaving off the module name:
++
++>     rsync somehost.mydomain.com::
++
++## COPYING TO A DIFFERENT NAME
++
++When you want to copy a directory to a different name, use a trailing slash on
++the source directory to put the contents of the directory into any destination
++directory you like:
++
++>     rsync -ai foo/ bar/
++
++Rsync also has the ability to customize a destination file's name when copying
++a single item.  The rules for this are:
++
++- The transfer list must consist of a single item (either a file or an empty
++  directory)
++- The final element of the destination path must not exist as a directory
++- The destination path must not have been specified with a trailing slash
++
++Under those circumstances, rsync will set the name of the destination's single
++item to the last element of the destination path.  Keep in mind that it is best
++to only use this idiom when copying a file and use the above trailing-slash
++idiom when copying a directory.
++
++The following example copies the `foo.c` file as `bar.c` in the `save` dir
++(assuming that `bar.c` isn't a directory):
++
++>     rsync -ai src/foo.c save/bar.c
++
++The single-item copy rule might accidentally bite you if you unknowingly copy a
++single item and specify a destination dir that doesn't exist (without using a
++trailing slash).  For example, if `src/*.c` matches one file and `save/dir`
++doesn't exist, this will confuse you by naming the destination file `save/dir`:
++
++>     rsync -ai src/*.c save/dir
++
++To prevent such an accident, either make sure the destination dir exists or
++specify the destination path with a trailing slash:
++
++>     rsync -ai src/*.c save/dir/
++
++## SORTED TRANSFER ORDER
++
++Rsync always sorts the specified filenames into its internal transfer list.
++This handles the merging together of the contents of identically named
++directories, makes it easy to remove duplicate filenames. It can, however,
++confuse someone when the files are transferred in a different order than what
++was given on the command-line.
++
++If you need a particular file to be transferred prior to another, either
++separate the files into different rsync calls, or consider using
++[`--delay-updates`](#opt) (which doesn't affect the sorted transfer order, but
++does make the final file-updating phase happen much more rapidly).
++
++## MULTI-HOST SECURITY
++
++Rsync takes steps to ensure that the file requests that are shared in a
++transfer are protected against various security issues.  Most of the potential
++problems arise on the receiving side where rsync takes steps to ensure that the
++list of files being transferred remains within the bounds of what was
++requested.
++
++Toward this end, rsync 3.1.2 and later have aborted when a file list contains
++an absolute or relative path that tries to escape out of the top of the
++transfer.  Also, beginning with version 3.2.5, rsync does two more safety
++checks of the file list to (1) ensure that no extra source arguments were added
++into the transfer other than those that the client requested and (2) ensure
++that the file list obeys the exclude rules that were sent to the sender.
++
++For those that don't yet have a 3.2.5 client rsync (or those that want to be
++extra careful), it is safest to do a copy into a dedicated destination
++directory for the remote files when you don't trust the remote host.  For
++example, instead of doing an rsync copy into your home directory:
++
++>     rsync -aiv host1:dir1 ~
++
++Dedicate a "host1-files" dir to the remote content:
++
++>     rsync -aiv host1:dir1 ~/host1-files
++
++See the [`--trust-sender`](#opt) option for additional details.
++
++CAUTION: it is not particularly safe to use rsync to copy files from a
++case-preserving filesystem to a case-ignoring filesystem.  If you must perform
++such a copy, you should either disable symlinks via `--no-links` or enable the
++munging of symlinks via [`--munge-links`](#opt) (and make sure you use the
++right local or remote option).  This will prevent rsync from doing potentially
++dangerous things if a symlink name overlaps with a file or directory. It does
++not, however, ensure that you get a full copy of all the files (since that may
++not be possible when the names overlap). A potentially better solution is to
++list all the source files and create a safe list of filenames that you pass to
++the [`--files-from`](#opt) option.  Any files that conflict in name would need
++to be copied to different destination directories using more than one copy.
++
++While a copy of a case-ignoring filesystem to a case-ignoring filesystem can
++work out fairly well, if no `--delete-during` or `--delete-before` option is
++active, rsync can potentially update an existing file on the receiving side
++without noticing that the upper-/lower-case of the filename should be changed
++to match the sender.
++
++## ADVANCED USAGE
++
++The syntax for requesting multiple files from a remote host is done by
++specifying additional remote-host args in the same style as the first, or with
++the hostname omitted.  For instance, all these work:
++
++>     rsync -aiv host:file1 :file2 host:file{3,4} /dest/
++>     rsync -aiv host::modname/file{1,2} host::modname/extra /dest/
++>     rsync -aiv host::modname/first ::extra-file{1,2} /dest/
++
++Note that a daemon connection only supports accessing one module per copy
++command, so if the start of a follow-up path doesn't begin with the
++modname of the first path, it is assumed to be a path in the module (such as
++the extra-file1 & extra-file2 that are grabbed above).
++
++Really old versions of rsync (2.6.9 and before) only allowed specifying one
++remote-source arg, so some people have instead relied on the remote-shell
++performing space splitting to break up an arg into multiple paths. Such
++unintuitive behavior is no longer supported by default (though you can request
++it, as described below).
++
++Starting in 3.2.4, filenames are passed to a remote shell in such a way as to
++preserve the characters you give it. Thus, if you ask for a file with spaces
++in the name, that's what the remote rsync looks for:
++
++>     rsync -aiv host:'a simple file.pdf' /dest/
++
++If you use scripts that have been written to manually apply extra quoting to
++the remote rsync args (or to require remote arg splitting), you can ask rsync
++to let your script handle the extra escaping.  This is done by either adding
++the [`--old-args`](#opt) option to the rsync runs in the script (which requires
++a new rsync) or exporting [RSYNC_OLD_ARGS](#)=1 and [RSYNC_PROTECT_ARGS](#)=0
++(which works with old or new rsync versions).
++
++## CONNECTING TO AN RSYNC DAEMON
++
++It is also possible to use rsync without a remote shell as the transport.  In
++this case you will directly connect to a remote rsync daemon, typically using
++TCP port 873. (This obviously requires the daemon to be running on the remote
++system, so refer to the [STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS](#)
++section below for information on that.)
++
++Using rsync in this way is the same as using it with a remote shell except
++that:
++
++- Use either double-colon syntax or rsync:// URL syntax instead of the
++  single-colon (remote shell) syntax.
++- The first element of the "path" is actually a module name.
++- Additional remote source args can use an abbreviated syntax that omits the
++  hostname and/or the module name, as discussed in [ADVANCED USAGE](#).
++- The remote daemon may print a "message of the day" when you connect.
++- If you specify only the host (with no module or path) then a list of
++  accessible modules on the daemon is output.
++- If you specify a remote source path but no destination, a listing of the
++  matching files on the remote daemon is output.
++- The [`--rsh`](#opt) (`-e`) option must be omitted to avoid changing the
++  connection style from using a socket connection to [USING RSYNC-DAEMON
++  FEATURES VIA A REMOTE-SHELL CONNECTION](#).
++
++An example that copies all the files in a remote module named "src":
++
++>     rsync -av host::src /dest
++
++Some modules on the remote daemon may require authentication.  If so, you will
++receive a password prompt when you connect.  You can avoid the password prompt
++by setting the environment variable [`RSYNC_PASSWORD`](#) to the password you
++want to use or using the [`--password-file`](#opt) option.  This may be useful
++when scripting rsync.
++
++WARNING: On some systems environment variables are visible to all users.  On
++those systems using [`--password-file`](#opt) is recommended.
++
++You may establish the connection via a web proxy by setting the environment
++variable [`RSYNC_PROXY`](#) to a hostname:port pair pointing to your web proxy.
++Note that your web proxy's configuration must support proxy connections to port
++873.
++
++You may also establish a daemon connection using a program as a proxy by
++setting the environment variable [`RSYNC_CONNECT_PROG`](#) to the commands you
++wish to run in place of making a direct socket connection.  The string may
++contain the escape "%H" to represent the hostname specified in the rsync
++command (so use "%%" if you need a single "%" in your string).  For example:
++
++>     export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
++>     rsync -av targethost1::module/src/ /dest/
++>     rsync -av rsync://targethost2/module/src/ /dest/
++
++The command specified above uses ssh to run nc (netcat) on a proxyhost, which
++forwards all data to port 873 (the rsync daemon) on the targethost (%H).
++
++Note also that if the [`RSYNC_SHELL`](#) environment variable is set, that
++program will be used to run the `RSYNC_CONNECT_PROG` command instead of using
++the default shell of the **system()** call.
++
++## USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION
++
++It is sometimes useful to use various features of an rsync daemon (such as
++named modules) without actually allowing any new socket connections into a
++system (other than what is already required to allow remote-shell access).
++Rsync supports connecting to a host using a remote shell and then spawning a
++single-use "daemon" server that expects to read its config file in the home dir
++of the remote user.  This can be useful if you want to encrypt a daemon-style
++transfer's data, but since the daemon is started up fresh by the remote user,
++you may not be able to use features such as chroot or change the uid used by
++the daemon. (For another way to encrypt a daemon transfer, consider using ssh
++to tunnel a local port to a remote machine and configure a normal rsync daemon
++on that remote host to only allow connections from "localhost".)
++
++From the user's perspective, a daemon transfer via a remote-shell connection
++uses nearly the same command-line syntax as a normal rsync-daemon transfer,
++with the only exception being that you must explicitly set the remote shell
++program on the command-line with the [`--rsh=COMMAND`](#opt) option. (Setting the
++RSYNC_RSH in the environment will not turn on this functionality.) For example:
++
++>     rsync -av --rsh=ssh host::module /dest
++
++If you need to specify a different remote-shell user, keep in mind that the
++user@ prefix in front of the host is specifying the rsync-user value (for a
++module that requires user-based authentication).  This means that you must give
++the '-l user' option to ssh when specifying the remote-shell, as in this
++example that uses the short version of the [`--rsh`](#opt) option:
++
++>     rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest
++
++The "ssh-user" will be used at the ssh level; the "rsync-user" will be used to
++log-in to the "module".
++
++In this setup, the daemon is started by the ssh command that is accessing the
++system (which can be forced via the `~/.ssh/authorized_keys` file, if desired).
++However, when accessing a daemon directly, it needs to be started beforehand.
++
++## STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS
++
++In order to connect to an rsync daemon, the remote system needs to have a
++daemon already running (or it needs to have configured something like inetd to
++spawn an rsync daemon for incoming connections on a particular port).  For full
++information on how to start a daemon that will handling incoming socket
++connections, see the [**rsyncd.conf**(5)](rsyncd.conf.5) manpage -- that is
++the config file for the daemon, and it contains the full details for how to run
++the daemon (including stand-alone and inetd configurations).
++
++If you're using one of the remote-shell transports for the transfer, there is
++no need to manually start an rsync daemon.
++
++## EXAMPLES
++
++Here are some examples of how rsync can be used.
++
++To backup a home directory, which consists of large MS Word files and mail
++folders, a per-user cron job can be used that runs this each day:
++
++>     rsync -aiz . bkhost:backup/joe/
++
++To move some files from a remote host to the local host, you could run:
++
++>     rsync -aiv --remove-source-files rhost:/tmp/{file1,file2}.c ~/src/
++
++## OPTION SUMMARY
++
++Here is a short summary of the options available in rsync.  Each option also
++has its own detailed description later in this manpage.
++
++[comment]: # (help-rsync.h)
++[comment]: # (Keep these short enough that they'll be under 80 chars when indented by 7 chars.)
++
++```
++--verbose, -v            increase verbosity
++--info=FLAGS             fine-grained informational verbosity
++--debug=FLAGS            fine-grained debug verbosity
++--stderr=e|a|c           change stderr output mode (default: errors)
++--quiet, -q              suppress non-error messages
++--no-motd                suppress daemon-mode MOTD
++--checksum, -c           skip based on checksum, not mod-time & size
++--archive, -a            archive mode is -rlptgoD (no -A,-X,-U,-N,-H)
++--no-OPTION              turn off an implied OPTION (e.g. --no-D)
++--recursive, -r          recurse into directories
++--relative, -R           use relative path names
++--no-implied-dirs        don't send implied dirs with --relative
++--backup, -b             make backups (see --suffix & --backup-dir)
++--backup-dir=DIR         make backups into hierarchy based in DIR
++--suffix=SUFFIX          backup suffix (default ~ w/o --backup-dir)
++--update, -u             skip files that are newer on the receiver
++--inplace                update destination files in-place
++--append                 append data onto shorter files
++--append-verify          --append w/old data in file checksum
++--dirs, -d               transfer directories without recursing
++--old-dirs, --old-d      works like --dirs when talking to old rsync
++--mkpath                 create destination's missing path components
++--links, -l              copy symlinks as symlinks
++--copy-links, -L         transform symlink into referent file/dir
++--copy-unsafe-links      only "unsafe" symlinks are transformed
++--safe-links             ignore symlinks that point outside the tree
++--munge-links            munge symlinks to make them safe & unusable
++--copy-dirlinks, -k      transform symlink to dir into referent dir
++--keep-dirlinks, -K      treat symlinked dir on receiver as dir
++--hard-links, -H         preserve hard links
++--perms, -p              preserve permissions
++--executability, -E      preserve executability
++--chmod=CHMOD            affect file and/or directory permissions
++--acls, -A               preserve ACLs (implies --perms)
++--xattrs, -X             preserve extended attributes
++--owner, -o              preserve owner (super-user only)
++--group, -g              preserve group
++--devices                preserve device files (super-user only)
++--copy-devices           copy device contents as a regular file
++--write-devices          write to devices as files (implies --inplace)
++--specials               preserve special files
++-D                       same as --devices --specials
++--times, -t              preserve modification times
++--atimes, -U             preserve access (use) times
++--open-noatime           avoid changing the atime on opened files
++--crtimes, -N            preserve create times (newness)
++--omit-dir-times, -O     omit directories from --times
++--omit-link-times, -J    omit symlinks from --times
++--super                  receiver attempts super-user activities
++--fake-super             store/recover privileged attrs using xattrs
++--sparse, -S             turn sequences of nulls into sparse blocks
++--preallocate            allocate dest files before writing them
++--dry-run, -n            perform a trial run with no changes made
++--whole-file, -W         copy files whole (w/o delta-xfer algorithm)
++--checksum-choice=STR    choose the checksum algorithm (aka --cc)
++--one-file-system, -x    don't cross filesystem boundaries
++--block-size=SIZE, -B    force a fixed checksum block-size
++--rsh=COMMAND, -e        specify the remote shell to use
++--rsync-path=PROGRAM     specify the rsync to run on remote machine
++--existing               skip creating new files on receiver
++--ignore-existing        skip updating files that exist on receiver
++--remove-source-files    sender removes synchronized files (non-dir)
++--del                    an alias for --delete-during
++--delete                 delete extraneous files from dest dirs
++--delete-before          receiver deletes before xfer, not during
++--delete-during          receiver deletes during the transfer
++--delete-delay           find deletions during, delete after
++--delete-after           receiver deletes after transfer, not during
++--delete-excluded        also delete excluded files from dest dirs
++--ignore-missing-args    ignore missing source args without error
++--delete-missing-args    delete missing source args from destination
++--ignore-errors          delete even if there are I/O errors
++--force                  force deletion of dirs even if not empty
++--max-delete=NUM         don't delete more than NUM files
++--max-size=SIZE          don't transfer any file larger than SIZE
++--min-size=SIZE          don't transfer any file smaller than SIZE
++--max-alloc=SIZE         change a limit relating to memory alloc
++--partial                keep partially transferred files
++--partial-dir=DIR        put a partially transferred file into DIR
++--delay-updates          put all updated files into place at end
++--prune-empty-dirs, -m   prune empty directory chains from file-list
++--numeric-ids            don't map uid/gid values by user/group name
++--usermap=STRING         custom username mapping
++--groupmap=STRING        custom groupname mapping
++--chown=USER:GROUP       simple username/groupname mapping
++--timeout=SECONDS        set I/O timeout in seconds
++--contimeout=SECONDS     set daemon connection timeout in seconds
++--ignore-times, -I       don't skip files that match size and time
++--size-only              skip files that match in size
++--modify-window=NUM, -@  set the accuracy for mod-time comparisons
++--temp-dir=DIR, -T       create temporary files in directory DIR
++--fuzzy, -y              find similar file for basis if no dest file
++--detect-renamed         try to find renamed files to speed the xfer
++--compare-dest=DIR       also compare destination files relative to DIR
++--copy-dest=DIR          ... and include copies of unchanged files
++--link-dest=DIR          hardlink to files in DIR when unchanged
++--clone-dest=DIR         clone (reflink) files from DIR when unchanged
++--compress, -z           compress file data during the transfer
++--compress-choice=STR    choose the compression algorithm (aka --zc)
++--compress-level=NUM     explicitly set compression level (aka --zl)
++--skip-compress=LIST     skip compressing files with suffix in LIST
++--cvs-exclude, -C        auto-ignore files in the same way CVS does
++--filter=RULE, -f        add a file-filtering RULE
++-F                       same as --filter='dir-merge /.rsync-filter'
++                         repeated: --filter='- .rsync-filter'
++--exclude=PATTERN        exclude files matching PATTERN
++--exclude-from=FILE      read exclude patterns from FILE
++--include=PATTERN        don't exclude files matching PATTERN
++--include-from=FILE      read include patterns from FILE
++--files-from=FILE        read list of source-file names from FILE
++--from0, -0              all *-from/filter files are delimited by 0s
++--old-args               disable the modern arg-protection idiom
++--secluded-args, -s      use the protocol to safely send the args
++--trust-sender           trust the remote sender's file list
++--copy-as=USER[:GROUP]   specify user & optional group for the copy
++--address=ADDRESS        bind address for outgoing socket to daemon
++--port=PORT              specify double-colon alternate port number
++--sockopts=OPTIONS       specify custom TCP options
++--blocking-io            use blocking I/O for the remote shell
++--outbuf=N|L|B           set out buffering to None, Line, or Block
++--stats                  give some file-transfer stats
++--8-bit-output, -8       leave high-bit chars unescaped in output
++--human-readable, -h     output numbers in a human-readable format
++--progress               show progress during transfer
++-P                       same as --partial --progress
++--itemize-changes, -i    output a change-summary for all updates
++--remote-option=OPT, -M  send OPTION to the remote side only
++--out-format=FORMAT      output updates using the specified FORMAT
++--log-file=FILE          log what we're doing to the specified FILE
++--log-file-format=FMT    log updates using the specified FMT
++--password-file=FILE     read daemon-access password from FILE
++--early-input=FILE       use FILE for daemon's early exec input
++--list-only              list the files instead of copying them
++--bwlimit=RATE           limit socket I/O bandwidth
++--stop-after=MINS        Stop rsync after MINS minutes have elapsed
++--stop-at=y-m-dTh:m      Stop rsync at the specified point in time
++--fsync                  fsync every written file
++--write-batch=FILE       write a batched update to FILE
++--only-write-batch=FILE  like --write-batch but w/o updating dest
++--read-batch=FILE        read a batched update from FILE
++--protocol=NUM           force an older protocol version to be used
++--iconv=CONVERT_SPEC     request charset conversion of filenames
++--checksum-seed=NUM      set block/file checksum seed (advanced)
++--ipv4, -4               prefer IPv4
++--ipv6, -6               prefer IPv6
++--version, -V            print the version + other info and exit
++--help, -h (*)           show this help (* -h is help only on its own)
++```
++
++Rsync can also be run as a daemon, in which case the following options are
++accepted:
++
++[comment]: # (help-rsyncd.h)
++
++```
++--daemon                 run as an rsync daemon
++--address=ADDRESS        bind to the specified address
++--bwlimit=RATE           limit socket I/O bandwidth
++--config=FILE            specify alternate rsyncd.conf file
++--dparam=OVERRIDE, -M    override global daemon config parameter
++--no-detach              do not detach from the parent
++--port=PORT              listen on alternate port number
++--log-file=FILE          override the "log file" setting
++--log-file-format=FMT    override the "log format" setting
++--sockopts=OPTIONS       specify custom TCP options
++--verbose, -v            increase verbosity
++--ipv4, -4               prefer IPv4
++--ipv6, -6               prefer IPv6
++--help, -h               show this help (when used with --daemon)
++```
++
++## OPTIONS
++
++Rsync accepts both long (double-dash + word) and short (single-dash + letter)
++options.  The full list of the available options are described below.  If an
++option can be specified in more than one way, the choices are comma-separated.
++Some options only have a long variant, not a short.
++
++If the option takes a parameter, the parameter is only listed after the long
++variant, even though it must also be specified for the short.  When specifying
++a parameter, you can either use the form `--option=param`, `--option param`,
++`-o=param`, `-o param`, or `-oparam` (the latter choices assume that your
++option has a short variant).
++
++The parameter may need to be quoted in some manner for it to survive the
++shell's command-line parsing.  Also keep in mind that a leading tilde (`~`) in
++a pathname is substituted by your shell, so make sure that you separate the
++option name from the pathname using a space if you want the local shell to
++expand it.
++
++[comment]: # (Some markup below uses a literal non-breakable space when a backtick string)
++[comment]: # (needs to contain a space since markdown strips spaces from the start/end)
++
++[comment]: # (An OL starting at 0 is converted into a DL by the parser.)
++
++0.  `--help`
++
++    Print a short help page describing the options available in rsync and exit.
++    You can also use `-h` for `--help` when it is used without any other
++    options (since it normally means [`--human-readable`](#opt)).
++
++0.  `--version`, `-V`
++
++    Print the rsync version plus other info and exit.  When repeated, the
++    information is output is a JSON format that is still fairly readable
++    (client side only).
++
++    The output includes a list of compiled-in capabilities, a list of
++    optimizations, the default list of checksum algorithms, the default list of
++    compression algorithms, the default list of daemon auth digests, a link to
++    the rsync web site, and a few other items.
++
++0.  `--verbose`, `-v`
++
++    This option increases the amount of information you are given during the
++    transfer.  By default, rsync works silently.  A single `-v` will give you
++    information about what files are being transferred and a brief summary at
++    the end.  Two `-v` options will give you information on what files are
++    being skipped and slightly more information at the end.  More than two `-v`
++    options should only be used if you are debugging rsync.
++
++    The end-of-run summary tells you the number of bytes sent to the remote
++    rsync (which is the receiving side on a local copy), the number of bytes
++    received from the remote host, and the average bytes per second of the
++    transferred data computed over the entire length of the rsync run. The
++    second line shows the total size (in bytes), which is the sum of all the
++    file sizes that rsync considered transferring.  It also shows a "speedup"
++    value, which is a ratio of the total file size divided by the sum of the
++    sent and received bytes (which is really just a feel-good bigger-is-better
++    number).  Note that these byte values can be made more (or less)
++    human-readable by using the [`--human-readable`](#opt) (or
++    `--no-human-readable`) options.
++
++    In a modern rsync, the `-v` option is equivalent to the setting of groups
++    of [`--info`](#opt) and [`--debug`](#opt) options.  You can choose to use
++    these newer options in addition to, or in place of using `--verbose`, as
++    any fine-grained settings override the implied settings of `-v`.  Both
++    [`--info`](#opt) and [`--debug`](#opt) have a way to ask for help that
++    tells you exactly what flags are set for each increase in verbosity.
++
++    However, do keep in mind that a daemon's "`max verbosity`" setting will limit
++    how high of a level the various individual flags can be set on the daemon
++    side.  For instance, if the max is 2, then any info and/or debug flag that
++    is set to a higher value than what would be set by `-vv` will be downgraded
++    to the `-vv` level in the daemon's logging.
++
++0.  `--info=FLAGS`
++
++    This option lets you have fine-grained control over the information output
++    you want to see.  An individual flag name may be followed by a level
++    number, with 0 meaning to silence that output, 1 being the default output
++    level, and higher numbers increasing the output of that flag (for those
++    that support higher levels).  Use `--info=help` to see all the available
++    flag names, what they output, and what flag names are added for each
++    increase in the verbose level.  Some examples:
++
++    >     rsync -a --info=progress2 src/ dest/
++    >     rsync -avv --info=stats2,misc1,flist0 src/ dest/
++
++    Note that `--info=name`'s output is affected by the [`--out-format`](#opt)
++    and [`--itemize-changes`](#opt) (`-i`) options.  See those options for more
++    information on what is output and when.
++
++    This option was added to 3.1.0, so an older rsync on the server side might
++    reject your attempts at fine-grained control (if one or more flags needed
++    to be send to the server and the server was too old to understand them).
++    See also the "`max verbosity`" caveat above when dealing with a daemon.
++
++0.  `--debug=FLAGS`
++
++    This option lets you have fine-grained control over the debug output you
++    want to see.  An individual flag name may be followed by a level number,
++    with 0 meaning to silence that output, 1 being the default output level,
++    and higher numbers increasing the output of that flag (for those that
++    support higher levels).  Use `--debug=help` to see all the available flag
++    names, what they output, and what flag names are added for each increase in
++    the verbose level.  Some examples:
++
++    >     rsync -avvv --debug=none src/ dest/
++    >     rsync -avA --del --debug=del2,acl src/ dest/
++
++    Note that some debug messages will only be output when the [`--stderr=all`](#opt)
++    option is specified, especially those pertaining to I/O and buffer debugging.
++
++    Beginning in 3.2.0, this option is no longer auto-forwarded to the server
++    side in order to allow you to specify different debug values for each side
++    of the transfer, as well as to specify a new debug option that is only
++    present in one of the rsync versions.  If you want to duplicate the same
++    option on both sides, using brace expansion is an easy way to save you some
++    typing.  This works in zsh and bash:
++
++    >     rsync -aiv {-M,}--debug=del2 src/ dest/
++
++0.  `--stderr=errors|all|client`
++
++    This option controls which processes output to stderr and if info messages
++    are also changed to stderr.  The mode strings can be abbreviated, so feel
++    free to use a single letter value.  The 3 possible choices are:
++
++    - `errors` - (the default) causes all the rsync processes to send an
++      error directly to stderr, even if the process is on the remote side of
++      the transfer.  Info messages are sent to the client side via the protocol
++      stream.  If stderr is not available (i.e. when directly connecting with a
++      daemon via a socket) errors fall back to being sent via the protocol
++      stream.
++
++    - `all` - causes all rsync messages (info and error) to get written
++      directly to stderr from all (possible) processes.  This causes stderr to
++      become line-buffered (instead of raw) and eliminates the ability to
++      divide up the info and error messages by file handle.  For those doing
++      debugging or using several levels of verbosity, this option can help to
++      avoid clogging up the transfer stream (which should prevent any chance of
++      a deadlock bug hanging things up).  It also allows [`--debug`](#opt) to
++      enable some extra I/O related messages.
++
++    - `client` - causes all rsync messages to be sent to the client side
++      via the protocol stream.  One client process outputs all messages, with
++      errors on stderr and info messages on stdout.  This **was** the default
++      in older rsync versions, but can cause error delays when a lot of
++      transfer data is ahead of the messages.  If you're pushing files to an
++      older rsync, you may want to use `--stderr=all` since that idiom has
++      been around for several releases.
++
++    This option was added in rsync 3.2.3.  This version also began the
++    forwarding of a non-default setting to the remote side, though rsync uses
++    the backward-compatible options `--msgs2stderr` and `--no-msgs2stderr` to
++    represent the `all` and `client` settings, respectively.  A newer rsync
++    will continue to accept these older option names to maintain compatibility.
++
++0.  `--quiet`, `-q`
++
++    This option decreases the amount of information you are given during the
++    transfer, notably suppressing information messages from the remote server.
++    This option is useful when invoking rsync from cron.
++
++0.  `--no-motd`
++
++    This option affects the information that is output by the client at the
++    start of a daemon transfer.  This suppresses the message-of-the-day (MOTD)
++    text, but it also affects the list of modules that the daemon sends in
++    response to the "rsync host::" request (due to a limitation in the rsync
++    protocol), so omit this option if you want to request the list of modules
++    from the daemon.
++
++0.  `--ignore-times`, `-I`
++
++    Normally rsync will skip any files that are already the same size and have
++    the same modification timestamp.  This option turns off this "quick check"
++    behavior, causing all files to be updated.
++
++    This option can be confusing compared to [`--ignore-existing`](#opt) and
++    [`--ignore-non-existing`](#opt) in that that they cause rsync to transfer
++    fewer files, while this option causes rsync to transfer more files.
++
++0.  `--size-only`
++
++    This modifies rsync's "quick check" algorithm for finding files that need
++    to be transferred, changing it from the default of transferring files with
++    either a changed size or a changed last-modified time to just looking for
++    files that have changed in size.  This is useful when starting to use rsync
++    after using another mirroring system which may not preserve timestamps
++    exactly.
++
++0.  `--modify-window=NUM`, `-@`
++
++    When comparing two timestamps, rsync treats the timestamps as being equal
++    if they differ by no more than the modify-window value.  The default is 0,
++    which matches just integer seconds.  If you specify a negative value (and
++    the receiver is at least version 3.1.3) then nanoseconds will also be taken
++    into account.  Specifying 1 is useful for copies to/from MS Windows FAT
++    filesystems, because FAT represents times with a 2-second resolution
++    (allowing times to differ from the original by up to 1 second).
++
++    If you want all your transfers to default to comparing nanoseconds, you can
++    create a `~/.popt` file and put these lines in it:
++
++    >     rsync alias -a -a@-1
++    >     rsync alias -t -t@-1
++
++    With that as the default, you'd need to specify `--modify-window=0` (aka
++    `-@0`) to override it and ignore nanoseconds, e.g. if you're copying
++    between ext3 and ext4, or if the receiving rsync is older than 3.1.3.
++
++0.  `--checksum`, `-c`
++
++    This changes the way rsync checks if the files have been changed and are in
++    need of a transfer.  Without this option, rsync uses a "quick check" that
++    (by default) checks if each file's size and time of last modification match
++    between the sender and receiver.  This option changes this to compare a
++    128-bit checksum for each file that has a matching size.  Generating the
++    checksums means that both sides will expend a lot of disk I/O reading all
++    the data in the files in the transfer, so this can slow things down
++    significantly (and this is prior to any reading that will be done to
++    transfer changed files)
++
++    The sending side generates its checksums while it is doing the file-system
++    scan that builds the list of the available files.  The receiver generates
++    its checksums when it is scanning for changed files, and will checksum any
++    file that has the same size as the corresponding sender's file: files with
++    either a changed size or a changed checksum are selected for transfer.
++
++    Note that rsync always verifies that each _transferred_ file was correctly
++    reconstructed on the receiving side by checking a whole-file checksum that
++    is generated as the file is transferred, but that automatic
++    after-the-transfer verification has nothing to do with this option's
++    before-the-transfer "Does this file need to be updated?" check.
++
++    The checksum used is auto-negotiated between the client and the server, but
++    can be overridden using either the [`--checksum-choice`](#opt) (`--cc`)
++    option or an environment variable that is discussed in that option's
++    section.
++
++0.  `--archive`, `-a`
++
++    This is equivalent to `-rlptgoD`.  It is a quick way of saying you want
++    recursion and want to preserve almost everything.  Be aware that it does
++    **not** include preserving ACLs (`-A`), xattrs (`-X`), atimes (`-U`),
++    crtimes (`-N`), nor the finding and preserving of hardlinks (`-H`).
++
++    The only exception to the above equivalence is when [`--files-from`](#opt)
++    is specified, in which case [`-r`](#opt) is not implied.
++
++0.  `--no-OPTION`
++
++    You may turn off one or more implied options by prefixing the option name
++    with "no-".  Not all positive options have a negated opposite, but a lot
++    do, including those that can be used to disable an implied option (e.g.
++    `--no-D`, `--no-perms`) or have different defaults in various circumstances
++    (e.g. [`--no-whole-file`](#opt), `--no-blocking-io`, `--no-dirs`).  Every
++    valid negated option accepts both the short and the long option name after
++    the "no-" prefix (e.g. `--no-R` is the same as `--no-relative`).
++
++    As an example, if you want to use [`--archive`](#opt) (`-a`) but don't want
++    [`--owner`](#opt) (`-o`), instead of converting `-a` into `-rlptgD`, you
++    can specify `-a --no-o` (aka `--archive --no-owner`).
++
++    The order of the options is important: if you specify `--no-r -a`, the `-r`
++    option would end up being turned on, the opposite of `-a --no-r`.  Note
++    also that the side-effects of the [`--files-from`](#opt) option are NOT
++    positional, as it affects the default state of several options and slightly
++    changes the meaning of [`-a`](#opt) (see the [`--files-from`](#opt) option
++    for more details).
++
++0.  `--recursive`, `-r`
++
++    This tells rsync to copy directories recursively.  See also
++    [`--dirs`](#opt) (`-d`) for an option that allows the scanning of a single
++    directory.
++
++    See the [`--inc-recursive`](#opt) option for a discussion of the
++    incremental recursion for creating the list of files to transfer.
++
++0. `--inc-recursive`, `--i-r`
++
++    This option explicitly enables on incremental recursion when scanning for
++    files, which is enabled by default when using the [`--recursive`](#opt)
++    option and both sides of the transfer are running rsync 3.0.0 or newer.
++
++    Incremental recursion uses much less memory than non-incremental, while
++    also beginning the transfer more quickly (since it doesn't need to scan the
++    entire transfer hierarchy before it starts transferring files).  If no
++    recursion is enabled in the source files, this option has no effect.
++
++    Some options require rsync to know the full file list, so these options
++    disable the incremental recursion mode.  These include:
++    - [`--delete-before`](#opt) (the old default of [`--delete`](#opt))
++    - [`--delete-after`](#opt)
++    - [`--prune-empty-dirs`](#opt)
++    - [`--delay-updates`](#opt)
++
++    In order to make [`--delete`](#opt) compatible with incremental recursion,
++    rsync 3.0.0 made [`--delete-during`](#opt) the default delete mode (which
++    was first added in 2.6.4).
++
++    One side-effect of incremental recursion is that any missing
++    sub-directories inside a recursively-scanned directory are (by default)
++    created prior to recursing into the sub-dirs.  This earlier creation point
++    (compared to a non-incremental recursion) allows rsync to then set the
++    modify time of the finished directory right away (without having to delay
++    that until a bunch of recursive copying has finished).  However, these
++    early directories don't yet have their completed mode, mtime, or ownership
++    set -- they have more restrictive rights until the subdirectory's copying
++    actually begins.  This early-creation idiom can be avoided by using the
++    [`--omit-dir-times`](#opt) option.
++
++    Incremental recursion can be disabled using the
++    [`--no-inc-recursive`](#opt) (`--no-i-r`) option.
++
++0. `--no-inc-recursive`, `--no-i-r`
++
++    Disables the new incremental recursion algorithm of the
++    [`--recursive`](#opt) option.  This makes rsync scan the full file list
++    before it begins to transfer files.  See [`--inc-recursive`](#opt) for more
++    info.
++
++0.  `--relative`, `-R`
++
++    Use relative paths.  This means that the full path names specified on the
++    command line are sent to the server rather than just the last parts of the
++    filenames.  This is particularly useful when you want to send several
++    different directories at the same time.  For example, if you used this
++    command:
++
++    >     rsync -av /foo/bar/baz.c remote:/tmp/
++
++    would create a file named baz.c in /tmp/ on the remote machine.  If instead
++    you used
++
++    >     rsync -avR /foo/bar/baz.c remote:/tmp/
++
++    then a file named /tmp/foo/bar/baz.c would be created on the remote
++    machine, preserving its full path.  These extra path elements are called
++    "implied directories" (i.e. the "foo" and the "foo/bar" directories in the
++    above example).
++
++    Beginning with rsync 3.0.0, rsync always sends these implied directories as
++    real directories in the file list, even if a path element is really a
++    symlink on the sending side.  This prevents some really unexpected behaviors
++    when copying the full path of a file that you didn't realize had a symlink
++    in its path.  If you want to duplicate a server-side symlink, include both
++    the symlink via its path, and referent directory via its real path.  If
++    you're dealing with an older rsync on the sending side, you may need to use
++    the [`--no-implied-dirs`](#opt) option.
++
++    It is also possible to limit the amount of path information that is sent as
++    implied directories for each path you specify.  With a modern rsync on the
++    sending side (beginning with 2.6.7), you can insert a dot and a slash into
++    the source path, like this:
++
++    >     rsync -avR /foo/./bar/baz.c remote:/tmp/
++
++    That would create /tmp/bar/baz.c on the remote machine. (Note that the dot
++    must be followed by a slash, so "/foo/." would not be abbreviated.) For
++    older rsync versions, you would need to use a chdir to limit the source
++    path.  For example, when pushing files:
++
++    >     (cd /foo; rsync -avR bar/baz.c remote:/tmp/)
++
++    (Note that the parens put the two commands into a sub-shell, so that the
++    "cd" command doesn't remain in effect for future commands.) If you're
++    pulling files from an older rsync, use this idiom (but only for a
++    non-daemon transfer):
++
++    >     rsync -avR --rsync-path="cd /foo; rsync" \
++    >          remote:bar/baz.c /tmp/
++
++0.  `--no-implied-dirs`
++
++    This option affects the default behavior of the [`--relative`](#opt) option.  When
++    it is specified, the attributes of the implied directories from the source
++    names are not included in the transfer.  This means that the corresponding
++    path elements on the destination system are left unchanged if they exist,
++    and any missing implied directories are created with default attributes.
++    This even allows these implied path elements to have big differences, such
++    as being a symlink to a directory on the receiving side.
++
++    For instance, if a command-line arg or a files-from entry told rsync to
++    transfer the file "path/foo/file", the directories "path" and "path/foo"
++    are implied when [`--relative`](#opt) is used.  If "path/foo" is a symlink to "bar"
++    on the destination system, the receiving rsync would ordinarily delete
++    "path/foo", recreate it as a directory, and receive the file into the new
++    directory.  With `--no-implied-dirs`, the receiving rsync updates
++    "path/foo/file" using the existing path elements, which means that the file
++    ends up being created in "path/bar".  Another way to accomplish this link
++    preservation is to use the [`--keep-dirlinks`](#opt) option (which will also affect
++    symlinks to directories in the rest of the transfer).
++
++    When pulling files from an rsync older than 3.0.0, you may need to use this
++    option if the sending side has a symlink in the path you request and you
++    wish the implied directories to be transferred as normal directories.
++
++0.  `--backup`, `-b`
++
++    With this option, preexisting destination files are renamed as each file is
++    transferred or deleted.  You can control where the backup file goes and
++    what (if any) suffix gets appended using the [`--backup-dir`](#opt) and
++    [`--suffix`](#opt) options.
++
++    If you don't specify [`--backup-dir`](#opt):
++
++    1. the [`--omit-dir-times`](#opt) option will be forced on
++    2. the use of [`--delete`](#opt) (without [`--delete-excluded`](#opt)),
++       causes rsync to add a "protect" [filter-rule](#FILTER_RULES) for the
++       backup suffix to the end of all your existing filters that looks like
++       this: `-f "P *~"`.  This rule prevents previously backed-up files from
++       being deleted.
++
++    Note that if you are supplying your own filter rules, you may need to
++    manually insert your own exclude/protect rule somewhere higher up in the
++    list so that it has a high enough priority to be effective (e.g. if your
++    rules specify a trailing inclusion/exclusion of `*`, the auto-added rule
++    would never be reached).
++
++0.  `--backup-dir=DIR`
++
++    This implies the [`--backup`](#opt) option, and tells rsync to store all
++    backups in the specified directory on the receiving side.  This can be used
++    for incremental backups.  You can additionally specify a backup suffix
++    using the [`--suffix`](#opt) option (otherwise the files backed up in the
++    specified directory will keep their original filenames).
++
++    Note that if you specify a relative path, the backup directory will be
++    relative to the destination directory, so you probably want to specify
++    either an absolute path or a path that starts with "../".  If an rsync
++    daemon is the receiver, the backup dir cannot go outside the module's path
++    hierarchy, so take extra care not to delete it or copy into it.
++
++0.  `--suffix=SUFFIX`
++
++    This option allows you to override the default backup suffix used with the
++    [`--backup`](#opt) (`-b`) option.  The default suffix is a `~` if no
++    [`--backup-dir`](#opt) was specified, otherwise it is an empty string.
++
++0.  `--update`, `-u`
++
++    This forces rsync to skip any files which exist on the destination and have
++    a modified time that is newer than the source file. (If an existing
++    destination file has a modification time equal to the source file's, it
++    will be updated if the sizes are different.)
++
++    Note that this does not affect the copying of dirs, symlinks, or other
++    special files.  Also, a difference of file format between the sender and
++    receiver is always considered to be important enough for an update, no
++    matter what date is on the objects.  In other words, if the source has a
++    directory where the destination has a file, the transfer would occur
++    regardless of the timestamps.
++
++    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any
++    exclude side effects.
++
++    A caution for those that choose to combine [`--inplace`](#opt) with
++    `--update`: an interrupted transfer will leave behind a partial file on the
++    receiving side that has a very recent modified time, so re-running the
++    transfer will probably **not** continue the interrupted file.  As such, it
++    is usually best to avoid combining this with[ `--inplace`](#opt) unless you
++    have implemented manual steps to handle any interrupted in-progress files.
++
++0.  `--inplace`
++
++    This option changes how rsync transfers a file when its data needs to be
++    updated: instead of the default method of creating a new copy of the file
++    and moving it into place when it is complete, rsync instead writes the
++    updated data directly to the destination file.
++
++    This has several effects:
++
++    - Hard links are not broken.  This means the new data will be visible
++      through other hard links to the destination file.  Moreover, attempts to
++      copy differing source files onto a multiply-linked destination file will
++      result in a "tug of war" with the destination data changing back and
++      forth.
++    - In-use binaries cannot be updated (either the OS will prevent this from
++      happening, or binaries that attempt to swap-in their data will misbehave
++      or crash).
++    - The file's data will be in an inconsistent state during the transfer and
++      will be left that way if the transfer is interrupted or if an update
++      fails.
++    - A file that rsync cannot write to cannot be updated.  While a super user
++      can update any file, a normal user needs to be granted write permission
++      for the open of the file for writing to be successful.
++    - The efficiency of rsync's delta-transfer algorithm may be reduced if some
++      data in the destination file is overwritten before it can be copied to a
++      position later in the file.  This does not apply if you use [`--backup`](#opt),
++      since rsync is smart enough to use the backup file as the basis file for
++      the transfer.
++
++    WARNING: you should not use this option to update files that are being
++    accessed by others, so be careful when choosing to use this for a copy.
++
++    This option is useful for transferring large files with block-based changes
++    or appended data, and also on systems that are disk bound, not network
++    bound.  It can also help keep a copy-on-write filesystem snapshot from
++    diverging the entire contents of a file that only has minor changes.
++
++    The option implies [`--partial`](#opt) (since an interrupted transfer does
++    not delete the file), but conflicts with [`--partial-dir`](#opt) and
++    [`--delay-updates`](#opt).  Prior to rsync 2.6.4 `--inplace` was also
++    incompatible with [`--compare-dest`](#opt) and [`--link-dest`](#opt).
++
++0.  `--append`
++
++    This special copy mode only works to efficiently update files that are
++    known to be growing larger where any existing content on the receiving side
++    is also known to be the same as the content on the sender.  The use of
++    `--append` **can be dangerous** if you aren't 100% sure that all the files
++    in the transfer are shared, growing files.  You should thus use filter
++    rules to ensure that you weed out any files that do not fit this criteria.
++
++    Rsync updates these growing file in-place without verifying any of the
++    existing content in the file (it only verifies the content that it is
++    appending).  Rsync skips any files that exist on the receiving side that
++    are not shorter than the associated file on the sending side (which means
++    that new files are transferred).  It also skips any files whose size on the
++    sending side gets shorter during the send negotiations (rsync warns about a
++    "diminished" file when this happens).
++
++    This does not interfere with the updating of a file's non-content
++    attributes (e.g.  permissions, ownership, etc.) when the file does not need
++    to be transferred, nor does it affect the updating of any directories or
++    non-regular files.
++
++0.  `--append-verify`
++
++    This special copy mode works like [`--append`](#opt) except that all the
++    data in the file is included in the checksum verification (making it less
++    efficient but also potentially safer).  This option **can be dangerous** if
++    you aren't 100% sure that all the files in the transfer are shared, growing
++    files.  See the [`--append`](#opt) option for more details.
++
++    Note: prior to rsync 3.0.0, the [`--append`](#opt) option worked like
++    `--append-verify`, so if you are interacting with an older rsync (or the
++    transfer is using a protocol prior to 30), specifying either append option
++    will initiate an `--append-verify` transfer.
++
++0.  `--dirs`, `-d`
++
++    Tell the sending side to include any directories that are encountered.
++    Unlike [`--recursive`](#opt), a directory's contents are not copied unless
++    the directory name specified is "." or ends with a trailing slash (e.g.
++    ".", "dir/.", "dir/", etc.).  Without this option or the
++    [`--recursive`](#opt) option, rsync will skip all directories it encounters
++    (and output a message to that effect for each one).  If you specify both
++    `--dirs` and [`--recursive`](#opt), `--recursive` takes precedence.
++
++    The `--dirs` option is implied by the [`--files-from`](#opt) option or the
++    [`--list-only`](#opt) option (including an implied [`--list-only`](#opt)
++    usage) if [`--recursive`](#opt) wasn't specified (so that directories are
++    seen in the listing).  Specify `--no-dirs` (or `--no-d`) if you want to
++    turn this off.
++
++    There is also a backward-compatibility helper option, `--old-dirs`
++    (`--old-d`) that tells rsync to use a hack of `-r --exclude='/*/*'` to get
++    an older rsync to list a single directory without recursing.
++
++0.  `--mkpath`
++
++    Create all missing path components of the destination path.
++
++    By default, rsync allows only the final component of the destination path
++    to not exist, which is an attempt to help you to validate your destination
++    path.  With this option, rsync creates all the missing destination-path
++    components, just as if `mkdir -p $DEST_PATH` had been run on the receiving
++    side.
++
++    When specifying a destination path, including a trailing slash ensures that
++    the whole path is treated as directory names to be created, even when the
++    file list has a single item. See the [COPYING TO A DIFFERENT NAME](#)
++    section for full details on how rsync decides if a final destination-path
++    component should be created as a directory or not.
++
++    If you would like the newly-created destination dirs to match the dirs on
++    the sending side, you should be using [`--relative`](#opt) (`-R`) instead
++    of `--mkpath`.  For instance, the following two commands result in the same
++    destination tree, but only the second command ensures that the
++    "some/extra/path" components match the dirs on the sending side:
++
++    >     rsync -ai --mkpath host:some/extra/path/*.c some/extra/path/
++    >     rsync -aiR host:some/extra/path/*.c ./
++
++0.  `--links`, `-l`
++
++    Add symlinks to the transferred files instead of noisily ignoring them with
++    a "non-regular file" warning for each symlink encountered.  You can
++    alternately silence the warning by specifying [`--info=nonreg0`](#opt).
++
++    The default handling of symlinks is to recreate each symlink's unchanged
++    value on the receiving side.
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--copy-links`, `-L`
++
++    The sender transforms each symlink encountered in the transfer into the
++    referent item, following the symlink chain to the file or directory that it
++    references.  If a symlink chain is broken, an error is output and the file
++    is dropped from the transfer.
++
++    This option supersedes any other options that affect symlinks in the
++    transfer, since there are no symlinks left in the transfer.
++
++    This option does not change the handling of existing symlinks on the
++    receiving side, unlike versions of rsync prior to 2.6.3 which had the
++    side-effect of telling the receiving side to also follow symlinks.  A
++    modern rsync won't forward this option to a remote receiver (since only the
++    sender needs to know about it), so this caveat should only affect someone
++    using an rsync client older than 2.6.7 (which is when `-L` stopped being
++    forwarded to the receiver).
++
++    See the [`--keep-dirlinks`](#opt) (`-K`) if you need a symlink to a
++    directory to be treated as a real directory on the receiving side.
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--copy-unsafe-links`
++
++    This tells rsync to copy the referent of symbolic links that point outside
++    the copied tree.  Absolute symlinks are also treated like ordinary files,
++    and so are any symlinks in the source path itself when [`--relative`](#opt)
++    is used.
++
++    Note that the cut-off point is the top of the transfer, which is the part
++    of the path that rsync isn't mentioning in the verbose output.  If you copy
++    "/src/subdir" to "/dest/" then the "subdir" directory is a name inside the
++    transfer tree, not the top of the transfer (which is /src) so it is legal
++    for created relative symlinks to refer to other names inside the /src and
++    /dest directories.  If you instead copy "/src/subdir/" (with a trailing
++    slash) to "/dest/subdir" that would not allow symlinks to any files outside
++    of "subdir".
++
++    Note that safe symlinks are only copied if [`--links`](#opt) was also
++    specified or implied. The `--copy-unsafe-links` option has no extra effect
++    when combined with [`--copy-links`](#opt).
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--safe-links`
++
++    This tells the receiving rsync to ignore any symbolic links in the transfer
++    which point outside the copied tree.  All absolute symlinks are also
++    ignored.
++
++    Since this ignoring is happening on the receiving side, it will still be
++    effective even when the sending side has munged symlinks (when it is using
++    [`--munge-links`](#opt)). It also affects deletions, since the file being
++    present in the transfer prevents any matching file on the receiver from
++    being deleted when the symlink is deemed to be unsafe and is skipped.
++
++    This option must be combined with [`--links`](#opt) (or
++    [`--archive`](#opt)) to have any symlinks in the transfer to conditionally
++    ignore. Its effect is superseded by [`--copy-unsafe-links`](#opt).
++
++    Using this option in conjunction with [`--relative`](#opt) may give
++    unexpected results.
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--munge-links`
++
++    This option affects just one side of the transfer and tells rsync to munge
++    symlink values when it is receiving files or unmunge symlink values when it
++    is sending files.  The munged values make the symlinks unusable on disk but
++    allows the original contents of the symlinks to be recovered.
++
++    The server-side rsync often enables this option without the client's
++    knowledge, such as in an rsync daemon's configuration file or by an option
++    given to the rrsync (restricted rsync) script.  When specified on the
++    client side, specify the option normally if it is the client side that
++    has/needs the munged symlinks, or use `-M--munge-links` to give the option
++    to the server when it has/needs the munged symlinks.  Note that on a local
++    transfer, the client is the sender, so specifying the option directly
++    unmunges symlinks while specifying it as a remote option munges symlinks.
++
++    This option has no effect when sent to a daemon via [`--remote-option`](#opt)
++    because the daemon configures whether it wants munged symlinks via its
++    "`munge symlinks`" parameter.
++
++    The symlink value is munged/unmunged once it is in the transfer, so any
++    option that transforms symlinks into non-symlinks occurs prior to the
++    munging/unmunging **except** for [`--safe-links`](#opt), which is a choice
++    that the receiver makes, so it bases its decision on the munged/unmunged
++    value.  This does mean that if a receiver has munging enabled, that using
++    [`--safe-links`](#opt) will cause all symlinks to be ignored (since they
++    are all absolute).
++
++    The method that rsync uses to munge the symlinks is to prefix each one's
++    value with the string "/rsyncd-munged/".  This prevents the links from
++    being used as long as the directory does not exist.  When this option is
++    enabled, rsync will refuse to run if that path is a directory or a symlink
++    to a directory (though it only checks at startup).  See also the
++    "munge-symlinks" python script in the support directory of the source code
++    for a way to munge/unmunge one or more symlinks in-place.
++
++0.  `--copy-dirlinks`, `-k`
++
++    This option causes the sending side to treat a symlink to a directory as
++    though it were a real directory.  This is useful if you don't want symlinks
++    to non-directories to be affected, as they would be using
++    [`--copy-links`](#opt).
++
++    Without this option, if the sending side has replaced a directory with a
++    symlink to a directory, the receiving side will delete anything that is in
++    the way of the new symlink, including a directory hierarchy (as long as
++    [`--force`](#opt) or [`--delete`](#opt) is in effect).
++
++    See also [`--keep-dirlinks`](#opt) for an analogous option for the
++    receiving side.
++
++    `--copy-dirlinks` applies to all symlinks to directories in the source.  If
++    you want to follow only a few specified symlinks, a trick you can use is to
++    pass them as additional source args with a trailing slash, using
++    [`--relative`](#opt) to make the paths match up right.  For example:
++
++    >     rsync -r --relative src/./ src/./follow-me/ dest/
++
++    This works because rsync calls **lstat**(2) on the source arg as given, and
++    the trailing slash makes **lstat**(2) follow the symlink, giving rise to a
++    directory in the file-list which overrides the symlink found during the
++    scan of "src/./".
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--keep-dirlinks`, `-K`
++
++    This option causes the receiving side to treat a symlink to a directory as
++    though it were a real directory, but only if it matches a real directory
++    from the sender.  Without this option, the receiver's symlink would be
++    deleted and replaced with a real directory.
++
++    For example, suppose you transfer a directory "foo" that contains a file
++    "file", but "foo" is a symlink to directory "bar" on the receiver.  Without
++    `--keep-dirlinks`, the receiver deletes symlink "foo", recreates it as a
++    directory, and receives the file into the new directory.  With
++    `--keep-dirlinks`, the receiver keeps the symlink and "file" ends up in
++    "bar".
++
++    One note of caution: if you use `--keep-dirlinks`, you must trust all the
++    symlinks in the copy or enable the [`--munge-links`](#opt) option on the
++    receiving side!  If it is possible for an untrusted user to create their
++    own symlink to any real directory, the user could then (on a subsequent
++    copy) replace the symlink with a real directory and affect the content of
++    whatever directory the symlink references.  For backup copies, you are
++    better off using something like a bind mount instead of a symlink to modify
++    your receiving hierarchy.
++
++    See also [`--copy-dirlinks`](#opt) for an analogous option for the sending
++    side.
++
++    See the [SYMBOLIC LINKS](#) section for multi-option info.
++
++0.  `--hard-links`, `-H`
++
++    This tells rsync to look for hard-linked files in the source and link
++    together the corresponding files on the destination.  Without this option,
++    hard-linked files in the source are treated as though they were separate
++    files.
++
++    This option does NOT necessarily ensure that the pattern of hard links on
++    the destination exactly matches that on the source.  Cases in which the
++    destination may end up with extra hard links include the following:
++
++    - If the destination contains extraneous hard-links (more linking than what
++      is present in the source file list), the copying algorithm will not break
++      them explicitly.  However, if one or more of the paths have content
++      differences, the normal file-update process will break those extra links
++      (unless you are using the [`--inplace`](#opt) option).
++    - If you specify a [`--link-dest`](#opt) directory that contains hard
++      links, the linking of the destination files against the
++      [`--link-dest`](#opt) files can cause some paths in the destination to
++      become linked together due to the [`--link-dest`](#opt) associations.
++
++    Note that rsync can only detect hard links between files that are inside
++    the transfer set.  If rsync updates a file that has extra hard-link
++    connections to files outside the transfer, that linkage will be broken.  If
++    you are tempted to use the [`--inplace`](#opt) option to avoid this breakage, be
++    very careful that you know how your files are being updated so that you are
++    certain that no unintended changes happen due to lingering hard links (and
++    see the [`--inplace`](#opt) option for more caveats).
++
++    If incremental recursion is active (see [`--inc-recursive`](#opt)), rsync
++    may transfer a missing hard-linked file before it finds that another link
++    for that contents exists elsewhere in the hierarchy.  This does not affect
++    the accuracy of the transfer (i.e. which files are hard-linked together),
++    just its efficiency (i.e. copying the data for a new, early copy of a
++    hard-linked file that could have been found later in the transfer in
++    another member of the hard-linked set of files).  One way to avoid this
++    inefficiency is to disable incremental recursion using the
++    [`--no-inc-recursive`](#opt) option.
++
++0.  `--perms`, `-p`
++
++    This option causes the receiving rsync to set the destination permissions
++    to be the same as the source permissions. (See also the [`--chmod`](#opt)
++    option for a way to modify what rsync considers to be the source
++    permissions.)
++
++    When this option is _off_, permissions are set as follows:
++
++    - Existing files (including updated files) retain their existing
++      permissions, though the [`--executability`](#opt) option might change
++      just the execute permission for the file.
++    - New files get their "normal" permission bits set to the source file's
++      permissions masked with the receiving directory's default permissions
++      (either the receiving process's umask, or the permissions specified via
++      the destination directory's default ACL), and their special permission
++      bits disabled except in the case where a new directory inherits a setgid
++      bit from its parent directory.
++
++    Thus, when `--perms` and [`--executability`](#opt) are both disabled, rsync's
++    behavior is the same as that of other file-copy utilities, such as **cp**(1)
++    and **tar**(1).
++
++    In summary: to give destination files (both old and new) the source
++    permissions, use `--perms`.  To give new files the destination-default
++    permissions (while leaving existing files unchanged), make sure that the
++    `--perms` option is off and use [`--chmod=ugo=rwX`](#opt) (which ensures
++    that all non-masked bits get enabled).  If you'd care to make this latter
++    behavior easier to type, you could define a popt alias for it, such as
++    putting this line in the file `~/.popt` (the following defines the `-Z`
++    option, and includes `--no-g` to use the default group of the destination
++    dir):
++
++    >      rsync alias -Z --no-p --no-g --chmod=ugo=rwX
++
++    You could then use this new option in a command such as this one:
++
++    >      rsync -avZ src/ dest/
++
++    (Caveat: make sure that `-a` does not follow `-Z`, or it will re-enable the
++    two `--no-*` options mentioned above.)
++
++    The preservation of the destination's setgid bit on newly-created
++    directories when `--perms` is off was added in rsync 2.6.7.  Older rsync
++    versions erroneously preserved the three special permission bits for
++    newly-created files when `--perms` was off, while overriding the
++    destination's setgid bit setting on a newly-created directory.  Default ACL
++    observance was added to the ACL patch for rsync 2.6.7, so older (or
++    non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
++    (Keep in mind that it is the version of the receiving rsync that affects
++    these behaviors.)
++
++0.  `--executability`, `-E`
++
++    This option causes rsync to preserve the executability (or
++    non-executability) of regular files when [`--perms`](#opt) is not enabled.
++    A regular file is considered to be executable if at least one 'x' is turned
++    on in its permissions.  When an existing destination file's executability
++    differs from that of the corresponding source file, rsync modifies the
++    destination file's permissions as follows:
++
++    - To make a file non-executable, rsync turns off all its 'x' permissions.
++    - To make a file executable, rsync turns on each 'x' permission that has a
++      corresponding 'r' permission enabled.
++
++    If [`--perms`](#opt) is enabled, this option is ignored.
++
++0.  `--acls`, `-A`
++
++    This option causes rsync to update the destination ACLs to be the same as
++    the source ACLs.  The option also implies [`--perms`](#opt).
++
++    The source and destination systems must have compatible ACL entries for
++    this option to work properly.  See the [`--fake-super`](#opt) option for a
++    way to backup and restore ACLs that are not compatible.
++
++0.  `--xattrs`, `-X`
++
++    This option causes rsync to update the destination extended attributes to
++    be the same as the source ones.
++
++    For systems that support extended-attribute namespaces, a copy being done
++    by a super-user copies all namespaces except system.\*.  A normal user only
++    copies the user.\* namespace.  To be able to backup and restore non-user
++    namespaces as a normal user, see the [`--fake-super`](#opt) option.
++
++    The above name filtering can be overridden by using one or more filter
++    options with the **x** modifier.  When you specify an xattr-affecting
++    filter rule, rsync requires that you do your own system/user filtering, as
++    well as any additional filtering for what xattr names are copied and what
++    names are allowed to be deleted.  For example, to skip the system
++    namespace, you could specify:
++
++    >     --filter='-x system.*'
++
++    To skip all namespaces except the user namespace, you could specify a
++    negated-user match:
++
++    >     --filter='-x! user.*'
++
++    To prevent any attributes from being deleted, you could specify a
++    receiver-only rule that excludes all names:
++
++    >     --filter='-xr *'
++
++    Note that the `-X` option does not copy rsync's special xattr values (e.g.
++    those used by [`--fake-super`](#opt)) unless you repeat the option (e.g. `-XX`).
++    This "copy all xattrs" mode cannot be used with [`--fake-super`](#opt).
++
++0.  `--chmod=CHMOD`
++
++    This option tells rsync to apply one or more comma-separated "chmod" modes
++    to the permission of the files in the transfer.  The resulting value is
++    treated as though it were the permissions that the sending side supplied
++    for the file, which means that this option can seem to have no effect on
++    existing files if [`--perms`](#opt) is not enabled.
++
++    In addition to the normal parsing rules specified in the **chmod**(1)
++    manpage, you can specify an item that should only apply to a directory by
++    prefixing it with a 'D', or specify an item that should only apply to a
++    file by prefixing it with a 'F'.  For example, the following will ensure
++    that all directories get marked set-gid, that no files are other-writable,
++    that both are user-writable and group-writable, and that both have
++    consistent executability across all bits:
++
++    >     --chmod=Dg+s,ug+w,Fo-w,+X
++
++    Using octal mode numbers is also allowed:
++
++    >     --chmod=D2775,F664
++
++    It is also legal to specify multiple `--chmod` options, as each additional
++    option is just appended to the list of changes to make.
++
++    See the [`--perms`](#opt) and [`--executability`](#opt) options for how the
++    resulting permission value can be applied to the files in the transfer.
++
++0.  `--owner`, `-o`
++
++    This option causes rsync to set the owner of the destination file to be the
++    same as the source file, but only if the receiving rsync is being run as
++    the super-user (see also the [`--super`](#opt) and [`--fake-super`](#opt)
++    options).  Without this option, the owner of new and/or transferred files
++    are set to the invoking user on the receiving side.
++
++    The preservation of ownership will associate matching names by default, but
++    may fall back to using the ID number in some circumstances (see also the
++    [`--numeric-ids`](#opt) option for a full discussion).
++
++0.  `--group`, `-g`
++
++    This option causes rsync to set the group of the destination file to be the
++    same as the source file.  If the receiving program is not running as the
++    super-user (or if `--no-super` was specified), only groups that the
++    invoking user on the receiving side is a member of will be preserved.
++    Without this option, the group is set to the default group of the invoking
++    user on the receiving side.
++
++    The preservation of group information will associate matching names by
++    default, but may fall back to using the ID number in some circumstances
++    (see also the [`--numeric-ids`](#opt) option for a full discussion).
++
++0.  `--devices`
++
++    This option causes rsync to transfer character and block device files to
++    the remote system to recreate these devices.  If the receiving rsync is not
++    being run as the super-user, rsync silently skips creating the device files
++    (see also the [`--super`](#opt) and [`--fake-super`](#opt) options).
++
++    By default, rsync generates a "non-regular file" warning for each device
++    file encountered when this option is not set.  You can silence the warning
++    by specifying [`--info=nonreg0`](#opt).
++
++0.  `--specials`
++
++    This option causes rsync to transfer special files, such as named sockets
++    and fifos.  If the receiving rsync is not being run as the super-user,
++    rsync silently skips creating the special files (see also the
++    [`--super`](#opt) and [`--fake-super`](#opt) options).
++
++    By default, rsync generates a "non-regular file" warning for each special
++    file encountered when this option is not set.  You can silence the warning
++    by specifying [`--info=nonreg0`](#opt).
++
++0.  `-D`
++
++    The `-D` option is equivalent to "[`--devices`](#opt)
++    [`--specials`](#opt)".
++
++0.  `--copy-devices`
++
++    This tells rsync to treat a device on the sending side as a regular file,
++    allowing it to be copied to a normal destination file (or another device
++    if `--write-devices` was also specified).
++
++    This option is refused by default by an rsync daemon.
++
++0.  `--write-devices`
++
++    This tells rsync to treat a device on the receiving side as a regular file,
++    allowing the writing of file data into a device.
++
++    This option implies the [`--inplace`](#opt) option.
++
++    Be careful using this, as you should know what devices are present on the
++    receiving side of the transfer, especially when running rsync as root.
++
++    This option is refused by default by an rsync daemon.
++
++0.  `--times`, `-t`
++
++    This tells rsync to transfer modification times along with the files and
++    update them on the remote system.  Note that if this option is not used,
++    the optimization that excludes files that have not been modified cannot be
++    effective; in other words, a missing `-t` (or [`-a`](#opt)) will cause the
++    next transfer to behave as if it used [`--ignore-times`](#opt) (`-I`),
++    causing all files to be updated (though rsync's delta-transfer algorithm
++    will make the update fairly efficient if the files haven't actually
++    changed, you're much better off using `-t`).
++
++    A modern rsync that is using transfer protocol 30 or 31 conveys a modify
++    time using up to 8-bytes. If rsync is forced to speak an older protocol
++    (perhaps due to the remote rsync being older than 3.0.0) a modify time is
++    conveyed using 4-bytes. Prior to 3.2.7, these shorter values could convey
++    a date range of 13-Dec-1901 to 19-Jan-2038.  Beginning with 3.2.7, these
++    4-byte values now convey a date range of 1-Jan-1970 to 7-Feb-2106.  If you
++    have files dated older than 1970, make sure your rsync executables are
++    upgraded so that the full range of dates can be conveyed.
++
++0.  `--atimes`, `-U`
++
++    This tells rsync to set the access (use) times of the destination files to
++    the same value as the source files.
++
++    If repeated, it also sets the [`--open-noatime`](#opt) option, which can help you
++    to make the sending and receiving systems have the same access times on the
++    transferred files without needing to run rsync an extra time after a file
++    is transferred.
++
++    Note that some older rsync versions (prior to 3.2.0) may have been built
++    with a pre-release `--atimes` patch that does not imply
++    [`--open-noatime`](#opt) when this option is repeated.
++
++0.  `--open-noatime`
++
++    This tells rsync to open files with the O_NOATIME flag (on systems that
++    support it) to avoid changing the access time of the files that are being
++    transferred.  If your OS does not support the O_NOATIME flag then rsync
++    will silently ignore this option.  Note also that some filesystems are
++    mounted to avoid updating the atime on read access even without the
++    O_NOATIME flag being set.
++
++0.  `--crtimes`, `-N,`
++
++    This tells rsync to set the create times (newness) of the destination
++    files to the same value as the source files. Your OS & filesystem must
++    support the setting of arbitrary creation (birth) times for this option
++    to be supported.
++
++0.  `--omit-dir-times`, `-O`
++
++    This tells rsync to omit directories when it is preserving modification,
++    access, and create times.  If NFS is sharing the directories on the receiving
++    side, it is a good idea to use `-O`.  This option is inferred if you use
++    [`--backup`](#opt) without [`--backup-dir`](#opt).
++
++    This option also has the side-effect of avoiding early creation of missing
++    sub-directories when incremental recursion is enabled, as discussed in the
++    [`--inc-recursive`](#opt) section.
++
++0.  `--omit-link-times`, `-J`
++
++    This tells rsync to omit symlinks when it is preserving modification,
++    access, and create times.
++
++0.  `--super`
++
++    This tells the receiving side to attempt super-user activities even if the
++    receiving rsync wasn't run by the super-user.  These activities include:
++    preserving users via the [`--owner`](#opt) option, preserving all groups
++    (not just the current user's groups) via the [`--group`](#opt) option, and
++    copying devices via the [`--devices`](#opt) option.  This is useful for
++    systems that allow such activities without being the super-user, and also
++    for ensuring that you will get errors if the receiving side isn't being run
++    as the super-user.  To turn off super-user activities, the super-user can
++    use `--no-super`.
++
++0.  `--fake-super`
++
++    When this option is enabled, rsync simulates super-user activities by
++    saving/restoring the privileged attributes via special extended attributes
++    that are attached to each file (as needed).  This includes the file's owner
++    and group (if it is not the default), the file's device info (device &
++    special files are created as empty text files), and any permission bits
++    that we won't allow to be set on the real file (e.g. the real file gets
++    u-s,g-s,o-t for safety) or that would limit the owner's access (since the
++    real super-user can always access/change a file, the files we create can
++    always be accessed/changed by the creating user).  This option also handles
++    ACLs (if [`--acls`](#opt) was specified) and non-user extended attributes
++    (if [`--xattrs`](#opt) was specified).
++
++    This is a good way to backup data without using a super-user, and to store
++    ACLs from incompatible systems.
++
++    The `--fake-super` option only affects the side where the option is used.
++    To affect the remote side of a remote-shell connection, use the
++    [`--remote-option`](#opt) (`-M`) option:
++
++    >     rsync -av -M--fake-super /src/ host:/dest/
++
++    For a local copy, this option affects both the source and the destination.
++    If you wish a local copy to enable this option just for the destination
++    files, specify `-M--fake-super`.  If you wish a local copy to enable this
++    option just for the source files, combine `--fake-super` with `-M--super`.
++
++    This option is overridden by both [`--super`](#opt) and `--no-super`.
++
++    See also the [`fake super`](rsyncd.conf.5#fake_super) setting in the
++    daemon's rsyncd.conf file.
++
++0.  `--sparse`, `-S`
++
++    Try to handle sparse files efficiently so they take up less space on the
++    destination.  If combined with [`--inplace`](#opt) the file created might
++    not end up with sparse blocks with some combinations of kernel version
++    and/or filesystem type.  If [`--whole-file`](#opt) is in effect (e.g. for a
++    local copy) then it will always work because rsync truncates the file prior
++    to writing out the updated version.
++
++    Note that versions of rsync older than 3.1.3 will reject the combination of
++    `--sparse` and [`--inplace`](#opt).
++
++0.  `--preallocate`
++
++    This tells the receiver to allocate each destination file to its eventual
++    size before writing data to the file.  Rsync will only use the real
++    filesystem-level preallocation support provided by Linux's **fallocate**(2)
++    system call or Cygwin's **posix_fallocate**(3), not the slow glibc
++    implementation that writes a null byte into each block.
++
++    Without this option, larger files may not be entirely contiguous on the
++    filesystem, but with this option rsync will probably copy more slowly.  If
++    the destination is not an extent-supporting filesystem (such as ext4, xfs,
++    NTFS, etc.), this option may have no positive effect at all.
++
++    If combined with [`--sparse`](#opt), the file will only have sparse blocks
++    (as opposed to allocated sequences of null bytes) if the kernel version and
++    filesystem type support creating holes in the allocated data.
++
++0.  `--dry-run`, `-n`
++
++    This makes rsync perform a trial run that doesn't make any changes (and
++    produces mostly the same output as a real run).  It is most commonly used
++    in combination with the [`--verbose`](#opt) (`-v`) and/or
++    [`--itemize-changes`](#opt) (`-i`) options to see what an rsync command is
++    going to do before one actually runs it.
++
++    The output of [`--itemize-changes`](#opt) is supposed to be exactly the
++    same on a dry run and a subsequent real run (barring intentional trickery
++    and system call failures); if it isn't, that's a bug.  Other output should
++    be mostly unchanged, but may differ in some areas.  Notably, a dry run does
++    not send the actual data for file transfers, so [`--progress`](#opt) has no
++    effect, the "bytes sent", "bytes received", "literal data", and "matched
++    data" statistics are too small, and the "speedup" value is equivalent to a
++    run where no file transfers were needed.
++
++0.  `--whole-file`, `-W`
++
++    This option disables rsync's delta-transfer algorithm, which causes all
++    transferred files to be sent whole.  The transfer may be faster if this
++    option is used when the bandwidth between the source and destination
++    machines is higher than the bandwidth to disk (especially when the "disk"
++    is actually a networked filesystem).  This is the default when both the
++    source and destination are specified as local paths, but only if no
++    batch-writing option is in effect.
++
++0. `--no-whole-file`, `--no-W`
++
++    Disable whole-file updating when it is enabled by default for a local
++    transfer.  This usually slows rsync down, but it can be useful if you are
++    trying to minimize the writes to the destination file (if combined with
++    [`--inplace`](#opt)) or for testing the checksum-based update algorithm.
++
++    See also the [`--whole-file`](#opt) option.
++
++0.  `--checksum-choice=STR`, `--cc=STR`
++
++    This option overrides the checksum algorithms.  If one algorithm name is
++    specified, it is used for both the transfer checksums and (assuming
++    [`--checksum`](#opt) is specified) the pre-transfer checksums.  If two
++    comma-separated names are supplied, the first name affects the transfer
++    checksums, and the second name affects the pre-transfer checksums (`-c`).
++
++    The checksum options that you may be able to use are:
++
++    - `auto` (the default automatic choice)
++    - `xxh128`
++    - `xxh3`
++    - `xxh64` (aka `xxhash`)
++    - `md5`
++    - `md4`
++    - `sha1`
++    - `none`
++
++    Run `rsync --version` to see the default checksum list compiled into your
++    version (which may differ from the list above).
++
++    If "none" is specified for the first (or only) name, the [`--whole-file`](#opt)
++    option is forced on and no checksum verification is performed on the
++    transferred data.  If "none" is specified for the second (or only) name,
++    the [`--checksum`](#opt) option cannot be used.
++
++    The "auto" option is the default, where rsync bases its algorithm choice on
++    a negotiation between the client and the server as follows:
++
++    When both sides of the transfer are at least 3.2.0, rsync chooses the first
++    algorithm in the client's list of choices that is also in the server's list
++    of choices.  If no common checksum choice is found, rsync exits with
++    an error.  If the remote rsync is too old to support checksum negotiation,
++    a value is chosen based on the protocol version (which chooses between MD5
++    and various flavors of MD4 based on protocol age).
++
++    The default order can be customized by setting the environment variable
++    [`RSYNC_CHECKSUM_LIST`](#) to a space-separated list of acceptable checksum
++    names.  If the string contains a "`&`" character, it is separated into the
++    "client string & server string", otherwise the same string applies to both.
++    If the string (or string portion) contains no non-whitespace characters,
++    the default checksum list is used.  This method does not allow you to
++    specify the transfer checksum separately from the pre-transfer checksum,
++    and it discards "auto" and all unknown checksum names.  A list with only
++    invalid names results in a failed negotiation.
++
++    The use of the `--checksum-choice` option overrides this environment list.
++
++0.  `--one-file-system`, `-x`
++
++    This tells rsync to avoid crossing a filesystem boundary when recursing.
++    This does not limit the user's ability to specify items to copy from
++    multiple filesystems, just rsync's recursion through the hierarchy of each
++    directory that the user specified, and also the analogous recursion on the
++    receiving side during deletion.  Also keep in mind that rsync treats a
++    "bind" mount to the same device as being on the same filesystem.
++
++    If this option is repeated, rsync omits all mount-point directories from
++    the copy.  Otherwise, it includes an empty directory at each mount-point it
++    encounters (using the attributes of the mounted directory because those of
++    the underlying mount-point directory are inaccessible).
++
++    If rsync has been told to collapse symlinks (via [`--copy-links`](#opt) or
++    [`--copy-unsafe-links`](#opt)), a symlink to a directory on another device
++    is treated like a mount-point.  Symlinks to non-directories are unaffected
++    by this option.
++
++0.  `--ignore-non-existing`, `--existing`
++
++    This tells rsync to skip creating files (including directories) that do not
++    exist yet on the destination.  If this option is combined with the
++    [`--ignore-existing`](#opt) option, no files will be updated (which can be
++    useful if all you want to do is delete extraneous files).
++
++    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any
++    exclude side effects.
++
++0.  `--ignore-existing`
++
++    This tells rsync to skip updating files that already exist on the
++    destination (this does _not_ ignore existing directories, or nothing would
++    get done).  See also [`--ignore-non-existing`](#opt).
++
++    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any
++    exclude side effects.
++
++    This option can be useful for those doing backups using the
++    [`--link-dest`](#opt) option when they need to continue a backup run that
++    got interrupted.  Since a [`--link-dest`](#opt) run is copied into a new
++    directory hierarchy (when it is used properly), using [`--ignore-existing`
++    will ensure that the already-handled files don't get tweaked (which avoids
++    a change in permissions on the hard-linked files).  This does mean that
++    this option is only looking at the existing files in the destination
++    hierarchy itself.
++
++    When [`--info=skip2`](#opt) is used rsync will output "FILENAME exists
++    (INFO)" messages where the INFO indicates one of "type change", "sum
++    change" (requires [`-c`](#opt)), "file change" (based on the quick check),
++    "attr change", or "uptodate".  Using [`--info=skip1`](#opt) (which is also
++    implied by 2 [`-v`](#opt) options) outputs the exists message without the
++    INFO suffix.
++
++0.  `--remove-source-files`
++
++    This tells rsync to remove from the sending side the files (meaning
++    non-directories) that are a part of the transfer and have been successfully
++    duplicated on the receiving side.
++
++    Note that you should only use this option on source files that are
++    quiescent.  If you are using this to move files that show up in a
++    particular directory over to another host, make sure that the finished
++    files get renamed into the source directory, not directly written into it,
++    so that rsync can't possibly transfer a file that is not yet fully written.
++    If you can't first write the files into a different directory, you should
++    use a naming idiom that lets rsync avoid transferring files that are not
++    yet finished (e.g. name the file "foo.new" when it is written, rename it to
++    "foo" when it is done, and then use the option [`--exclude='*.new'`](#opt)
++    for the rsync transfer).
++
++    Starting with 3.1.0, rsync will skip the sender-side removal (and output an
++    error) if the file's size or modify time has not stayed unchanged.
++
++    Starting with 3.2.6, a local rsync copy will ensure that the sender does
++    not remove a file the receiver just verified, such as when the user
++    accidentally makes the source and destination directory the same path.
++
++0.  `--delete`
++
++    This tells rsync to delete extraneous files from the receiving side (ones
++    that aren't on the sending side), but only for the directories that are
++    being synchronized.  You must have asked rsync to send the whole directory
++    (e.g. "`dir`" or "`dir/`") without using a wildcard for the directory's
++    contents (e.g. "`dir/*`") since the wildcard is expanded by the shell and
++    rsync thus gets a request to transfer individual files, not the files'
++    parent directory.  Files that are excluded from the transfer are also
++    excluded from being deleted unless you use the [`--delete-excluded`](#opt)
++    option or mark the rules as only matching on the sending side (see the
++    include/exclude modifiers in the [FILTER RULES](#) section).
++
++    Prior to rsync 2.6.7, this option would have no effect unless
++    [`--recursive`](#opt) was enabled.  Beginning with 2.6.7, deletions will
++    also occur when [`--dirs`](#opt) (`-d`) is enabled, but only for
++    directories whose contents are being copied.
++
++    This option can be dangerous if used incorrectly! It is a very good idea to
++    first try a run using the [`--dry-run`](#opt) (`-n`) option to see what
++    files are going to be deleted.
++
++    If the sending side detects any I/O errors, then the deletion of any files
++    at the destination will be automatically disabled.  This is to prevent
++    temporary filesystem failures (such as NFS errors) on the sending side from
++    causing a massive deletion of files on the destination.  You can override
++    this with the [`--ignore-errors`](#opt) option.
++
++    The `--delete` option may be combined with one of the --delete-WHEN options
++    without conflict, as well as [`--delete-excluded`](#opt).  However, if none
++    of the `--delete-WHEN` options are specified, rsync will choose the
++    [`--delete-during`](#opt) algorithm when talking to rsync 3.0.0 or newer,
++    or the [`--delete-before`](#opt) algorithm when talking to an older rsync.
++    See also [`--delete-delay`](#opt) and [`--delete-after`](#opt).
++
++0.  `--delete-before`
++
++    Request that the file-deletions on the receiving side be done before the
++    transfer starts.  See [`--delete`](#opt) (which is implied) for more
++    details on file-deletion.
++
++    Deleting before the transfer is helpful if the filesystem is tight for
++    space and removing extraneous files would help to make the transfer
++    possible.  However, it does introduce a delay before the start of the
++    transfer, and this delay might cause the transfer to timeout (if
++    [`--timeout`](#opt) was specified).  It also forces rsync to use the old,
++    non-incremental recursion algorithm that requires rsync to scan all the
++    files in the transfer into memory at once (see [`--recursive`](#opt)).
++
++0.  `--delete-during`, `--del`
++
++    Request that the file-deletions on the receiving side be done incrementally
++    as the transfer happens.  The per-directory delete scan is done right
++    before each directory is checked for updates, so it behaves like a more
++    efficient [`--delete-before`](#opt), including doing the deletions prior to
++    any per-directory filter files being updated.  This option was first added
++    in rsync version 2.6.4.  See [`--delete`](#opt) (which is implied) for more
++    details on file-deletion.
++
++0.  `--delete-delay`
++
++    Request that the file-deletions on the receiving side be computed during
++    the transfer (like [`--delete-during`](#opt)), and then removed after the
++    transfer completes.  This is useful when combined with
++    [`--delay-updates`](#opt) and/or [`--fuzzy`](#opt), and is more efficient
++    than using [`--delete-after`](#opt) (but can behave differently, since
++    [`--delete-after`](#opt) computes the deletions in a separate pass after
++    all updates are done).  If the number of removed files overflows an
++    internal buffer, a temporary file will be created on the receiving side to
++    hold the names (it is removed while open, so you shouldn't see it during
++    the transfer).  If the creation of the temporary file fails, rsync will try
++    to fall back to using [`--delete-after`](#opt) (which it cannot do if
++    [`--recursive`](#opt) is doing an incremental scan).  See
++    [`--delete`](#opt) (which is implied) for more details on file-deletion.
++
++0.  `--delete-after`
++
++    Request that the file-deletions on the receiving side be done after the
++    transfer has completed.  This is useful if you are sending new
++    per-directory merge files as a part of the transfer and you want their
++    exclusions to take effect for the delete phase of the current transfer.  It
++    also forces rsync to use the old, non-incremental recursion algorithm that
++    requires rsync to scan all the files in the transfer into memory at once
++    (see [`--recursive`](#opt)). See [`--delete`](#opt) (which is implied) for
++    more details on file-deletion.
++
++    See also the [`--delete-delay`](#opt) option that might be a faster choice
++    for those that just want the deletions to occur at the end of the transfer.
++
++0.  `--delete-excluded`
++
++    This option turns any unqualified exclude/include rules into server-side
++    rules that do not affect the receiver's deletions.
++
++    By default, an exclude or include has both a server-side effect (to "hide"
++    and "show" files when building the server's file list) and a receiver-side
++    effect (to "protect" and "risk" files when deletions are occurring).  Any
++    rule that has no modifier to specify what sides it is executed on will be
++    instead treated as if it were a server-side rule only, avoiding any
++    "protect" effects of the rules.
++
++    A rule can still apply to both sides even with this option specified if the
++    rule is given both the sender & receiver modifier letters (e.g., `-f'-sr
++    foo'`).  Receiver-side protect/risk rules can also be explicitly specified
++    to limit the deletions.  This saves you from having to edit a bunch of
++    `-f'- foo'` rules into `-f'-s foo'` (aka `-f'H foo'`) rules (not to mention
++    the corresponding includes).
++
++    See the [FILTER RULES](#) section for more information.  See
++    [`--delete`](#opt) (which is implied) for more details on deletion.
++
++0.  `--ignore-missing-args`
++
++    When rsync is first processing the explicitly requested source files (e.g.
++    command-line arguments or [`--files-from`](#opt) entries), it is normally
++    an error if the file cannot be found.  This option suppresses that error,
++    and does not try to transfer the file.  This does not affect subsequent
++    vanished-file errors if a file was initially found to be present and later
++    is no longer there.
++
++0.  `--delete-missing-args`
++
++    This option takes the behavior of the (implied)
++    [`--ignore-missing-args`](#opt) option a step farther: each missing arg
++    will become a deletion request of the corresponding destination file on the
++    receiving side (should it exist).  If the destination file is a non-empty
++    directory, it will only be successfully deleted if [`--force`](#opt) or
++    [`--delete`](#opt) are in effect.  Other than that, this option is
++    independent of any other type of delete processing.
++
++    The missing source files are represented by special file-list entries which
++    display as a "`*missing`" entry in the [`--list-only`](#opt) output.
++
++0.  `--ignore-errors`
++
++    Tells [`--delete`](#opt) to go ahead and delete files even when there are
++    I/O errors.
++
++0.  `--force`
++
++    This option tells rsync to delete a non-empty directory when it is to be
++    replaced by a non-directory.  This is only relevant if deletions are not
++    active (see [`--delete`](#opt) for details).
++
++    Note for older rsync versions: `--force` used to still be required when
++    using [`--delete-after`](#opt), and it used to be non-functional unless the
++    [`--recursive`](#opt) option was also enabled.
++
++0.  `--max-delete=NUM`
++
++    This tells rsync not to delete more than NUM files or directories.  If that
++    limit is exceeded, all further deletions are skipped through the end of the
++    transfer.  At the end, rsync outputs a warning (including a count of the
++    skipped deletions) and exits with an error code of 25 (unless some more
++    important error condition also occurred).
++
++    Beginning with version 3.0.0, you may specify `--max-delete=0` to be warned
++    about any extraneous files in the destination without removing any of them.
++    Older clients interpreted this as "unlimited", so if you don't know what
++    version the client is, you can use the less obvious `--max-delete=-1` as a
++    backward-compatible way to specify that no deletions be allowed (though
++    really old versions didn't warn when the limit was exceeded).
++
++0.  `--max-size=SIZE`
++
++    This tells rsync to avoid transferring any file that is larger than the
++    specified SIZE.  A numeric value can be suffixed with a string to indicate
++    the numeric units or left unqualified to specify bytes.  Feel free to use a
++    fractional value along with the units, such as `--max-size=1.5m`.
++
++    This option is a [TRANSFER RULE](#TRANSFER_RULES), so don't expect any
++    exclude side effects.
++
++    The first letter of a units string can be `B` (bytes), `K` (kilo), `M`
++    (mega), `G` (giga), `T` (tera), or `P` (peta).  If the string is a single
++    char or has "ib" added to it (e.g. "G" or "GiB") then the units are
++    multiples of 1024.  If you use a two-letter suffix that ends with a "B"
++    (e.g. "kb") then you get units that are multiples of 1000.  The string's
++    letters can be any mix of upper and lower-case that you want to use.
++
++    Finally, if the string ends with either "+1" or "-1", it is offset by one
++    byte in the indicated direction.  The largest possible value is usually
++    `8192P-1`.
++
++    Examples: `--max-size=1.5mb-1` is 1499999 bytes, and `--max-size=2g+1` is
++    2147483649 bytes.
++
++    Note that rsync versions prior to 3.1.0 did not allow `--max-size=0`.
++
++0.  `--min-size=SIZE`
++
++    This tells rsync to avoid transferring any file that is smaller than the
++    specified SIZE, which can help in not transferring small, junk files.  See
++    the [`--max-size`](#opt) option for a description of SIZE and other info.
++
++    Note that rsync versions prior to 3.1.0 did not allow `--min-size=0`.
++
++0.  `--max-alloc=SIZE`
++
++    By default rsync limits an individual malloc/realloc to about 1GB in size.
++    For most people this limit works just fine and prevents a protocol error
++    causing rsync to request massive amounts of memory.  However, if you have
++    many millions of files in a transfer, a large amount of server memory, and
++    you don't want to split up your transfer into multiple parts, you can
++    increase the per-allocation limit to something larger and rsync will
++    consume more memory.
++
++    Keep in mind that this is not a limit on the total size of allocated
++    memory.  It is a sanity-check value for each individual allocation.
++
++    See the [`--max-size`](#opt) option for a description of how SIZE can be
++    specified.  The default suffix if none is given is bytes.
++
++    Beginning in 3.2.7, a value of 0 is an easy way to specify SIZE_MAX (the
++    largest limit possible).
++
++    You can set a default value using the environment variable
++    [`RSYNC_MAX_ALLOC`](#) using the same SIZE values as supported by this
++    option.  If the remote rsync doesn't understand the `--max-alloc` option,
++    you can override an environmental value by specifying `--max-alloc=1g`,
++    which will make rsync avoid sending the option to the remote side (because
++    "1G" is the default).
++
++0.  `--block-size=SIZE`, `-B`
++
++    This forces the block size used in rsync's delta-transfer algorithm to a
++    fixed value.  It is normally selected based on the size of each file being
++    updated.  See the technical report for details.
++
++    Beginning in 3.2.3 the SIZE can be specified with a suffix as detailed in
++    the [`--max-size`](#opt) option.  Older versions only accepted a byte count.
++
++0.  `--rsh=COMMAND`, `-e`
++
++    This option allows you to choose an alternative remote shell program to use
++    for communication between the local and remote copies of rsync.  Typically,
++    rsync is configured to use ssh by default, but you may prefer to use rsh on
++    a local network.
++
++    If this option is used with `[user@]host::module/path`, then the remote
++    shell _COMMAND_ will be used to run an rsync daemon on the remote host, and
++    all data will be transmitted through that remote shell connection, rather
++    than through a direct socket connection to a running rsync daemon on the
++    remote host.  See the [USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL
++    CONNECTION](#) section above.
++
++    Beginning with rsync 3.2.0, the [`RSYNC_PORT`](#) environment variable will
++    be set when a daemon connection is being made via a remote-shell
++    connection.  It is set to 0 if the default daemon port is being assumed, or
++    it is set to the value of the rsync port that was specified via either the
++    [`--port`](#opt) option or a non-empty port value in an `rsync://` URL.
++    This allows the script to discern if a non-default port is being requested,
++    allowing for things such as an SSL or stunnel helper script to connect to a
++    default or alternate port.
++
++    Command-line arguments are permitted in COMMAND provided that COMMAND is
++    presented to rsync as a single argument.  You must use spaces (not tabs or
++    other whitespace) to separate the command and args from each other, and you
++    can use single- and/or double-quotes to preserve spaces in an argument (but
++    not backslashes).  Note that doubling a single-quote inside a single-quoted
++    string gives you a single-quote; likewise for double-quotes (though you
++    need to pay attention to which quotes your shell is parsing and which
++    quotes rsync is parsing).  Some examples:
++
++    >     -e 'ssh -p 2234'
++    >     -e 'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"'
++
++    (Note that ssh users can alternately customize site-specific connect
++    options in their .ssh/config file.)
++
++    You can also choose the remote shell program using the [`RSYNC_RSH`](#)
++    environment variable, which accepts the same range of values as `-e`.
++
++    See also the [`--blocking-io`](#opt) option which is affected by this
++    option.
++
++0.  `--rsync-path=PROGRAM`
++
++    Use this to specify what program is to be run on the remote machine to
++    start-up rsync.  Often used when rsync is not in the default remote-shell's
++    path (e.g. `--rsync-path=/usr/local/bin/rsync`).  Note that PROGRAM is run
++    with the help of a shell, so it can be any program, script, or command
++    sequence you'd care to run, so long as it does not corrupt the standard-in
++    & standard-out that rsync is using to communicate.
++
++    One tricky example is to set a different default directory on the remote
++    machine for use with the [`--relative`](#opt) option.  For instance:
++
++    >     rsync -avR --rsync-path="cd /a/b && rsync" host:c/d /e/
++
++0.  `--remote-option=OPTION`, `-M`
++
++    This option is used for more advanced situations where you want certain
++    effects to be limited to one side of the transfer only.  For instance, if
++    you want to pass [`--log-file=FILE`](#opt) and [`--fake-super`](#opt) to
++    the remote system, specify it like this:
++
++    >     rsync -av -M --log-file=foo -M--fake-super src/ dest/
++
++    If you want to have an option affect only the local side of a transfer when
++    it normally affects both sides, send its negation to the remote side.  Like
++    this:
++
++    >     rsync -av -x -M--no-x src/ dest/
++
++    Be cautious using this, as it is possible to toggle an option that will
++    cause rsync to have a different idea about what data to expect next over
++    the socket, and that will make it fail in a cryptic fashion.
++
++    Note that you should use a separate `-M` option for each remote option you
++    want to pass.  On older rsync versions, the presence of any spaces in the
++    remote-option arg could cause it to be split into separate remote args, but
++    this requires the use of [`--old-args`](#opt) in a modern rsync.
++
++    When performing a local transfer, the "local" side is the sender and the
++    "remote" side is the receiver.
++
++    Note some versions of the popt option-parsing library have a bug in them
++    that prevents you from using an adjacent arg with an equal in it next to a
++    short option letter (e.g. `-M--log-file=/tmp/foo`).  If this bug affects
++    your version of popt, you can use the version of popt that is included with
++    rsync.
++
++0.  `--cvs-exclude`, `-C`
++
++    This is a useful shorthand for excluding a broad range of files that you
++    often don't want to transfer between systems.  It uses a similar algorithm
++    to CVS to determine if a file should be ignored.
++
++    The exclude list is initialized to exclude the following items (these
++    initial items are marked as perishable -- see the [FILTER RULES](#)
++    section):
++
++    [comment]: # (This list gets used for the default-cvsignore.h file.)
++
++    > `RCS`
++    > `SCCS`
++    > `CVS`
++    > `CVS.adm`
++    > `RCSLOG`
++    > `cvslog.*`
++    > `tags`
++    > `TAGS`
++    > `.make.state`
++    > `.nse_depinfo`
++    > `*~`
++    > `#*`
++    > `.#*`
++    > `,*`
++    > `_$*`
++    > `*$`
++    > `*.old`
++    > `*.bak`
++    > `*.BAK`
++    > `*.orig`
++    > `*.rej`
++    > `.del-*`
++    > `*.a`
++    > `*.olb`
++    > `*.o`
++    > `*.obj`
++    > `*.so`
++    > `*.exe`
++    > `*.Z`
++    > `*.elc`
++    > `*.ln`
++    > `core`
++    > `.svn/`
++    > `.git/`
++    > `.hg/`
++    > `.bzr/`
++
++    then, files listed in a $HOME/.cvsignore are added to the list and any
++    files listed in the CVSIGNORE environment variable (all cvsignore names are
++    delimited by whitespace).
++
++    Finally, any file is ignored if it is in the same directory as a .cvsignore
++    file and matches one of the patterns listed therein.  Unlike rsync's
++    filter/exclude files, these patterns are split on whitespace.  See the
++    **cvs**(1) manual for more information.
++
++    If you're combining `-C` with your own [`--filter`](#opt) rules, you should
++    note that these CVS excludes are appended at the end of your own rules,
++    regardless of where the `-C` was placed on the command-line.  This makes
++    them a lower priority than any rules you specified explicitly.  If you want
++    to control where these CVS excludes get inserted into your filter rules,
++    you should omit the `-C` as a command-line option and use a combination of
++    [`--filter=:C`](#opt) and [`--filter=-C`](#opt) (either on your
++    command-line or by putting the ":C" and "-C" rules into a filter file with
++    your other rules).  The first option turns on the per-directory scanning
++    for the .cvsignore file.  The second option does a one-time import of the
++    CVS excludes mentioned above.
++
++0.  `--filter=RULE`, `-f`
++
++    This option allows you to add rules to selectively exclude certain files
++    from the list of files to be transferred.  This is most useful in
++    combination with a recursive transfer.
++
++    You may use as many `--filter` options on the command line as you like to
++    build up the list of files to exclude.  If the filter contains whitespace,
++    be sure to quote it so that the shell gives the rule to rsync as a single
++    argument.  The text below also mentions that you can use an underscore to
++    replace the space that separates a rule from its arg.
++
++    See the [FILTER RULES](#) section for detailed information on this option.
++
++0.  `-F`
++
++    The `-F` option is a shorthand for adding two [`--filter`](#opt) rules to
++    your command.  The first time it is used is a shorthand for this rule:
++
++    >     --filter='dir-merge /.rsync-filter'
++
++    This tells rsync to look for per-directory .rsync-filter files that have
++    been sprinkled through the hierarchy and use their rules to filter the
++    files in the transfer.  If `-F` is repeated, it is a shorthand for this
++    rule:
++
++    >     --filter='exclude .rsync-filter'
++
++    This filters out the .rsync-filter files themselves from the transfer.
++
++    See the [FILTER RULES](#) section for detailed information on how these
++    options work.
++
++0.  `--exclude=PATTERN`
++
++    This option is a simplified form of the [`--filter`](#opt) option that
++    specifies an exclude rule and does not allow the full rule-parsing syntax
++    of normal filter rules.  This is equivalent to specifying `-f'- PATTERN'`.
++
++    See the [FILTER RULES](#) section for detailed information on this option.
++
++0.  `--exclude-from=FILE`
++
++    This option is related to the [`--exclude`](#opt) option, but it specifies
++    a FILE that contains exclude patterns (one per line).  Blank lines in the
++    file are ignored, as are whole-line comments that start with '`;`' or '`#`'
++    (filename rules that contain those characters are unaffected).
++
++    If a line begins with "`- `" (dash, space) or "`+ `" (plus, space), then
++    the type of rule is being explicitly specified as an exclude or an include
++    (respectively).  Any rules without such a prefix are taken to be an exclude.
++
++    If a line consists of just "`!`", then the current filter rules are cleared
++    before adding any further rules.
++
++    If _FILE_ is '`-`', the list will be read from standard input.
++
++0.  `--include=PATTERN`
++
++    This option is a simplified form of the [`--filter`](#opt) option that
++    specifies an include rule and does not allow the full rule-parsing syntax
++    of normal filter rules.  This is equivalent to specifying `-f'+ PATTERN'`.
++
++    See the [FILTER RULES](#) section for detailed information on this option.
++
++0.  `--include-from=FILE`
++
++    This option is related to the [`--include`](#opt) option, but it specifies
++    a FILE that contains include patterns (one per line).  Blank lines in the
++    file are ignored, as are whole-line comments that start with '`;`' or '`#`'
++    (filename rules that contain those characters are unaffected).
++
++    If a line begins with "`- `" (dash, space) or "`+ `" (plus, space), then
++    the type of rule is being explicitly specified as an exclude or an include
++    (respectively).  Any rules without such a prefix are taken to be an include.
++
++    If a line consists of just "`!`", then the current filter rules are cleared
++    before adding any further rules.
++
++    If _FILE_ is '`-`', the list will be read from standard input.
++
++0.  `--files-from=FILE`
++
++    Using this option allows you to specify the exact list of files to transfer
++    (as read from the specified FILE or '`-`' for standard input).  It also
++    tweaks the default behavior of rsync to make transferring just the
++    specified files and directories easier:
++
++    - The [`--relative`](#opt) (`-R`) option is implied, which preserves the
++      path information that is specified for each item in the file (use
++      `--no-relative` or `--no-R` if you want to turn that off).
++    - The [`--dirs`](#opt) (`-d`) option is implied, which will create
++      directories specified in the list on the destination rather than noisily
++      skipping them (use `--no-dirs` or `--no-d` if you want to turn that off).
++    - The [`--archive`](#opt) (`-a`) option's behavior does not imply
++      [`--recursive`](#opt) (`-r`), so specify it explicitly, if you want it.
++    - These side-effects change the default state of rsync, so the position of
++      the `--files-from` option on the command-line has no bearing on how other
++      options are parsed (e.g. [`-a`](#opt) works the same before or after
++      `--files-from`, as does `--no-R` and all other options).
++
++    The filenames that are read from the FILE are all relative to the source
++    dir -- any leading slashes are removed and no ".." references are allowed
++    to go higher than the source dir.  For example, take this command:
++
++    >     rsync -a --files-from=/tmp/foo /usr remote:/backup
++
++    If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
++    directory will be created as /backup/bin on the remote host.  If it
++    contains "bin/" (note the trailing slash), the immediate contents of the
++    directory would also be sent (without needing to be explicitly mentioned in
++    the file -- this began in version 2.6.4).  In both cases, if the
++    [`-r`](#opt) option was enabled, that dir's entire hierarchy would also be
++    transferred (keep in mind that [`-r`](#opt) needs to be specified
++    explicitly with `--files-from`, since it is not implied by [`-a`](#opt).
++    Also note that the effect of the (enabled by default) [`-r`](#opt) option
++    is to duplicate only the path info that is read from the file -- it does
++    not force the duplication of the source-spec path (/usr in this case).
++
++    In addition, the `--files-from` file can be read from the remote host
++    instead of the local host if you specify a "host:" in front of the file
++    (the host must match one end of the transfer).  As a short-cut, you can
++    specify just a prefix of ":" to mean "use the remote end of the transfer".
++    For example:
++
++    >     rsync -a --files-from=:/path/file-list src:/ /tmp/copy
++
++    This would copy all the files specified in the /path/file-list file that
++    was located on the remote "src" host.
++
++    If the [`--iconv`](#opt) and [`--secluded-args`](#opt) options are specified
++    and the `--files-from` filenames are being sent from one host to another,
++    the filenames will be translated from the sending host's charset to the
++    receiving host's charset.
++
++    NOTE: sorting the list of files in the `--files-from` input helps rsync to
++    be more efficient, as it will avoid re-visiting the path elements that are
++    shared between adjacent entries.  If the input is not sorted, some path
++    elements (implied directories) may end up being scanned multiple times, and
++    rsync will eventually unduplicate them after they get turned into file-list
++    elements.
++
++0.  `--from0`, `-0`
++
++    This tells rsync that the rules/filenames it reads from a file are
++    terminated by a null ('\\0') character, not a NL, CR, or CR+LF.  This
++    affects [`--exclude-from`](#opt), [`--include-from`](#opt),
++    [`--files-from`](#opt), and any merged files specified in a
++    [`--filter`](#opt) rule.  It does not affect [`--cvs-exclude`](#opt) (since
++    all names read from a .cvsignore file are split on whitespace).
++
++0. `--old-args`
++
++    This option tells rsync to stop trying to protect the arg values on the
++    remote side from unintended word-splitting or other misinterpretation.
++    It also allows the client to treat an empty arg as a "." instead of
++    generating an error.
++
++    The default in a modern rsync is for "shell-active" characters (including
++    spaces) to be backslash-escaped in the args that are sent to the remote
++    shell.  The wildcard characters `*`, `?`, `[`, & `]` are not escaped in
++    filename args (allowing them to expand into multiple filenames) while being
++    protected in option args, such as [`--usermap`](#opt).
++
++    If you have a script that wants to use old-style arg splitting in its
++    filenames, specify this option once.  If the remote shell has a problem
++    with any backslash escapes at all, specify this option twice.
++
++    You may also control this setting via the [`RSYNC_OLD_ARGS`](#) environment
++    variable.  If it has the value "1", rsync will default to a single-option
++    setting.  If it has the value "2" (or more), rsync will default to a
++    repeated-option setting.  If it is "0", you'll get the default escaping
++    behavior.  The environment is always overridden by manually specified
++    positive or negative options (the negative is `--no-old-args`).
++
++    Note that this option also disables the extra safety check added in 3.2.5
++    that ensures that a remote sender isn't including extra top-level items in
++    the file-list that you didn't request.  This side-effect is necessary
++    because we can't know for sure what names to expect when the remote shell
++    is interpreting the args.
++
++    This option conflicts with the [`--secluded-args`](#opt) option.
++
++0.  `--secluded-args`, `-s`
++
++    This option sends all filenames and most options to the remote rsync via
++    the protocol (not the remote shell command line) which avoids letting the
++    remote shell modify them.  Wildcards are expanded on the remote host by
++    rsync instead of a shell.
++
++    This is similar to the default backslash-escaping of args that was added
++    in 3.2.4 (see [`--old-args`](#opt)) in that it prevents things like space
++    splitting and unwanted special-character side-effects. However, it has the
++    drawbacks of being incompatible with older rsync versions (prior to 3.0.0)
++    and of being refused by restricted shells that want to be able to inspect
++    all the option values for safety.
++
++    This option is useful for those times that you need the argument's
++    character set to be converted for the remote host, if the remote shell is
++    incompatible with the default backslash-escpaing method, or there is some
++    other reason that you want the majority of the options and arguments to
++    bypass the command-line of the remote shell.
++
++    If you combine this option with [`--iconv`](#opt), the args related to the
++    remote side will be translated from the local to the remote character-set.
++    The translation happens before wild-cards are expanded.  See also the
++    [`--files-from`](#opt) option.
++
++    You may also control this setting via the [`RSYNC_PROTECT_ARGS`](#)
++    environment variable.  If it has a non-zero value, this setting will be
++    enabled by default, otherwise it will be disabled by default.  Either state
++    is overridden by a manually specified positive or negative version of this
++    option (note that `--no-s` and `--no-secluded-args` are the negative
++    versions).  This environment variable is also superseded by a non-zero
++    [`RSYNC_OLD_ARGS`](#) export.
++
++    This option conflicts with the [`--old-args`](#opt) option.
++
++    This option used to be called `--protect-args` (before 3.2.6) and that
++    older name can still be used (though specifying it as `-s` is always the
++    easiest and most compatible choice).
++
++0.  `--trust-sender`
++
++    This option disables two extra validation checks that a local client
++    performs on the file list generated by a remote sender.  This option should
++    only be used if you trust the sender to not put something malicious in the
++    file list (something that could possibly be done via a modified rsync, a
++    modified shell, or some other similar manipulation).
++
++    Normally, the rsync client (as of version 3.2.5) runs two extra validation
++    checks when pulling files from a remote rsync:
++
++    - It verifies that additional arg items didn't get added at the top of the
++      transfer.
++    - It verifies that none of the items in the file list are names that should
++      have been excluded (if filter rules were specified).
++
++    Note that various options can turn off one or both of these checks if the
++    option interferes with the validation.  For instance:
++
++    - Using a per-directory filter file reads filter rules that only the server
++      knows about, so the filter checking is disabled.
++    - Using the [`--old-args`](#opt) option allows the sender to manipulate the
++      requested args, so the arg checking is disabled.
++    - Reading the files-from list from the server side means that the client
++      doesn't know the arg list, so the arg checking is disabled.
++    - Using [`--read-batch`](#opt) disables both checks since the batch file's
++      contents will have been verified when it was created.
++
++    This option may help an under-powered client server if the extra pattern
++    matching is slowing things down on a huge transfer.  It can also be used to
++    work around a currently-unknown bug in the verification logic for a transfer
++    from a trusted sender.
++
++    When using this option it is a good idea to specify a dedicated destination
++    directory, as discussed in the [MULTI-HOST SECURITY](#) section.
++
++0.  `--copy-as=USER[:GROUP]`
++
++    This option instructs rsync to use the USER and (if specified after a
++    colon) the GROUP for the copy operations.  This only works if the user that
++    is running rsync has the ability to change users.  If the group is not
++    specified then the user's default groups are used.
++
++    This option can help to reduce the risk of an rsync being run as root into
++    or out of a directory that might have live changes happening to it and you
++    want to make sure that root-level read or write actions of system files are
++    not possible.  While you could alternatively run all of rsync as the
++    specified user, sometimes you need the root-level host-access credentials
++    to be used, so this allows rsync to drop root for the copying part of the
++    operation after the remote-shell or daemon connection is established.
++
++    The option only affects one side of the transfer unless the transfer is
++    local, in which case it affects both sides.  Use the
++    [`--remote-option`](#opt) to affect the remote side, such as
++    `-M--copy-as=joe`.  For a local transfer, the lsh (or lsh.sh) support file
++    provides a local-shell helper script that can be used to allow a
++    "localhost:" or "lh:" host-spec to be specified without needing to setup
++    any remote shells, allowing you to specify remote options that affect the
++    side of the transfer that is using the host-spec (and using hostname "lh"
++    avoids the overriding of the remote directory to the user's home dir).
++
++    For example, the following rsync writes the local files as user "joe":
++
++    >     sudo rsync -aiv --copy-as=joe host1:backups/joe/ /home/joe/
++
++    This makes all files owned by user "joe", limits the groups to those that
++    are available to that user, and makes it impossible for the joe user to do
++    a timed exploit of the path to induce a change to a file that the joe user
++    has no permissions to change.
++
++    The following command does a local copy into the "dest/" dir as user "joe"
++    (assuming you've installed support/lsh into a dir on your $PATH):
++
++    >     sudo rsync -aive lsh -M--copy-as=joe src/ lh:dest/
++
++0.  `--temp-dir=DIR`, `-T`
++
++    This option instructs rsync to use DIR as a scratch directory when creating
++    temporary copies of the files transferred on the receiving side.  The
++    default behavior is to create each temporary file in the same directory as
++    the associated destination file.  Beginning with rsync 3.1.1, the temp-file
++    names inside the specified DIR will not be prefixed with an extra dot
++    (though they will still have a random suffix added).
++
++    This option is most often used when the receiving disk partition does not
++    have enough free space to hold a copy of the largest file in the transfer.
++    In this case (i.e. when the scratch directory is on a different disk
++    partition), rsync will not be able to rename each received temporary file
++    over the top of the associated destination file, but instead must copy it
++    into place.  Rsync does this by copying the file over the top of the
++    destination file, which means that the destination file will contain
++    truncated data during this copy.  If this were not done this way (even if
++    the destination file were first removed, the data locally copied to a
++    temporary file in the destination directory, and then renamed into place)
++    it would be possible for the old file to continue taking up disk space (if
++    someone had it open), and thus there might not be enough room to fit the
++    new version on the disk at the same time.
++
++    If you are using this option for reasons other than a shortage of disk
++    space, you may wish to combine it with the [`--delay-updates`](#opt)
++    option, which will ensure that all copied files get put into subdirectories
++    in the destination hierarchy, awaiting the end of the transfer.  If you
++    don't have enough room to duplicate all the arriving files on the
++    destination partition, another way to tell rsync that you aren't overly
++    concerned about disk space is to use the [`--partial-dir`](#opt) option
++    with a relative path; because this tells rsync that it is OK to stash off a
++    copy of a single file in a subdir in the destination hierarchy, rsync will
++    use the partial-dir as a staging area to bring over the copied file, and
++    then rename it into place from there. (Specifying a [`--partial-dir`](#opt)
++    with an absolute path does not have this side-effect.)
++
++0.  `--fuzzy`, `-y`
++
++    This option tells rsync that it should look for a basis file for any
++    destination file that is missing.  The current algorithm looks in the same
++    directory as the destination file for either a file that has an identical
++    size and modified-time, or a similarly-named file.  If found, rsync uses
++    the fuzzy basis file to try to speed up the transfer.
++
++    If the option is repeated, the fuzzy scan will also be done in any matching
++    alternate destination directories that are specified via
++    [`--compare-dest`](#opt), [`--copy-dest`](#opt), or [`--link-dest`](#opt).
++
++    Note that the use of the [`--delete`](#opt) option might get rid of any
++    potential fuzzy-match files, so either use [`--delete-after`](#opt) or
++    specify some filename exclusions if you need to prevent this.
++
++0.  `--detect-renamed`
++
++    With this option, for each new source file (call it `src/S`), rsync looks
++    for a file `dest/D` anywhere in the destination that passes the quick check
++    with `src/S`.  If such a `dest/D` is found, rsync uses it as an alternate
++    basis for transferring `S`.  The idea is that if `src/S` was renamed from
++    `src/D` (as opposed to `src/S` passing the quick check with `dest/D` by
++    coincidence), the delta-transfer algorithm will find that all the data
++    matches between `src/S` and `dest/D`, and the transfer will be really fast.
++
++    By default, alternate-basis files are hard-linked into a directory named
++    ".~tmp~" in each file's destination directory, but if you've specified the
++    [`--partial-dir`](#opt) option, that directory will be used instead.  These
++    otential alternate-basis files will be removed as the transfer progresses.
++    This option conflicts with [`--inplace`](#opt) and [`--append`](#opt).
++
++0.  `--compare-dest=DIR`
++
++    This option instructs rsync to use _DIR_ on the destination machine as an
++    additional hierarchy to compare destination files against doing transfers
++    (if the files are missing in the destination directory).  If a file is
++    found in _DIR_ that is identical to the sender's file, the file will NOT be
++    transferred to the destination directory.  This is useful for creating a
++    sparse backup of just files that have changed from an earlier backup.  This
++    option is typically used to copy into an empty (or newly created)
++    directory.
++
++    Beginning in version 2.6.4, multiple `--compare-dest` directories may be
++    provided, which will cause rsync to search the list in the order specified
++    for an exact match.  If a match is found that differs only in attributes, a
++    local copy is made and the attributes updated.  If a match is not found, a
++    basis file from one of the _DIRs_ will be selected to try to speed up the
++    transfer.
++
++    If _DIR_ is a relative path, it is relative to the destination directory.
++    See also [`--copy-dest`](#opt) and [`--link-dest`](#opt).
++
++    NOTE: beginning with version 3.1.0, rsync will remove a file from a
++    non-empty destination hierarchy if an exact match is found in one of the
++    compare-dest hierarchies (making the end result more closely match a fresh
++    copy).
++
++0.  `--copy-dest=DIR`
++
++    This option behaves like [`--compare-dest`](#opt), but rsync will also copy
++    unchanged files found in _DIR_ to the destination directory using a local
++    copy.  This is useful for doing transfers to a new destination while
++    leaving existing files intact, and then doing a flash-cutover when all
++    files have been successfully transferred.
++
++    Multiple `--copy-dest` directories may be provided, which will cause rsync
++    to search the list in the order specified for an unchanged file.  If a
++    match is not found, a basis file from one of the _DIRs_ will be selected to
++    try to speed up the transfer.
++
++    If _DIR_ is a relative path, it is relative to the destination directory.
++    See also [`--compare-dest`](#opt) and [`--link-dest`](#opt).
++
++0.  `--link-dest=DIR`
++
++    This option behaves like [`--copy-dest`](#opt), but unchanged files are
++    hard linked from _DIR_ to the destination directory.  The files must be
++    identical in all preserved attributes (e.g. permissions, possibly
++    ownership) in order for the files to be linked together.  An example:
++
++    >     rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
++
++    If files aren't linking, double-check their attributes.  Also check if
++    some attributes are getting forced outside of rsync's control, such a mount
++    option that squishes root to a single user, or mounts a removable drive
++    with generic ownership (such as OS X's "Ignore ownership on this volume"
++    option).
++
++    Beginning in version 2.6.4, multiple `--link-dest` directories may be
++    provided, which will cause rsync to search the list in the order specified
++    for an exact match (there is a limit of 20 such directories).  If a match
++    is found that differs only in attributes, a local copy is made and the
++    attributes updated.  If a match is not found, a basis file from one of the
++    _DIRs_ will be selected to try to speed up the transfer.
++
++    This option works best when copying into an empty destination hierarchy, as
++    existing files may get their attributes tweaked, and that can affect
++    alternate destination files via hard-links.  Also, itemizing of changes can
++    get a bit muddled.  Note that prior to version 3.1.0, an
++    alternate-directory exact match would never be found (nor linked into the
++    destination) when a destination file already exists.
++
++    Note that if you combine this option with [`--ignore-times`](#opt), rsync will not
++    link any files together because it only links identical files together as a
++    substitute for transferring the file, never as an additional check after
++    the file is updated.
++
++    If _DIR_ is a relative path, it is relative to the destination directory.
++    See also [`--compare-dest`](#opt) and [`--copy-dest`](#opt).
++
++    Note that rsync versions prior to 2.6.1 had a bug that could prevent
++    `--link-dest` from working properly for a non-super-user when
++    [`--owner`](#opt) (`-o`) was specified (or implied).  You can work-around
++    this bug by avoiding the `-o` option (or using `--no-o`) when sending to an
++    old rsync.
++
++0.  `--clone-dest=DIR`
++
++    This option behaves like [`--link-dest`](#opt), but unchanged files are
++    reflinked from _DIR_ to the destination directory.  The files do not need
++    to match in attributes, as the data is cloned separately from the
++    attributes.
++
++    If _DIR_ is a relative path, it is relative to the destination directory.
++    See also [`--compare-dest`](#opt) and [`--copy-dest`](#opt).
++
++    All non-regular files are hard-linked (when possible).
++
++0.  `--compress`, `-z`
++
++    With this option, rsync compresses the file data as it is sent to the
++    destination machine, which reduces the amount of data being transmitted --
++    something that is useful over a slow connection.
++
++    Rsync supports multiple compression methods and will choose one for you
++    unless you force the choice using the [`--compress-choice`](#opt) (`--zc`)
++    option.
++
++    Run `rsync --version` to see the default compress list compiled into your
++    version.
++
++    When both sides of the transfer are at least 3.2.0, rsync chooses the first
++    algorithm in the client's list of choices that is also in the server's list
++    of choices.  If no common compress choice is found, rsync exits with
++    an error.  If the remote rsync is too old to support checksum negotiation,
++    its list is assumed to be "zlib".
++
++    The default order can be customized by setting the environment variable
++    [`RSYNC_COMPRESS_LIST`](#) to a space-separated list of acceptable
++    compression names.  If the string contains a "`&`" character, it is
++    separated into the "client string & server string", otherwise the same
++    string applies to both.  If the string (or string portion) contains no
++    non-whitespace characters, the default compress list is used.  Any unknown
++    compression names are discarded from the list, but a list with only invalid
++    names results in a failed negotiation.
++
++    There are some older rsync versions that were configured to reject a `-z`
++    option and require the use of `-zz` because their compression library was
++    not compatible with the default zlib compression method.  You can usually
++    ignore this weirdness unless the rsync server complains and tells you to
++    specify `-zz`.
++
++0.  `--compress-choice=STR`, `--zc=STR`
++
++    This option can be used to override the automatic negotiation of the
++    compression algorithm that occurs when [`--compress`](#opt) is used.  The
++    option implies [`--compress`](#opt) unless "none" was specified, which
++    instead implies `--no-compress`.
++
++    The compression options that you may be able to use are:
++
++    - `zstd`
++    - `lz4`
++    - `zlibx`
++    - `zlib`
++    - `none`
++
++    Run `rsync --version` to see the default compress list compiled into your
++    version (which may differ from the list above).
++
++    Note that if you see an error about an option named `--old-compress` or
++    `--new-compress`, this is rsync trying to send the `--compress-choice=zlib`
++    or `--compress-choice=zlibx` option in a backward-compatible manner that
++    more rsync versions understand.  This error indicates that the older rsync
++    version on the server will not allow you to force the compression type.
++
++    Note that the "zlibx" compression algorithm is just the "zlib" algorithm
++    with matched data excluded from the compression stream (to try to make it
++    more compatible with an external zlib implementation).
++
++0.  `--compress-level=NUM`, `--zl=NUM`
++
++    Explicitly set the compression level to use (see [`--compress`](#opt),
++    `-z`) instead of letting it default.  The [`--compress`](#opt) option is
++    implied as long as the level chosen is not a "don't compress" level for the
++    compression algorithm that is in effect (e.g. zlib compression treats level
++    0 as "off").
++
++    The level values vary depending on the checksum in effect.  Because rsync
++    will negotiate a checksum choice by default (when the remote rsync is new
++    enough), it can be good to combine this option with a
++    [`--compress-choice`](#opt) (`--zc`) option unless you're sure of the
++    choice in effect.  For example:
++
++    >     rsync -aiv --zc=zstd --zl=22 host:src/ dest/
++
++    For zlib & zlibx compression the valid values are from 1 to 9 with 6 being
++    the default.  Specifying `--zl=0` turns compression off, and specifying
++    `--zl=-1` chooses the default level of 6.
++
++    For zstd compression the valid values are from -131072 to 22 with 3 being
++    the default. Specifying 0 chooses the default of 3.
++
++    For lz4 compression there are no levels, so the value is always 0.
++
++    If you specify a too-large or too-small value, the number is silently
++    limited to a valid value.  This allows you to specify something like
++    `--zl=999999999` and be assured that you'll end up with the maximum
++    compression level no matter what algorithm was chosen.
++
++    If you want to know the compression level that is in effect, specify
++    [`--debug=nstr`](#opt) to see the "negotiated string" results.  This will
++    report something like "`Client compress: zstd (level 3)`" (along with the
++    checksum choice in effect).
++
++0.  `--skip-compress=LIST`
++
++    **NOTE:** no compression method currently supports per-file compression
++    changes, so this option has no effect.
++
++    Override the list of file suffixes that will be compressed as little as
++    possible.  Rsync sets the compression level on a per-file basis based on
++    the file's suffix.  If the compression algorithm has an "off" level, then
++    no compression occurs for those files.  Other algorithms that support
++    changing the streaming level on-the-fly will have the level minimized to
++    reduces the CPU usage as much as possible for a matching file.
++
++    The **LIST** should be one or more file suffixes (without the dot) separated
++    by slashes (`/`).  You may specify an empty string to indicate that no files
++    should be skipped.
++
++    Simple character-class matching is supported: each must consist of a list
++    of letters inside the square brackets (e.g. no special classes, such as
++    "[:alpha:]", are supported, and '-' has no special meaning).
++
++    The characters asterisk (`*`) and question-mark (`?`) have no special meaning.
++
++    Here's an example that specifies 6 suffixes to skip (since 1 of the 5 rules
++    matches 2 suffixes):
++
++    >     --skip-compress=gz/jpg/mp[34]/7z/bz2
++
++    The default file suffixes in the skip-compress list in this version of
++    rsync are:
++
++    [comment]: # (This list gets used for the default-dont-compress.h file.)
++
++    > 3g2
++    > 3gp
++    > 7z
++    > aac
++    > ace
++    > apk
++    > avi
++    > bz2
++    > deb
++    > dmg
++    > ear
++    > f4v
++    > flac
++    > flv
++    > gpg
++    > gz
++    > iso
++    > jar
++    > jpeg
++    > jpg
++    > lrz
++    > lz
++    > lz4
++    > lzma
++    > lzo
++    > m1a
++    > m1v
++    > m2a
++    > m2ts
++    > m2v
++    > m4a
++    > m4b
++    > m4p
++    > m4r
++    > m4v
++    > mka
++    > mkv
++    > mov
++    > mp1
++    > mp2
++    > mp3
++    > mp4
++    > mpa
++    > mpeg
++    > mpg
++    > mpv
++    > mts
++    > odb
++    > odf
++    > odg
++    > odi
++    > odm
++    > odp
++    > ods
++    > odt
++    > oga
++    > ogg
++    > ogm
++    > ogv
++    > ogx
++    > opus
++    > otg
++    > oth
++    > otp
++    > ots
++    > ott
++    > oxt
++    > png
++    > qt
++    > rar
++    > rpm
++    > rz
++    > rzip
++    > spx
++    > squashfs
++    > sxc
++    > sxd
++    > sxg
++    > sxm
++    > sxw
++    > sz
++    > tbz
++    > tbz2
++    > tgz
++    > tlz
++    > ts
++    > txz
++    > tzo
++    > vob
++    > war
++    > webm
++    > webp
++    > xz
++    > z
++    > zip
++    > zst
++
++    This list will be replaced by your `--skip-compress` list in all but one
++    situation: a copy from a daemon rsync will add your skipped suffixes to its
++    list of non-compressing files (and its list may be configured to a
++    different default).
++
++0.  `--numeric-ids`
++
++    With this option rsync will transfer numeric group and user IDs rather than
++    using user and group names and mapping them at both ends.
++
++    By default rsync will use the username and groupname to determine what
++    ownership to give files.  The special uid 0 and the special group 0 are
++    never mapped via user/group names even if the `--numeric-ids` option is not
++    specified.
++
++    If a user or group has no name on the source system or it has no match on
++    the destination system, then the numeric ID from the source system is used
++    instead.  See also the [`use chroot`](rsyncd.conf.5#use_chroot) setting
++    in the rsyncd.conf manpage for some comments on how the chroot setting
++    affects rsync's ability to look up the names of the users and groups and
++    what you can do about it.
++
++0.  `--usermap=STRING`, `--groupmap=STRING`
++
++    These options allow you to specify users and groups that should be mapped
++    to other values by the receiving side.  The **STRING** is one or more
++    **FROM**:**TO** pairs of values separated by commas.  Any matching **FROM**
++    value from the sender is replaced with a **TO** value from the receiver.
++    You may specify usernames or user IDs for the **FROM** and **TO** values,
++    and the **FROM** value may also be a wild-card string, which will be
++    matched against the sender's names (wild-cards do NOT match against ID
++    numbers, though see below for why a '`*`' matches everything).  You may
++    instead specify a range of ID numbers via an inclusive range: LOW-HIGH.
++    For example:
++
++    >     --usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr
++
++    The first match in the list is the one that is used.  You should specify
++    all your user mappings using a single `--usermap` option, and/or all your
++    group mappings using a single `--groupmap` option.
++
++    Note that the sender's name for the 0 user and group are not transmitted to
++    the receiver, so you should either match these values using a 0, or use the
++    names in effect on the receiving side (typically "root").  All other
++    **FROM** names match those in use on the sending side.  All **TO** names
++    match those in use on the receiving side.
++
++    Any IDs that do not have a name on the sending side are treated as having
++    an empty name for the purpose of matching.  This allows them to be matched
++    via a "`*`" or using an empty name.  For instance:
++
++    >     --usermap=:nobody --groupmap=*:nobody
++
++    When the [`--numeric-ids`](#opt) option is used, the sender does not send any
++    names, so all the IDs are treated as having an empty name.  This means that
++    you will need to specify numeric **FROM** values if you want to map these
++    nameless IDs to different values.
++
++    For the `--usermap` option to work, the receiver will need to be running as
++    a super-user (see also the [`--super`](#opt) and [`--fake-super`](#opt)
++    options).  For the `--groupmap` option to work, the receiver will need to
++    have permissions to set that group.
++
++    Starting with rsync 3.2.4, the `--usermap` option implies the
++    [`--owner`](#opt) (`-o`) option while the `--groupmap` option implies the
++    [`--group`](#opt) (`-g`) option (since rsync needs to have those options
++    enabled for the mapping options to work).
++
++    An older rsync client may need to use [`-s`](#opt) to avoid a complaint
++    about wildcard characters, but a modern rsync handles this automatically.
++
++0.  `--chown=USER:GROUP`
++
++    This option forces all files to be owned by USER with group GROUP.  This is
++    a simpler interface than using [`--usermap`](#opt) & [`--groupmap`](#opt)
++    directly, but it is implemented using those options internally so they
++    cannot be mixed.  If either the USER or GROUP is empty, no mapping for the
++    omitted user/group will occur.  If GROUP is empty, the trailing colon may
++    be omitted, but if USER is empty, a leading colon must be supplied.
++
++    If you specify "`--chown=foo:bar`", this is exactly the same as specifying
++    "`--usermap=*:foo --groupmap=*:bar`", only easier (and with the same
++    implied [`--owner`](#opt) and/or [`--group`](#opt) options).
++
++    An older rsync client may need to use [`-s`](#opt) to avoid a complaint
++    about wildcard characters, but a modern rsync handles this automatically.
++
++0.  `--timeout=SECONDS`
++
++    This option allows you to set a maximum I/O timeout in seconds.  If no data
++    is transferred for the specified time then rsync will exit.  The default is
++    0, which means no timeout.
++
++0.  `--contimeout=SECONDS`
++
++    This option allows you to set the amount of time that rsync will wait for
++    its connection to an rsync daemon to succeed.  If the timeout is reached,
++    rsync exits with an error.
++
++0.  `--address=ADDRESS`
++
++    By default rsync will bind to the wildcard address when connecting to an
++    rsync daemon.  The `--address` option allows you to specify a specific IP
++    address (or hostname) to bind to.
++
++    See also [the daemon version of the `--address` option](#dopt--address).
++
++0.  `--port=PORT`
++
++    This specifies an alternate TCP port number to use rather than the default
++    of 873.  This is only needed if you are using the double-colon (::) syntax
++    to connect with an rsync daemon (since the URL syntax has a way to specify
++    the port as a part of the URL).
++
++    See also [the daemon version of the `--port` option](#dopt--port).
++
++0.  `--sockopts=OPTIONS`
++
++    This option can provide endless fun for people who like to tune their
++    systems to the utmost degree.  You can set all sorts of socket options
++    which may make transfers faster (or slower!).  Read the manpage for the
++    `setsockopt()` system call for details on some of the options you may be
++    able to set.  By default no special socket options are set.  This only
++    affects direct socket connections to a remote rsync daemon.
++
++    See also [the daemon version of the `--sockopts` option](#dopt--sockopts).
++
++0.  `--blocking-io`
++
++    This tells rsync to use blocking I/O when launching a remote shell
++    transport.  If the remote shell is either rsh or remsh, rsync defaults to
++    using blocking I/O, otherwise it defaults to using non-blocking I/O. (Note
++    that ssh prefers non-blocking I/O.)
++
++0.  `--outbuf=MODE`
++
++    This sets the output buffering mode.  The mode can be None (aka
++    Unbuffered), Line, or Block (aka Full).  You may specify as little as a
++    single letter for the mode, and use upper or lower case.
++
++    The main use of this option is to change Full buffering to Line buffering
++    when rsync's output is going to a file or pipe.
++
++0.  `--itemize-changes`, `-i`
++
++    Requests a simple itemized list of the changes that are being made to each
++    file, including attribute changes.  This is exactly the same as specifying
++    [`--out-format='%i %n%L'`](#opt).  If you repeat the option, unchanged
++    files will also be output, but only if the receiving rsync is at least
++    version 2.6.7 (you can use `-vv` with older versions of rsync, but that
++    also turns on the output of other verbose messages).
++
++    The "%i" escape has a cryptic output that is 11 letters long.  The general
++    format is like the string `YXcstpoguax`, where **Y** is replaced by the type
++    of update being done, **X** is replaced by the file-type, and the other
++    letters represent attributes that may be output if they are being modified.
++
++    The update types that replace the **Y** are as follows:
++
++    - A `<` means that a file is being transferred to the remote host (sent).
++    - A `>` means that a file is being transferred to the local host
++      (received).
++    - A `c` means that a local change/creation is occurring for the item (such
++      as the creation of a directory or the changing of a symlink, etc.).
++    - A `h` means that the item is a hard link to another item (requires
++      [`--hard-links`](#opt)).
++    - A `.` means that the item is not being updated (though it might have
++      attributes that are being modified).
++    - A `*` means that the rest of the itemized-output area contains a message
++      (e.g. "deleting").
++
++    The file-types that replace the **X** are: `f` for a file, a `d` for a
++    directory, an `L` for a symlink, a `D` for a device, and a `S` for a
++    special file (e.g. named sockets and fifos).
++
++    The other letters in the string indicate if some attributes of the file
++    have changed, as follows:
++
++    - "`.`" - the attribute is unchanged.
++    - "`+`" - the file is newly created.
++    - "` `" - all the attributes are unchanged (all dots turn to spaces).
++    - "`?`" - the change is unknown (when the remote rsync is old).
++    - A letter indicates an attribute is being updated.
++
++    The attribute that is associated with each letter is as follows:
++
++    - A `c` means either that a regular file has a different checksum (requires
++      [`--checksum`](#opt)) or that a symlink, device, or special file has a
++      changed value.  Note that if you are sending files to an rsync prior to
++      3.0.1, this change flag will be present only for checksum-differing
++      regular files.
++    - A `s` means the size of a regular file is different and will be updated
++      by the file transfer.
++    - A `t` means the modification time is different and is being updated to
++      the sender's value (requires [`--times`](#opt)).  An alternate value of
++      `T` means that the modification time will be set to the transfer time,
++      which happens when a file/symlink/device is updated without
++      [`--times`](#opt) and when a symlink is changed and the receiver can't
++      set its time. (Note: when using an rsync 3.0.0 client, you might see the
++      `s` flag combined with `t` instead of the proper `T` flag for this
++      time-setting failure.)
++    - A `p` means the permissions are different and are being updated to the
++      sender's value (requires [`--perms`](#opt)).
++    - An `o` means the owner is different and is being updated to the sender's
++      value (requires [`--owner`](#opt) and super-user privileges).
++    - A `g` means the group is different and is being updated to the sender's
++      value (requires [`--group`](#opt) and the authority to set the group).
++    - A `u`|`n`|`b` indicates the following information:
++      - `u`  means the access (use) time is different and is being updated to
++	the sender's value (requires [`--atimes`](#opt))
++      - `n` means the create time (newness) is different and is being updated
++	to the sender's value (requires [`--crtimes`](#opt))
++      - `b` means that both the access and create times are being updated
++    - The `a` means that the ACL information is being changed.
++    - The `x` means that the extended attribute information is being changed.
++
++    One other output is possible: when deleting files, the "%i" will output the
++    string "`*deleting`" for each item that is being removed (assuming that you
++    are talking to a recent enough rsync that it logs deletions instead of
++    outputting them as a verbose message).
++
++0.  `--out-format=FORMAT`
++
++    This allows you to specify exactly what the rsync client outputs to the
++    user on a per-update basis.  The format is a text string containing
++    embedded single-character escape sequences prefixed with a percent (%)
++    character.  A default format of "%n%L" is assumed if either
++    [`--info=name`](#opt) or [`-v`](#opt) is specified (this tells you just the
++    name of the file and, if the item is a link, where it points).  For a full
++    list of the possible escape characters, see the [`log
++    format`](rsyncd.conf.5#log_format) setting in the rsyncd.conf manpage.
++
++    Specifying the `--out-format` option implies the [`--info=name`](#opt)
++    option, which will mention each file, dir, etc. that gets updated in a
++    significant way (a transferred file, a recreated symlink/device, or a
++    touched directory).  In addition, if the itemize-changes escape (%i) is
++    included in the string (e.g. if the [`--itemize-changes`](#opt) option was
++    used), the logging of names increases to mention any item that is changed
++    in any way (as long as the receiving side is at least 2.6.4).  See the
++    [`--itemize-changes`](#opt) option for a description of the output of "%i".
++
++    Rsync will output the out-format string prior to a file's transfer unless
++    one of the transfer-statistic escapes is requested, in which case the
++    logging is done at the end of the file's transfer.  When this late logging
++    is in effect and [`--progress`](#opt) is also specified, rsync will also
++    output the name of the file being transferred prior to its progress
++    information (followed, of course, by the out-format output).
++
++0.  `--log-file=FILE`
++
++    This option causes rsync to log what it is doing to a file.  This is
++    similar to the logging that a daemon does, but can be requested for the
++    client side and/or the server side of a non-daemon transfer.  If specified
++    as a client option, transfer logging will be enabled with a default format
++    of "%i %n%L".  See the [`--log-file-format`](#opt) option if you wish to
++    override this.
++
++    Here's an example command that requests the remote side to log what is
++    happening:
++
++    >     rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/
++
++    This is very useful if you need to debug why a connection is closing
++    unexpectedly.
++
++    See also [the daemon version of the `--log-file` option](#dopt--log-file).
++
++0.  `--log-file-format=FORMAT`
++
++    This allows you to specify exactly what per-update logging is put into the
++    file specified by the [`--log-file`](#opt) option (which must also be
++    specified for this option to have any effect).  If you specify an empty
++    string, updated files will not be mentioned in the log file.  For a list of
++    the possible escape characters, see the [`log format`](rsyncd.conf.5#log_format)
++    setting in the rsyncd.conf manpage.
++
++    The default FORMAT used if [`--log-file`](#opt) is specified and this
++    option is not is '%i %n%L'.
++
++    See also [the daemon version of the `--log-file-format`
++    option](#dopt--log-file-format).
++
++0.  `--stats`
++
++    This tells rsync to print a verbose set of statistics on the file transfer,
++    allowing you to tell how effective rsync's delta-transfer algorithm is for
++    your data.  This option is equivalent to [`--info=stats2`](#opt) if
++    combined with 0 or 1 [`-v`](#opt) options, or [`--info=stats3`](#opt) if
++    combined with 2 or more [`-v`](#opt) options.
++
++    The current statistics are as follows:
++
++    - `Number of files` is the count of all "files" (in the generic sense),
++      which includes directories, symlinks, etc.  The total count will be
++      followed by a list of counts by filetype (if the total is non-zero).  For
++      example: "(reg: 5, dir: 3, link: 2, dev: 1, special: 1)" lists the totals
++      for regular files, directories, symlinks, devices, and special files.  If
++      any of value is 0, it is completely omitted from the list.
++    - `Number of created files` is the count of how many "files" (generic
++      sense) were created (as opposed to updated).  The total count will be
++      followed by a list of counts by filetype (if the total is non-zero).
++    - `Number of deleted files` is the count of how many "files" (generic
++      sense) were deleted.  The total count will be
++      followed by a list of counts by filetype (if the total is non-zero).
++      Note that this line is only output if deletions are in effect, and only
++      if protocol 31 is being used (the default for rsync 3.1.x).
++    - `Number of regular files transferred` is the count of normal files that
++      were updated via rsync's delta-transfer algorithm, which does not include
++      dirs, symlinks, etc.  Note that rsync 3.1.0 added the word "regular" into
++      this heading.
++    - `Total file size` is the total sum of all file sizes in the transfer.
++      This does not count any size for directories or special files, but does
++      include the size of symlinks.
++    - `Total transferred file size` is the total sum of all files sizes for
++      just the transferred files.
++    - `Literal data` is how much unmatched file-update data we had to send to
++      the receiver for it to recreate the updated files.
++    - `Matched data` is how much data the receiver got locally when recreating
++      the updated files.
++    - `File list size` is how big the file-list data was when the sender sent
++      it to the receiver.  This is smaller than the in-memory size for the file
++      list due to some compressing of duplicated data when rsync sends the
++      list.
++    - `File list generation time` is the number of seconds that the sender
++      spent creating the file list.  This requires a modern rsync on the
++      sending side for this to be present.
++    - `File list transfer time` is the number of seconds that the sender spent
++      sending the file list to the receiver.
++    - `Total bytes sent` is the count of all the bytes that rsync sent from the
++      client side to the server side.
++    - `Total bytes received` is the count of all non-message bytes that rsync
++      received by the client side from the server side. "Non-message" bytes
++      means that we don't count the bytes for a verbose message that the server
++      sent to us, which makes the stats more consistent.
++
++0.  `--8-bit-output`, `-8`
++
++    This tells rsync to leave all high-bit characters unescaped in the output
++    instead of trying to test them to see if they're valid in the current
++    locale and escaping the invalid ones.  All control characters (but never
++    tabs) are always escaped, regardless of this option's setting.
++
++    The escape idiom that started in 2.6.7 is to output a literal backslash
++    (`\`) and a hash (`#`), followed by exactly 3 octal digits.  For example, a
++    newline would output as "`\#012`".  A literal backslash that is in a
++    filename is not escaped unless it is followed by a hash and 3 digits (0-9).
++
++0.  `--human-readable`, `-h`
++
++    Output numbers in a more human-readable format.  There are 3 possible levels:
++
++    1. output numbers with a separator between each set of 3 digits (either a
++       comma or a period, depending on if the decimal point is represented by a
++       period or a comma).
++    2. output numbers in units of 1000 (with a character suffix for larger
++       units -- see below).
++    3. output numbers in units of 1024.
++
++    The default is human-readable level 1.  Each `-h` option increases the
++    level by one.  You can take the level down to 0 (to output numbers as pure
++    digits) by specifying the `--no-human-readable` (`--no-h`) option.
++
++    The unit letters that are appended in levels 2 and 3 are: `K` (kilo), `M`
++    (mega), `G` (giga), `T` (tera), or `P` (peta).  For example, a 1234567-byte
++    file would output as 1.23M in level-2 (assuming that a period is your local
++    decimal point).
++
++    Backward compatibility note: versions of rsync prior to 3.1.0 do not
++    support human-readable level 1, and they default to level 0.  Thus,
++    specifying one or two `-h` options will behave in a comparable manner in
++    old and new versions as long as you didn't specify a `--no-h` option prior
++    to one or more `-h` options.  See the [`--list-only`](#opt) option for one
++    difference.
++
++0.  `--partial`
++
++    By default, rsync will delete any partially transferred file if the
++    transfer is interrupted.  In some circumstances it is more desirable to
++    keep partially transferred files.  Using the `--partial` option tells rsync
++    to keep the partial file which should make a subsequent transfer of the
++    rest of the file much faster.
++
++0.  `--partial-dir=DIR`
++
++    This option modifies the behavior of the [`--partial`](#opt) option while
++    also implying that it be enabled.  This enhanced partial-file method puts
++    any partially transferred files into the specified _DIR_ instead of writing
++    the partial file out to the destination file.  On the next transfer, rsync
++    will use a file found in this dir as data to speed up the resumption of the
++    transfer and then delete it after it has served its purpose.
++
++    Note that if [`--whole-file`](#opt) is specified (or implied), any
++    partial-dir files that are found for a file that is being updated will
++    simply be removed (since rsync is sending files without using rsync's
++    delta-transfer algorithm).
++
++    Rsync will create the _DIR_ if it is missing, but just the last dir -- not
++    the whole path.  This makes it easy to use a relative path (such as
++    "`--partial-dir=.rsync-partial`") to have rsync create the
++    partial-directory in the destination file's directory when it is needed,
++    and then remove it again when the partial file is deleted.  Note that this
++    directory removal is only done for a relative pathname, as it is expected
++    that an absolute path is to a directory that is reserved for partial-dir
++    work.
++
++    If the partial-dir value is not an absolute path, rsync will add an exclude
++    rule at the end of all your existing excludes.  This will prevent the
++    sending of any partial-dir files that may exist on the sending side, and
++    will also prevent the untimely deletion of partial-dir items on the
++    receiving side.  An example: the above `--partial-dir` option would add the
++    equivalent of this "perishable" exclude at the end of any other filter
++    rules: `-f '-p .rsync-partial/'`
++
++    If you are supplying your own exclude rules, you may need to add your own
++    exclude/hide/protect rule for the partial-dir because:
++
++    1. the auto-added rule may be ineffective at the end of your other rules, or
++    2. you may wish to override rsync's exclude choice.
++
++    For instance, if you want to make rsync clean-up any left-over partial-dirs
++    that may be lying around, you should specify [`--delete-after`](#opt) and
++    add a "risk" filter rule, e.g.  `-f 'R .rsync-partial/'`. Avoid using
++    [`--delete-before`](#opt) or [`--delete-during`](#opt) unless you don't
++    need rsync to use any of the left-over partial-dir data during the current
++    run.
++
++    IMPORTANT: the `--partial-dir` should not be writable by other users or it
++    is a security risk!  E.g. AVOID "/tmp"!
++
++    You can also set the partial-dir value the [`RSYNC_PARTIAL_DIR`](#)
++    environment variable.  Setting this in the environment does not force
++    [`--partial`](#opt) to be enabled, but rather it affects where partial
++    files go when [`--partial`](#opt) is specified.  For instance, instead of
++    using `--partial-dir=.rsync-tmp` along with [`--progress`](#opt), you could
++    set [`RSYNC_PARTIAL_DIR=.rsync-tmp`](#) in your environment and then use
++    the [`-P`](#opt) option to turn on the use of the .rsync-tmp dir for
++    partial transfers.  The only times that the [`--partial`](#opt) option does
++    not look for this environment value are:
++
++    1. when [`--inplace`](#opt) was specified (since [`--inplace`](#opt)
++       conflicts with `--partial-dir`), and
++    2. when [`--delay-updates`](#opt) was specified (see below).
++
++    When a modern rsync resumes the transfer of a file in the partial-dir, that
++    partial file is now updated in-place instead of creating yet another
++    tmp-file copy (so it maxes out at dest + tmp instead of dest + partial +
++    tmp).  This requires both ends of the transfer to be at least version
++    3.2.0.
++
++    For the purposes of the daemon-config's "`refuse options`" setting,
++    `--partial-dir` does _not_ imply [`--partial`](#opt).  This is so that a
++    refusal of the [`--partial`](#opt) option can be used to disallow the
++    overwriting of destination files with a partial transfer, while still
++    allowing the safer idiom provided by `--partial-dir`.
++
++0.  `--delay-updates`
++
++    This option puts the temporary file from each updated file into a holding
++    directory until the end of the transfer, at which time all the files are
++    renamed into place in rapid succession.  This attempts to make the updating
++    of the files a little more atomic.  By default the files are placed into a
++    directory named `.~tmp~` in each file's destination directory, but if
++    you've specified the [`--partial-dir`](#opt) option, that directory will be
++    used instead.  See the comments in the [`--partial-dir`](#opt) section for
++    a discussion of how this `.~tmp~` dir will be excluded from the transfer,
++    and what you can do if you want rsync to cleanup old `.~tmp~` dirs that
++    might be lying around.  Conflicts with [`--inplace`](#opt) and
++    [`--append`](#opt).
++
++    This option implies [`--no-inc-recursive`](#opt) since it needs the full
++    file list in memory in order to be able to iterate over it at the end.
++
++    This option uses more memory on the receiving side (one bit per file
++    transferred) and also requires enough free disk space on the receiving side
++    to hold an additional copy of all the updated files.  Note also that you
++    should not use an absolute path to [`--partial-dir`](#opt) unless:
++
++    1. there is no chance of any of the files in the transfer having the same
++       name (since all the updated files will be put into a single directory if
++       the path is absolute), and
++    2. there are no mount points in the hierarchy (since the delayed updates
++       will fail if they can't be renamed into place).
++
++    See also the "atomic-rsync" python script in the "support" subdir for an
++    update algorithm that is even more atomic (it uses [`--link-dest`](#opt)
++    and a parallel hierarchy of files).
++
++0.  `--prune-empty-dirs`, `-m`
++
++    This option tells the receiving rsync to get rid of empty directories from
++    the file-list, including nested directories that have no non-directory
++    children.  This is useful for avoiding the creation of a bunch of useless
++    directories when the sending rsync is recursively scanning a hierarchy of
++    files using include/exclude/filter rules.
++
++    This option can still leave empty directories on the receiving side if you
++    make use of [TRANSFER_RULES](#).
++
++    Because the file-list is actually being pruned, this option also affects
++    what directories get deleted when a delete is active.  However, keep in
++    mind that excluded files and directories can prevent existing items from
++    being deleted due to an exclude both hiding source files and protecting
++    destination files.  See the perishable filter-rule option for how to avoid
++    this.
++
++    You can prevent the pruning of certain empty directories from the file-list
++    by using a global "protect" filter.  For instance, this option would ensure
++    that the directory "emptydir" was kept in the file-list:
++
++    >     --filter 'protect emptydir/'
++
++    Here's an example that copies all .pdf files in a hierarchy, only creating
++    the necessary destination directories to hold the .pdf files, and ensures
++    that any superfluous files and directories in the destination are removed
++    (note the hide filter of non-directories being used instead of an exclude):
++
++    >     rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest
++
++    If you didn't want to remove superfluous destination files, the more
++    time-honored options of `--include='*/' --exclude='*'` would work
++    fine in place of the hide-filter (if that is more natural to you).
++
++0.  `--progress`
++
++    This option tells rsync to print information showing the progress of the
++    transfer.  This gives a bored user something to watch.  With a modern rsync
++    this is the same as specifying [`--info=flist2,name,progress`](#opt), but
++    any user-supplied settings for those info flags takes precedence (e.g.
++    [`--info=flist0 --progress`](#opt)).
++
++    While rsync is transferring a regular file, it updates a progress line that
++    looks like this:
++
++    >     782448  63%  110.64kB/s    0:00:04
++
++    In this example, the receiver has reconstructed 782448 bytes or 63% of the
++    sender's file, which is being reconstructed at a rate of 110.64 kilobytes
++    per second, and the transfer will finish in 4 seconds if the current rate
++    is maintained until the end.
++
++    These statistics can be misleading if rsync's delta-transfer algorithm is
++    in use.  For example, if the sender's file consists of the basis file
++    followed by additional data, the reported rate will probably drop
++    dramatically when the receiver gets to the literal data, and the transfer
++    will probably take much longer to finish than the receiver estimated as it
++    was finishing the matched part of the file.
++
++    When the file transfer finishes, rsync replaces the progress line with a
++    summary line that looks like this:
++
++    >     1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)
++
++    In this example, the file was 1,238,099 bytes long in total, the average
++    rate of transfer for the whole file was 146.38 kilobytes per second over
++    the 8 seconds that it took to complete, it was the 5th transfer of a
++    regular file during the current rsync session, and there are 169 more files
++    for the receiver to check (to see if they are up-to-date or not) remaining
++    out of the 396 total files in the file-list.
++
++    In an incremental recursion scan, rsync won't know the total number of
++    files in the file-list until it reaches the ends of the scan, but since it
++    starts to transfer files during the scan, it will display a line with the
++    text "ir-chk" (for incremental recursion check) instead of "to-chk" until
++    the point that it knows the full size of the list, at which point it will
++    switch to using "to-chk".  Thus, seeing "ir-chk" lets you know that the
++    total count of files in the file list is still going to increase (and each
++    time it does, the count of files left to check will increase by the number
++    of the files added to the list).
++
++0.  `-P`
++
++    The `-P` option is equivalent to "[`--partial`](#opt)
++    [`--progress`](#opt)".  Its purpose is to make it much easier to specify
++    these two options for a long transfer that may be interrupted.
++
++    There is also a [`--info=progress2`](#opt) option that outputs statistics
++    based on the whole transfer, rather than individual files.  Use this flag
++    without outputting a filename (e.g. avoid `-v` or specify
++    [`--info=name0`](#opt)) if you want to see how the transfer is doing
++    without scrolling the screen with a lot of names. (You don't need to
++    specify the [`--progress`](#opt) option in order to use
++    [`--info=progress2`](#opt).)
++
++    Finally, you can get an instant progress report by sending rsync a signal
++    of either SIGINFO or SIGVTALRM.  On BSD systems, a SIGINFO is generated by
++    typing a Ctrl+T (Linux doesn't currently support a SIGINFO signal).  When
++    the client-side process receives one of those signals, it sets a flag to
++    output a single progress report which is output when the current file
++    transfer finishes (so it may take a little time if a big file is being
++    handled when the signal arrives).  A filename is output (if needed)
++    followed by the [`--info=progress2`](#opt) format of progress info.  If you
++    don't know which of the 3 rsync processes is the client process, it's OK to
++    signal all of them (since the non-client processes ignore the signal).
++
++    CAUTION: sending SIGVTALRM to an older rsync (pre-3.2.0) will kill it.
++
++0.  `--password-file=FILE`
++
++    This option allows you to provide a password for accessing an rsync daemon
++    via a file or via standard input if **FILE** is `-`.  The file should
++    contain just the password on the first line (all other lines are ignored).
++    Rsync will exit with an error if **FILE** is world readable or if a
++    root-run rsync command finds a non-root-owned file.
++
++    This option does not supply a password to a remote shell transport such as
++    ssh; to learn how to do that, consult the remote shell's documentation.
++    When accessing an rsync daemon using a remote shell as the transport, this
++    option only comes into effect after the remote shell finishes its
++    authentication (i.e. if you have also specified a password in the daemon's
++    config file).
++
++0.  `--early-input=FILE`
++
++    This option allows rsync to send up to 5K of data to the "early exec"
++    script on its stdin.  One possible use of this data is to give the script a
++    secret that can be used to mount an encrypted filesystem (which you should
++    unmount in the the "post-xfer exec" script).
++
++    The daemon must be at least version 3.2.1.
++
++0.  `--list-only`
++
++    This option will cause the source files to be listed instead of
++    transferred.  This option is inferred if there is a single source arg and
++    no destination specified, so its main uses are:
++
++    1. to turn a copy command that includes a destination arg into a
++       file-listing command, or
++    2. to be able to specify more than one source arg.  Note: be sure to
++       include the destination.
++
++    CAUTION: keep in mind that a source arg with a wild-card is expanded by the
++    shell into multiple args, so it is never safe to try to specify a single
++    wild-card arg to try to infer this option. A safe example is:
++
++    >     rsync -av --list-only foo* dest/
++
++    This option always uses an output format that looks similar to this:
++
++    >     drwxrwxr-x          4,096 2022/09/30 12:53:11 support
++    >     -rw-rw-r--             80 2005/01/11 10:37:37 support/Makefile
++
++    The only option that affects this output style is (as of 3.1.0) the
++    [`--human-readable`](#opt) (`-h`) option.  The default is to output sizes
++    as byte counts with digit separators (in a 14-character-width column).
++    Specifying at least one `-h` option makes the sizes output with unit
++    suffixes.  If you want old-style bytecount sizes without digit separators
++    (and an 11-character-width column) use `--no-h`.
++
++    Compatibility note: when requesting a remote listing of files from an rsync
++    that is version 2.6.3 or older, you may encounter an error if you ask for a
++    non-recursive listing.  This is because a file listing implies the
++    [`--dirs`](#opt) option w/o [`--recursive`](#opt), and older rsyncs don't
++    have that option.  To avoid this problem, either specify the `--no-dirs`
++    option (if you don't need to expand a directory's content), or turn on
++    recursion and exclude the content of subdirectories: `-r --exclude='/*/*'`.
++
++0.  `--bwlimit=RATE`
++
++    This option allows you to specify the maximum transfer rate for the data
++    sent over the socket, specified in units per second.  The RATE value can be
++    suffixed with a string to indicate a size multiplier, and may be a
++    fractional value (e.g. `--bwlimit=1.5m`).  If no suffix is specified, the
++    value will be assumed to be in units of 1024 bytes (as if "K" or "KiB" had
++    been appended).  See the [`--max-size`](#opt) option for a description of
++    all the available suffixes.  A value of 0 specifies no limit.
++
++    For backward-compatibility reasons, the rate limit will be rounded to the
++    nearest KiB unit, so no rate smaller than 1024 bytes per second is
++    possible.
++
++    Rsync writes data over the socket in blocks, and this option both limits
++    the size of the blocks that rsync writes, and tries to keep the average
++    transfer rate at the requested limit.  Some burstiness may be seen where
++    rsync writes out a block of data and then sleeps to bring the average rate
++    into compliance.
++
++    Due to the internal buffering of data, the [`--progress`](#opt) option may
++    not be an accurate reflection on how fast the data is being sent.  This is
++    because some files can show up as being rapidly sent when the data is
++    quickly buffered, while other can show up as very slow when the flushing of
++    the output buffer occurs.  This may be fixed in a future version.
++
++    See also [the daemon version of the `--bwlimit` option](#dopt--bwlimit).
++
++0.  `--stop-after=MINS`, (`--time-limit=MINS`)
++
++    This option tells rsync to stop copying when the specified number of
++    minutes has elapsed.
++
++    For maximal flexibility, rsync does not communicate this option to the
++    remote rsync since it is usually enough that one side of the connection
++    quits as specified.  This allows the option's use even when only one side
++    of the connection supports it.  You can tell the remote side about the time
++    limit using [`--remote-option`](#opt) (`-M`), should the need arise.
++
++    The `--time-limit` version of this option is deprecated.
++
++0.  `--stop-at=y-m-dTh:m`
++
++    This option tells rsync to stop copying when the specified point in time
++    has been reached. The date & time can be fully specified in a numeric
++    format of year-month-dayThour:minute (e.g. 2000-12-31T23:59) in the local
++    timezone.  You may choose to separate the date numbers using slashes
++    instead of dashes.
++
++    The value can also be abbreviated in a variety of ways, such as specifying
++    a 2-digit year and/or leaving off various values.  In all cases, the value
++    will be taken to be the next possible point in time where the supplied
++    information matches.  If the value specifies the current time or a past
++    time, rsync exits with an error.
++
++    For example, "1-30" specifies the next January 30th (at midnight local
++    time), "14:00" specifies the next 2 P.M., "1" specifies the next 1st of the
++    month at midnight, "31" specifies the next month where we can stop on its
++    31st day, and ":59" specifies the next 59th minute after the hour.
++
++    For maximal flexibility, rsync does not communicate this option to the
++    remote rsync since it is usually enough that one side of the connection
++    quits as specified.  This allows the option's use even when only one side
++    of the connection supports it.  You can tell the remote side about the time
++    limit using [`--remote-option`](#opt) (`-M`), should the need arise.  Do
++    keep in mind that the remote host may have a different default timezone
++    than your local host.
++
++0.  `--fsync`
++
++    Cause the receiving side to fsync each finished file.  This may slow down
++    the transfer, but can help to provide peace of mind when updating critical
++    files.
++
++0.  `--write-batch=FILE`
++
++    Record a file that can later be applied to another identical destination
++    with [`--read-batch`](#opt).  See the "BATCH MODE" section for details, and
++    also the [`--only-write-batch`](#opt) option.
++
++    This option overrides the negotiated checksum & compress lists and always
++    negotiates a choice based on old-school md5/md4/zlib choices.  If you want
++    a more modern choice, use the [`--checksum-choice`](#opt) (`--cc`) and/or
++    [`--compress-choice`](#opt) (`--zc`) options.
++
++0.  `--only-write-batch=FILE`
++
++    Works like [`--write-batch`](#opt), except that no updates are made on the
++    destination system when creating the batch.  This lets you transport the
++    changes to the destination system via some other means and then apply the
++    changes via [`--read-batch`](#opt).
++
++    Note that you can feel free to write the batch directly to some portable
++    media: if this media fills to capacity before the end of the transfer, you
++    can just apply that partial transfer to the destination and repeat the
++    whole process to get the rest of the changes (as long as you don't mind a
++    partially updated destination system while the multi-update cycle is
++    happening).
++
++    Also note that you only save bandwidth when pushing changes to a remote
++    system because this allows the batched data to be diverted from the sender
++    into the batch file without having to flow over the wire to the receiver
++    (when pulling, the sender is remote, and thus can't write the batch).
++
++0.  `--read-batch=FILE`
++
++    Apply all of the changes stored in FILE, a file previously generated by
++    [`--write-batch`](#opt).  If _FILE_ is `-`, the batch data will be read
++    from standard input. See the "BATCH MODE" section for details.
++
++0.  `--protocol=NUM`
++
++    Force an older protocol version to be used.  This is useful for creating a
++    batch file that is compatible with an older version of rsync.  For
++    instance, if rsync 2.6.4 is being used with the [`--write-batch`](#opt)
++    option, but rsync 2.6.3 is what will be used to run the
++    [`--read-batch`](#opt) option, you should use "--protocol=28" when creating
++    the batch file to force the older protocol version to be used in the batch
++    file (assuming you can't upgrade the rsync on the reading system).
++
++0.  `--iconv=CONVERT_SPEC`
++
++    Rsync can convert filenames between character sets using this option.
++    Using a CONVERT_SPEC of "." tells rsync to look up the default
++    character-set via the locale setting.  Alternately, you can fully specify
++    what conversion to do by giving a local and a remote charset separated by a
++    comma in the order `--iconv=LOCAL,REMOTE`, e.g. `--iconv=utf8,iso88591`.
++    This order ensures that the option will stay the same whether you're
++    pushing or pulling files.  Finally, you can specify either `--no-iconv` or
++    a CONVERT_SPEC of "-" to turn off any conversion.  The default setting of
++    this option is site-specific, and can also be affected via the
++    [`RSYNC_ICONV`](#) environment variable.
++
++    For a list of what charset names your local iconv library supports, you can
++    run "`iconv --list`".
++
++    If you specify the [`--secluded-args`](#opt) (`-s`) option, rsync will
++    translate the filenames you specify on the command-line that are being sent
++    to the remote host.  See also the [`--files-from`](#opt) option.
++
++    Note that rsync does not do any conversion of names in filter files
++    (including include/exclude files).  It is up to you to ensure that you're
++    specifying matching rules that can match on both sides of the transfer.
++    For instance, you can specify extra include/exclude rules if there are
++    filename differences on the two sides that need to be accounted for.
++
++    When you pass an `--iconv` option to an rsync daemon that allows it, the
++    daemon uses the charset specified in its "charset" configuration parameter
++    regardless of the remote charset you actually pass.  Thus, you may feel
++    free to specify just the local charset for a daemon transfer (e.g.
++    `--iconv=utf8`).
++
++0.  `--ipv4`, `-4` or `--ipv6`, `-6`
++
++    Tells rsync to prefer IPv4/IPv6 when creating sockets or running ssh.  This
++    affects sockets that rsync has direct control over, such as the outgoing
++    socket when directly contacting an rsync daemon, as well as the forwarding
++    of the `-4` or `-6` option to ssh when rsync can deduce that ssh is being
++    used as the remote shell.  For other remote shells you'll need to specify
++    the "`--rsh SHELL -4`" option directly (or whatever IPv4/IPv6 hint options
++    it uses).
++
++    See also [the daemon version of these options](#dopt--ipv4).
++
++    If rsync was compiled without support for IPv6, the `--ipv6` option will
++    have no effect.  The `rsync --version` output will contain "`no IPv6`" if
++    is the case.
++
++0.  `--checksum-seed=NUM`
++
++    Set the checksum seed to the integer NUM.  This 4 byte checksum seed is
++    included in each block and MD4 file checksum calculation (the more modern
++    MD5 file checksums don't use a seed).  By default the checksum seed is
++    generated by the server and defaults to the current **time**().  This
++    option is used to set a specific checksum seed, which is useful for
++    applications that want repeatable block checksums, or in the case where the
++    user wants a more random checksum seed.  Setting NUM to 0 causes rsync to
++    use the default of **time**() for checksum seed.
++
++## DAEMON OPTIONS
++
++The options allowed when starting an rsync daemon are as follows:
++
++0.  `--daemon`
++
++    This tells rsync that it is to run as a daemon.  The daemon you start
++    running may be accessed using an rsync client using the `host::module` or
++    `rsync://host/module/` syntax.
++
++    If standard input is a socket then rsync will assume that it is being run
++    via inetd, otherwise it will detach from the current terminal and become a
++    background daemon.  The daemon will read the config file (rsyncd.conf) on
++    each connect made by a client and respond to requests accordingly.
++
++    See the [**rsyncd.conf**(5)](rsyncd.conf.5) manpage for more details.
++
++0.  `--address=ADDRESS`
++
++    By default rsync will bind to the wildcard address when run as a daemon
++    with the `--daemon` option.  The `--address` option allows you to specify a
++    specific IP address (or hostname) to bind to.  This makes virtual hosting
++    possible in conjunction with the `--config` option.
++
++    See also the [address](rsyncd.conf.5#address) global option in the
++    rsyncd.conf manpage and the [client version of the `--address`
++    option](#opt--address).
++
++0.  `--bwlimit=RATE`
++
++    This option allows you to specify the maximum transfer rate for the data
++    the daemon sends over the socket.  The client can still specify a smaller
++    `--bwlimit` value, but no larger value will be allowed.
++
++    See the [client version of the `--bwlimit` option](#opt--bwlimit) for some
++    extra details.
++
++0.  `--config=FILE`
++
++    This specifies an alternate config file than the default.  This is only
++    relevant when [`--daemon`](#dopt) is specified.  The default is
++    /etc/rsyncd.conf unless the daemon is running over a remote shell program
++    and the remote user is not the super-user; in that case the default is
++    rsyncd.conf in the current directory (typically $HOME).
++
++0.  `--dparam=OVERRIDE`, `-M`
++
++    This option can be used to set a daemon-config parameter when starting up
++    rsync in daemon mode.  It is equivalent to adding the parameter at the end
++    of the global settings prior to the first module's definition.  The
++    parameter names can be specified without spaces, if you so desire.  For
++    instance:
++
++    >     rsync --daemon -M pidfile=/path/rsync.pid
++
++0.  `--no-detach`
++
++    When running as a daemon, this option instructs rsync to not detach itself
++    and become a background process.  This option is required when running as a
++    service on Cygwin, and may also be useful when rsync is supervised by a
++    program such as `daemontools` or AIX's `System Resource Controller`.
++    `--no-detach` is also recommended when rsync is run under a debugger.  This
++    option has no effect if rsync is run from inetd or sshd.
++
++0.  `--port=PORT`
++
++    This specifies an alternate TCP port number for the daemon to listen on
++    rather than the default of 873.
++
++    See also [the client version of the `--port` option](#opt--port) and the
++    [port](rsyncd.conf.5#port) global setting in the rsyncd.conf manpage.
++
++0.  `--log-file=FILE`
++
++    This option tells the rsync daemon to use the given log-file name instead
++    of using the "`log file`" setting in the config file.
++
++    See also [the client version of the `--log-file` option](#opt--log-file).
++
++0.  `--log-file-format=FORMAT`
++
++    This option tells the rsync daemon to use the given FORMAT string instead
++    of using the "`log format`" setting in the config file.  It also enables
++    "`transfer logging`" unless the string is empty, in which case transfer
++    logging is turned off.
++
++    See also [the client version of the `--log-file-format`
++    option](#opt--log-file-format).
++
++0.  `--sockopts`
++
++    This overrides the [`socket options`](rsyncd.conf.5#socket_options)
++    setting in the rsyncd.conf file and has the same syntax.
++
++    See also [the client version of the `--sockopts` option](#opt--sockopts).
++
++0.  `--verbose`, `-v`
++
++    This option increases the amount of information the daemon logs during its
++    startup phase.  After the client connects, the daemon's verbosity level
++    will be controlled by the options that the client used and the
++    "`max verbosity`" setting in the module's config section.
++
++    See also [the client version of the `--verbose` option](#opt--verbose).
++
++0.  `--ipv4`, `-4` or `--ipv6`, `-6`
++
++    Tells rsync to prefer IPv4/IPv6 when creating the incoming sockets that the
++    rsync daemon will use to listen for connections.  One of these options may
++    be required in older versions of Linux to work around an IPv6 bug in the
++    kernel (if you see an "address already in use" error when nothing else is
++    using the port, try specifying `--ipv6` or `--ipv4` when starting the
++    daemon).
++
++    See also [the client version of these options](#opt--ipv4).
++
++    If rsync was compiled without support for IPv6, the `--ipv6` option will
++    have no effect.  The `rsync --version` output will contain "`no IPv6`" if
++    is the case.
++
++0.  `--help`, `-h`
++
++    When specified after `--daemon`, print a short help page describing the
++    options available for starting an rsync daemon.
++
++## FILTER RULES
++
++The filter rules allow for custom control of several aspects of how files are
++handled:
++
++- Control which files the sending side puts into the file list that describes
++  the transfer hierarchy
++- Control which files the receiving side protects from deletion when the file
++  is not in the sender's file list
++- Control which extended attribute names are skipped when copying xattrs
++
++The rules are either directly specified via option arguments or they can be
++read in from one or more files.  The filter-rule files can even be a part of
++the hierarchy of files being copied, affecting different parts of the tree in
++different ways.
++
++### SIMPLE INCLUDE/EXCLUDE RULES
++
++We will first cover the basics of how include & exclude rules affect what files
++are transferred, ignoring any deletion side-effects.  Filter rules mainly
++affect the contents of directories that rsync is "recursing" into, but they can
++also affect a top-level item in the transfer that was specified as a argument.
++
++The default for any unmatched file/dir is for it to be included in the
++transfer, which puts the file/dir into the sender's file list.  The use of an
++exclude rule causes one or more matching files/dirs to be left out of the
++sender's file list.  An include rule can be used to limit the effect of an
++exclude rule that is matching too many files.
++
++The order of the rules is important because the first rule that matches is the
++one that takes effect.  Thus, if an early rule excludes a file, no include rule
++that comes after it can have any effect. This means that you must place any
++include overrides somewhere prior to the exclude that it is intended to limit.
++
++When a directory is excluded, all its contents and sub-contents are also
++excluded.  The sender doesn't scan through any of it at all, which can save a
++lot of time when skipping large unneeded sub-trees.
++
++It is also important to understand that the include/exclude rules are applied
++to every file and directory that the sender is recursing into. Thus, if you
++want a particular deep file to be included, you have to make sure that none of
++the directories that must be traversed on the way down to that file are
++excluded or else the file will never be discovered to be included. As an
++example, if the directory "`a/path`" was given as a transfer argument and you
++want to ensure that the file "`a/path/down/deep/wanted.txt`" is a part of the
++transfer, then the sender must not exclude the directories "`a/path`",
++"`a/path/down`", or "`a/path/down/deep`" as it makes it way scanning through
++the file tree.
++
++When you are working on the rules, it can be helpful to ask rsync to tell you
++what is being excluded/included and why.  Specifying `--debug=FILTER` or (when
++pulling files) `-M--debug=FILTER` turns on level 1 of the FILTER debug
++information that will output a message any time that a file or directory is
++included or excluded and which rule it matched.  Beginning in 3.2.4 it will
++also warn if a filter rule has trailing whitespace, since an exclude of "foo "
++(with a trailing space) will not exclude a file named "foo".
++
++Exclude and include rules can specify wildcard [PATTERN MATCHING RULES](#)
++(similar to shell wildcards) that allow you to match things like a file suffix
++or a portion of a filename.
++
++A rule can be limited to only affecting a directory by putting a trailing slash
++onto the filename.
++
++### SIMPLE INCLUDE/EXCLUDE EXAMPLE
++
++With the following file tree created on the sending side:
++
++>     mkdir x/
++>     touch x/file.txt
++>     mkdir x/y/
++>     touch x/y/file.txt
++>     touch x/y/zzz.txt
++>     mkdir x/z/
++>     touch x/z/file.txt
++
++Then the following rsync command will transfer the file "`x/y/file.txt`" and
++the directories needed to hold it, resulting in the path "`/tmp/x/y/file.txt`"
++existing on the remote host:
++
++>     rsync -ai -f'+ x/' -f'+ x/y/' -f'+ x/y/file.txt' -f'- *' x host:/tmp/
++
++Aside: this copy could also have been accomplished using the [`-R`](#opt)
++option (though the 2 commands behave differently if deletions are enabled):
++
++>     rsync -aiR x/y/file.txt host:/tmp/
++
++The following command does not need an include of the "x" directory because it
++is not a part of the transfer (note the traililng slash).  Running this command
++would copy just "`/tmp/x/file.txt`" because the "y" and "z" dirs get excluded:
++
++>     rsync -ai -f'+ file.txt' -f'- *' x/ host:/tmp/x/
++
++This command would omit the zzz.txt file while copying "x" and everything else
++it contains:
++
++>     rsync -ai -f'- zzz.txt' x host:/tmp/
++
++### FILTER RULES WHEN DELETING
++
++By default the include & exclude filter rules affect both the sender
++(as it creates its file list)
++and the receiver (as it creates its file lists for calculating deletions).  If
++no delete option is in effect, the receiver skips creating the delete-related
++file lists.  This two-sided default can be manually overridden so that you are
++only specifying sender rules or receiver rules, as described in the [FILTER
++RULES IN DEPTH](#) section.
++
++When deleting, an exclude protects a file from being removed on the receiving
++side while an include overrides that protection (putting the file at risk of
++deletion). The default is for a file to be at risk -- its safety depends on it
++matching a corresponding file from the sender.
++
++An example of the two-sided exclude effect can be illustrated by the copying of
++a C development directory between 2 systems.  When doing a touch-up copy, you
++might want to skip copying the built executable and the `.o` files (sender
++hide) so that the receiving side can build their own and not lose any object
++files that are already correct (receiver protect).  For instance:
++
++>     rsync -ai --del -f'- *.o' -f'- cmd' src host:/dest/
++
++Note that using `-f'-p *.o'` is even better than `-f'- *.o'` if there is a
++chance that the directory structure may have changed.  The "p" modifier is
++discussed in [FILTER RULE MODIFIERS](#).
++
++One final note, if your shell doesn't mind unexpanded wildcards, you could
++simplify the typing of the filter options by using an underscore in place of
++the space and leaving off the quotes.  For instance, `-f -_*.o -f -_cmd` (and
++similar) could be used instead of the filter options above.
++
++### FILTER RULES IN DEPTH
++
++Rsync supports old-style include/exclude rules and new-style filter rules.  The
++older rules are specified using [`--include`](#opt) and [`--exclude`](#opt) as
++well as the [`--include-from`](#opt) and [`--exclude-from`](#opt). These are
++limited in behavior but they don't require a "-" or "+" prefix.  An old-style
++exclude rule is turned into a "`- name`" filter rule (with no modifiers) and an
++old-style include rule is turned into a "`+ name`" filter rule (with no
++modifiers).
++
++Rsync builds an ordered list of filter rules as specified on the command-line
++and/or read-in from files.  New style filter rules have the following syntax:
++
++>     RULE [PATTERN_OR_FILENAME]
++>     RULE,MODIFIERS [PATTERN_OR_FILENAME]
++
++You have your choice of using either short or long RULE names, as described
++below.  If you use a short-named rule, the ',' separating the RULE from the
++MODIFIERS is optional.  The PATTERN or FILENAME that follows (when present)
++must come after either a single space or an underscore (\_). Any additional
++spaces and/or underscores are considered to be a part of the pattern name.
++Here are the available rule prefixes:
++
++0.  `exclude, '-'` specifies an exclude pattern that (by default) is both a
++    `hide` and a `protect`.
++0.  `include, '+'` specifies an include pattern that (by default) is both a
++    `show` and a `risk`.
++0.  `merge, '.'` specifies a merge-file on the client side to read for more
++    rules.
++0.  `dir-merge, ':'` specifies a per-directory merge-file.  Using this kind of
++    filter rule requires that you trust the sending side's filter checking, so
++    it has the side-effect mentioned under the [`--trust-sender`](#opt) option.
++0.  `hide, 'H'` specifies a pattern for hiding files from the transfer.
++    Equivalent to a sender-only exclude, so `-f'H foo'` could also be specified
++    as `-f'-s foo'`.
++0.  `show, 'S'` files that match the pattern are not hidden. Equivalent to a
++    sender-only include, so `-f'S foo'` could also be specified as `-f'+s
++    foo'`.
++0.  `protect, 'P'` specifies a pattern for protecting files from deletion.
++    Equivalent to a receiver-only exclude, so `-f'P foo'` could also be
++    specified as `-f'-r foo'`.
++0.  `risk, 'R'` files that match the pattern are not protected. Equivalent to a
++    receiver-only include, so `-f'R foo'` could also be specified as `-f'+r
++    foo'`.
++0.  `clear, '!'` clears the current include/exclude list (takes no arg)
++
++When rules are being read from a file (using merge or dir-merge), empty lines
++are ignored, as are whole-line comments that start with a '`#`' (filename rules
++that contain a hash character are unaffected).
++
++Note also that the [`--filter`](#opt), [`--include`](#opt), and
++[`--exclude`](#opt) options take one rule/pattern each.  To add multiple ones,
++you can repeat the options on the command-line, use the merge-file syntax of
++the [`--filter`](#opt) option, or the [`--include-from`](#opt) /
++[`--exclude-from`](#opt) options.
++
++### PATTERN MATCHING RULES
++
++Most of the rules mentioned above take an argument that specifies what the rule
++should match.  If rsync is recursing through a directory hierarchy, keep in
++mind that each pattern is matched against the name of every directory in the
++descent path as rsync finds the filenames to send.
++
++The matching rules for the pattern argument take several forms:
++
++- If a pattern contains a `/` (not counting a trailing slash) or a "`**`"
++  (which can match a slash), then the pattern is matched against the full
++  pathname, including any leading directories within the transfer.  If the
++  pattern doesn't contain a (non-trailing) `/` or a "`**`", then it is matched
++  only against the final component of the filename or pathname. For example,
++  `foo` means that the final path component must be "foo" while `foo/bar` would
++  match the last 2 elements of the path (as long as both elements are within
++  the transfer).
++- A pattern that ends with a `/` only matches a directory, not a regular file,
++  symlink, or device.
++- A pattern that starts with a `/` is anchored to the start of the transfer
++  path instead of the end.  For example, `/foo/**` or `/foo/bar/**` match only
++  leading elements in the path.  If the rule is read from a per-directory
++  filter file, the transfer path being matched will begin at the level of the
++  filter file instead of the top of the transfer.  See the section on
++  [ANCHORING INCLUDE/EXCLUDE PATTERNS](#) for a full discussion of how to
++  specify a pattern that matches at the root of the transfer.
++
++Rsync chooses between doing a simple string match and wildcard matching by
++checking if the pattern contains one of these three wildcard characters: '`*`',
++'`?`', and '`[`' :
++
++- a '`?`' matches any single character except a slash (`/`).
++- a '`*`' matches zero or more non-slash characters.
++- a '`**`' matches zero or more characters, including slashes.
++- a '`[`' introduces a character class, such as `[a-z]` or `[[:alpha:]]`, that
++  must match one character.
++- a trailing `***` in the pattern is a shorthand that allows you to match a
++  directory and all its contents using a single rule.  For example, specifying
++  "`dir_name/***`" will match both the "dir_name" directory (as if "`dir_name/`"
++  had been specified) and everything in the directory (as if "`dir_name/**`"
++  had been specified).
++- a backslash can be used to escape a wildcard character, but it is only
++  interpreted as an escape character if at least one wildcard character is
++  present in the match pattern. For instance, the pattern "`foo\bar`" matches
++  that single backslash literally, while the pattern "`foo\bar*`" would need to
++  be changed to "`foo\\bar*`" to avoid the "`\b`" becoming just "b".
++
++Here are some examples of exclude/include matching:
++
++- Option `-f'- *.o'` would exclude all filenames ending with `.o`
++- Option `-f'- /foo'` would exclude a file (or directory) named foo in the
++  transfer-root directory
++- Option `-f'- foo/'` would exclude any directory named foo
++- Option `-f'- foo/*/bar'` would exclude any file/dir named bar which is at two
++  levels below a directory named foo (if foo is in the transfer)
++- Option `-f'- /foo/**/bar'` would exclude any file/dir named bar that was two
++  or more levels below a top-level directory named foo (note that /foo/bar is
++  **not** excluded by this)
++- Options `-f'+ */' -f'+ *.c' -f'- *'` would include all directories and .c
++  source files but nothing else
++- Options `-f'+ foo/' -f'+ foo/bar.c' -f'- *'` would include only the foo
++  directory and foo/bar.c (the foo directory must be explicitly included or it
++  would be excluded by the "`- *`")
++
++### FILTER RULE MODIFIERS
++
++The following modifiers are accepted after an include (+) or exclude (-) rule:
++
++- A `/` specifies that the include/exclude rule should be matched against the
++  absolute pathname of the current item.  For example, `-f'-/ /etc/passwd'`
++  would exclude the passwd file any time the transfer was sending files from
++  the "/etc" directory, and "-/ subdir/foo" would always exclude "foo" when it
++  is in a dir named "subdir", even if "foo" is at the root of the current
++  transfer.
++- A `!` specifies that the include/exclude should take effect if the pattern
++  fails to match.  For instance, `-f'-! */'` would exclude all non-directories.
++- A `C` is used to indicate that all the global CVS-exclude rules should be
++  inserted as excludes in place of the "-C".  No arg should follow.
++- An `s` is used to indicate that the rule applies to the sending side.  When a
++  rule affects the sending side, it affects what files are put into the
++  sender's file list.  The default is for a rule to affect both sides unless
++  [`--delete-excluded`](#opt) was specified, in which case default rules become
++  sender-side only.  See also the hide (H) and show (S) rules, which are an
++  alternate way to specify sending-side includes/excludes.
++- An `r` is used to indicate that the rule applies to the receiving side.  When
++  a rule affects the receiving side, it prevents files from being deleted.  See
++  the `s` modifier for more info.  See also the protect (P) and risk (R) rules,
++  which are an alternate way to specify receiver-side includes/excludes.
++- A `p` indicates that a rule is perishable, meaning that it is ignored in
++  directories that are being deleted.  For instance, the
++  [`--cvs-exclude`](#opt) (`-C`) option's default rules that exclude things
++  like "CVS" and "`*.o`" are marked as perishable, and will not prevent a
++  directory that was removed on the source from being deleted on the
++  destination.
++- An `x` indicates that a rule affects xattr names in xattr copy/delete
++  operations (and is thus ignored when matching file/dir names).  If no
++  xattr-matching rules are specified, a default xattr filtering rule is used
++  (see the [`--xattrs`](#opt) option).
++
++### MERGE-FILE FILTER RULES
++
++You can merge whole files into your filter rules by specifying either a merge
++(.) or a dir-merge (:) filter rule (as introduced in the [FILTER RULES](#)
++section above).
++
++There are two kinds of merged files -- single-instance ('.') and per-directory
++(':').  A single-instance merge file is read one time, and its rules are
++incorporated into the filter list in the place of the "." rule.  For
++per-directory merge files, rsync will scan every directory that it traverses
++for the named file, merging its contents when the file exists into the current
++list of inherited rules.  These per-directory rule files must be created on the
++sending side because it is the sending side that is being scanned for the
++available files to transfer.  These rule files may also need to be transferred
++to the receiving side if you want them to affect what files don't get deleted
++(see [PER-DIRECTORY RULES AND DELETE](#) below).
++
++Some examples:
++
++>     merge /etc/rsync/default.rules
++>     . /etc/rsync/default.rules
++>     dir-merge .per-dir-filter
++>     dir-merge,n- .non-inherited-per-dir-excludes
++>     :n- .non-inherited-per-dir-excludes
++
++The following modifiers are accepted after a merge or dir-merge rule:
++
++- A `-` specifies that the file should consist of only exclude patterns, with
++  no other rule-parsing except for in-file comments.
++- A `+` specifies that the file should consist of only include patterns, with
++  no other rule-parsing except for in-file comments.
++- A `C` is a way to specify that the file should be read in a CVS-compatible
++  manner.  This turns on 'n', 'w', and '-', but also allows the list-clearing
++  token (!) to be specified.  If no filename is provided, ".cvsignore" is
++  assumed.
++- A `e` will exclude the merge-file name from the transfer; e.g.  "dir-merge,e
++  .rules" is like "dir-merge .rules" and "- .rules".
++- An `n` specifies that the rules are not inherited by subdirectories.
++- A `w` specifies that the rules are word-split on whitespace instead of the
++  normal line-splitting.  This also turns off comments.  Note: the space that
++  separates the prefix from the rule is treated specially, so "- foo + bar" is
++  parsed as two rules (assuming that prefix-parsing wasn't also disabled).
++- You may also specify any of the modifiers for the "+" or "-" rules (above) in
++  order to have the rules that are read in from the file default to having that
++  modifier set (except for the `!` modifier, which would not be useful).  For
++  instance, "merge,-/ .excl" would treat the contents of .excl as absolute-path
++  excludes, while "dir-merge,s .filt" and ":sC" would each make all their
++  per-directory rules apply only on the sending side.  If the merge rule
++  specifies sides to affect (via the `s` or `r` modifier or both), then the
++  rules in the file must not specify sides (via a modifier or a rule prefix
++  such as `hide`).
++
++Per-directory rules are inherited in all subdirectories of the directory where
++the merge-file was found unless the 'n' modifier was used.  Each subdirectory's
++rules are prefixed to the inherited per-directory rules from its parents, which
++gives the newest rules a higher priority than the inherited rules.  The entire
++set of dir-merge rules are grouped together in the spot where the merge-file
++was specified, so it is possible to override dir-merge rules via a rule that
++got specified earlier in the list of global rules.  When the list-clearing rule
++("!") is read from a per-directory file, it only clears the inherited rules for
++the current merge file.
++
++Another way to prevent a single rule from a dir-merge file from being inherited
++is to anchor it with a leading slash.  Anchored rules in a per-directory
++merge-file are relative to the merge-file's directory, so a pattern "/foo"
++would only match the file "foo" in the directory where the dir-merge filter
++file was found.
++
++Here's an example filter file which you'd specify via `--filter=". file":`
++
++>     merge /home/user/.global-filter
++>     - *.gz
++>     dir-merge .rules
++>     + *.[ch]
++>     - *.o
++>     - foo*
++
++This will merge the contents of the /home/user/.global-filter file at the start
++of the list and also turns the ".rules" filename into a per-directory filter
++file.  All rules read in prior to the start of the directory scan follow the
++global anchoring rules (i.e. a leading slash matches at the root of the
++transfer).
++
++If a per-directory merge-file is specified with a path that is a parent
++directory of the first transfer directory, rsync will scan all the parent dirs
++from that starting point to the transfer directory for the indicated
++per-directory file.  For instance, here is a common filter (see [`-F`](#opt)):
++
++>     --filter=': /.rsync-filter'
++
++That rule tells rsync to scan for the file .rsync-filter in all directories
++from the root down through the parent directory of the transfer prior to the
++start of the normal directory scan of the file in the directories that are sent
++as a part of the transfer. (Note: for an rsync daemon, the root is always the
++same as the module's "path".)
++
++Some examples of this pre-scanning for per-directory files:
++
++>     rsync -avF /src/path/ /dest/dir
++>     rsync -av --filter=': ../../.rsync-filter' /src/path/ /dest/dir
++>     rsync -av --filter=': .rsync-filter' /src/path/ /dest/dir
++
++The first two commands above will look for ".rsync-filter" in "/" and "/src"
++before the normal scan begins looking for the file in "/src/path" and its
++subdirectories.  The last command avoids the parent-dir scan and only looks for
++the ".rsync-filter" files in each directory that is a part of the transfer.
++
++If you want to include the contents of a ".cvsignore" in your patterns, you
++should use the rule ":C", which creates a dir-merge of the .cvsignore file, but
++parsed in a CVS-compatible manner.  You can use this to affect where the
++[`--cvs-exclude`](#opt) (`-C`) option's inclusion of the per-directory
++.cvsignore file gets placed into your rules by putting the ":C" wherever you
++like in your filter rules.  Without this, rsync would add the dir-merge rule
++for the .cvsignore file at the end of all your other rules (giving it a lower
++priority than your command-line rules).  For example:
++
++> ```
++> cat <<EOT | rsync -avC --filter='. -' a/ b
++> + foo.o
++> :C
++> - *.old
++> EOT
++> rsync -avC --include=foo.o -f :C --exclude='*.old' a/ b
++> ```
++
++Both of the above rsync commands are identical.  Each one will merge all the
++per-directory .cvsignore rules in the middle of the list rather than at the
++end.  This allows their dir-specific rules to supersede the rules that follow
++the :C instead of being subservient to all your rules.  To affect the other CVS
++exclude rules (i.e. the default list of exclusions, the contents of
++$HOME/.cvsignore, and the value of $CVSIGNORE) you should omit the `-C`
++command-line option and instead insert a "-C" rule into your filter rules; e.g.
++"`--filter=-C`".
++
++### LIST-CLEARING FILTER RULE
++
++You can clear the current include/exclude list by using the "!" filter rule (as
++introduced in the [FILTER RULES](#) section above).  The "current" list is either
++the global list of rules (if the rule is encountered while parsing the filter
++options) or a set of per-directory rules (which are inherited in their own
++sub-list, so a subdirectory can use this to clear out the parent's rules).
++
++### ANCHORING INCLUDE/EXCLUDE PATTERNS
++
++As mentioned earlier, global include/exclude patterns are anchored at the "root
++of the transfer" (as opposed to per-directory patterns, which are anchored at
++the merge-file's directory).  If you think of the transfer as a subtree of
++names that are being sent from sender to receiver, the transfer-root is where
++the tree starts to be duplicated in the destination directory.  This root
++governs where patterns that start with a / match.
++
++Because the matching is relative to the transfer-root, changing the trailing
++slash on a source path or changing your use of the [`--relative`](#opt) option
++affects the path you need to use in your matching (in addition to changing how
++much of the file tree is duplicated on the destination host).  The following
++examples demonstrate this.
++
++Let's say that we want to match two source files, one with an absolute
++path of "/home/me/foo/bar", and one with a path of "/home/you/bar/baz".
++Here is how the various command choices differ for a 2-source transfer:
++
++> ```
++> Example cmd: rsync -a /home/me /home/you /dest
++> +/- pattern: /me/foo/bar
++> +/- pattern: /you/bar/baz
++> Target file: /dest/me/foo/bar
++> Target file: /dest/you/bar/baz
++> ```
++
++> ```
++> Example cmd: rsync -a /home/me/ /home/you/ /dest
++> +/- pattern: /foo/bar               (note missing "me")
++> +/- pattern: /bar/baz               (note missing "you")
++> Target file: /dest/foo/bar
++> Target file: /dest/bar/baz
++> ```
++
++> ```
++> Example cmd: rsync -a --relative /home/me/ /home/you /dest
++> +/- pattern: /home/me/foo/bar       (note full path)
++> +/- pattern: /home/you/bar/baz      (ditto)
++> Target file: /dest/home/me/foo/bar
++> Target file: /dest/home/you/bar/baz
++> ```
++
++> ```
++> Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
++> +/- pattern: /me/foo/bar      (starts at specified path)
++> +/- pattern: /you/bar/baz     (ditto)
++> Target file: /dest/me/foo/bar
++> Target file: /dest/you/bar/baz
++> ```
++
++The easiest way to see what name you should filter is to just look at the
++output when using [`--verbose`](#opt) and put a / in front of the name (use the
++`--dry-run` option if you're not yet ready to copy any files).
++
++### PER-DIRECTORY RULES AND DELETE
++
++Without a delete option, per-directory rules are only relevant on the sending
++side, so you can feel free to exclude the merge files themselves without
++affecting the transfer.  To make this easy, the 'e' modifier adds this exclude
++for you, as seen in these two equivalent commands:
++
++>     rsync -av --filter=': .excl' --exclude=.excl host:src/dir /dest
++>     rsync -av --filter=':e .excl' host:src/dir /dest
++
++However, if you want to do a delete on the receiving side AND you want some
++files to be excluded from being deleted, you'll need to be sure that the
++receiving side knows what files to exclude.  The easiest way is to include the
++per-directory merge files in the transfer and use [`--delete-after`](#opt),
++because this ensures that the receiving side gets all the same exclude rules as
++the sending side before it tries to delete anything:
++
++>     rsync -avF --delete-after host:src/dir /dest
++
++However, if the merge files are not a part of the transfer, you'll need to
++either specify some global exclude rules (i.e. specified on the command line),
++or you'll need to maintain your own per-directory merge files on the receiving
++side.  An example of the first is this (assume that the remote .rules files
++exclude themselves):
++
++>     rsync -av --filter=': .rules' --filter='. /my/extra.rules'
++>        --delete host:src/dir /dest
++
++In the above example the extra.rules file can affect both sides of the
++transfer, but (on the sending side) the rules are subservient to the rules
++merged from the .rules files because they were specified after the
++per-directory merge rule.
++
++In one final example, the remote side is excluding the .rsync-filter files from
++the transfer, but we want to use our own .rsync-filter files to control what
++gets deleted on the receiving side.  To do this we must specifically exclude
++the per-directory merge files (so that they don't get deleted) and then put
++rules into the local files to control what else should not get deleted.  Like
++one of these commands:
++
++> ```
++> rsync -av --filter=':e /.rsync-filter' --delete \
++>     host:src/dir /dest
++> rsync -avFF --delete host:src/dir /dest
++> ```
++
++## TRANSFER RULES
++
++In addition to the [FILTER RULES](#) that affect the recursive file scans that
++generate the file list on the sending and (when deleting) receiving sides,
++there are transfer rules. These rules affect which files the generator decides
++need to be transferred without the side effects of an exclude filter rule.
++Transfer rules affect only files and never directories.
++
++Because a transfer rule does not affect what goes into the sender's (and
++receiver's) file list, it cannot have any effect on which files get deleted on
++the receiving side.  For example, if the file "foo" is present in the sender's
++list but its size is such that it is omitted due to a transfer rule, the
++receiving side does not request the file.  However, its presence in the file
++list means that a delete pass will not remove a matching file named "foo" on
++the receiving side.  On the other hand, a server-side exclude (hide) of the
++file "foo" leaves the file out of the server's file list, and absent a
++receiver-side exclude (protect) the receiver will remove a matching file named
++"foo" if deletions are requested.
++
++Given that the files are still in the sender's file list, the
++[`--prune-empty-dirs`](#opt) option will not judge a directory as being empty
++even if it contains only files that the transfer rules omitted.
++
++Similarly, a transfer rule does not have any extra effect on which files are
++deleted on the receiving side, so setting a maximum file size for the transfer
++does not prevent big files from being deleted.
++
++Examples of transfer rules include the default "quick check" algorithm (which
++compares size & modify time), the [`--update`](#opt) option, the
++[`--max-size`](#opt) option, the [`--ignore-non-existing`](#opt) option, and a
++few others.
++
++## BATCH MODE
++
++Batch mode can be used to apply the same set of updates to many identical
++systems.  Suppose one has a tree which is replicated on a number of hosts.  Now
++suppose some changes have been made to this source tree and those changes need
++to be propagated to the other hosts.  In order to do this using batch mode,
++rsync is run with the write-batch option to apply the changes made to the
++source tree to one of the destination trees.  The write-batch option causes the
++rsync client to store in a "batch file" all the information needed to repeat
++this operation against other, identical destination trees.
++
++Generating the batch file once saves having to perform the file status,
++checksum, and data block generation more than once when updating multiple
++destination trees.  Multicast transport protocols can be used to transfer the
++batch update files in parallel to many hosts at once, instead of sending the
++same data to every host individually.
++
++To apply the recorded changes to another destination tree, run rsync with the
++read-batch option, specifying the name of the same batch file, and the
++destination tree.  Rsync updates the destination tree using the information
++stored in the batch file.
++
++For your convenience, a script file is also created when the write-batch option
++is used: it will be named the same as the batch file with ".sh" appended.  This
++script file contains a command-line suitable for updating a destination tree
++using the associated batch file.  It can be executed using a Bourne (or
++Bourne-like) shell, optionally passing in an alternate destination tree
++pathname which is then used instead of the original destination path.  This is
++useful when the destination tree path on the current host differs from the one
++used to create the batch file.
++
++Examples:
++
++>     $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
++>     $ scp foo* remote:
++>     $ ssh remote ./foo.sh /bdest/dir/
++
++>     $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
++>     $ ssh remote rsync --read-batch=- -a /bdest/dir/ <foo
++
++In these examples, rsync is used to update /adest/dir/ from /source/dir/ and
++the information to repeat this operation is stored in "foo" and "foo.sh".  The
++host "remote" is then updated with the batched data going into the directory
++/bdest/dir.  The differences between the two examples reveals some of the
++flexibility you have in how you deal with batches:
++
++- The first example shows that the initial copy doesn't have to be local -- you
++  can push or pull data to/from a remote host using either the remote-shell
++  syntax or rsync daemon syntax, as desired.
++- The first example uses the created "foo.sh" file to get the right rsync
++  options when running the read-batch command on the remote host.
++- The second example reads the batch data via standard input so that the batch
++  file doesn't need to be copied to the remote machine first.  This example
++  avoids the foo.sh script because it needed to use a modified
++  [`--read-batch`](#opt) option, but you could edit the script file if you
++  wished to make use of it (just be sure that no other option is trying to use
++  standard input, such as the [`--exclude-from=-`](#opt) option).
++
++Caveats:
++
++The read-batch option expects the destination tree that it is updating to be
++identical to the destination tree that was used to create the batch update
++fileset.  When a difference between the destination trees is encountered the
++update might be discarded with a warning (if the file appears to be up-to-date
++already) or the file-update may be attempted and then, if the file fails to
++verify, the update discarded with an error.  This means that it should be safe
++to re-run a read-batch operation if the command got interrupted.  If you wish
++to force the batched-update to always be attempted regardless of the file's
++size and date, use the [`-I`](#opt) option (when reading the batch).  If an
++error occurs, the destination tree will probably be in a partially updated
++state.  In that case, rsync can be used in its regular (non-batch) mode of
++operation to fix up the destination tree.
++
++The rsync version used on all destinations must be at least as new as the one
++used to generate the batch file.  Rsync will die with an error if the protocol
++version in the batch file is too new for the batch-reading rsync to handle.
++See also the [`--protocol`](#opt) option for a way to have the creating rsync
++generate a batch file that an older rsync can understand.  (Note that batch
++files changed format in version 2.6.3, so mixing versions older than that with
++newer versions will not work.)
++
++When reading a batch file, rsync will force the value of certain options to
++match the data in the batch file if you didn't set them to the same as the
++batch-writing command.  Other options can (and should) be changed.  For
++instance [`--write-batch`](#opt) changes to [`--read-batch`](#opt),
++[`--files-from`](#opt) is dropped, and the [`--filter`](#opt) /
++[`--include`](#opt) / [`--exclude`](#opt) options are not needed unless one of
++the [`--delete`](#opt) options is specified.
++
++The code that creates the BATCH.sh file transforms any filter/include/exclude
++options into a single list that is appended as a "here" document to the shell
++script file.  An advanced user can use this to modify the exclude list if a
++change in what gets deleted by [`--delete`](#opt) is desired.  A normal user
++can ignore this detail and just use the shell script as an easy way to run the
++appropriate [`--read-batch`](#opt) command for the batched data.
++
++The original batch mode in rsync was based on "rsync+", but the latest
++version uses a new implementation.
++
++## SYMBOLIC LINKS
++
++Three basic behaviors are possible when rsync encounters a symbolic
++link in the source directory.
++
++By default, symbolic links are not transferred at all.  A message "skipping
++non-regular" file is emitted for any symlinks that exist.
++
++If [`--links`](#opt) is specified, then symlinks are added to the transfer
++(instead of being noisily ignored), and the default handling is to recreate
++them with the same target on the destination.  Note that [`--archive`](#opt)
++implies [`--links`](#opt).
++
++If [`--copy-links`](#opt) is specified, then symlinks are "collapsed" by
++copying their referent, rather than the symlink.
++
++Rsync can also distinguish "safe" and "unsafe" symbolic links.  An example
++where this might be used is a web site mirror that wishes to ensure that the
++rsync module that is copied does not include symbolic links to `/etc/passwd` in
++the public section of the site.  Using [`--copy-unsafe-links`](#opt) will cause
++any links to be copied as the file they point to on the destination.  Using
++[`--safe-links`](#opt) will cause unsafe links to be omitted by the receiver.
++(Note that you must specify or imply [`--links`](#opt) for
++[`--safe-links`](#opt) to have any effect.)
++
++Symbolic links are considered unsafe if they are absolute symlinks (start with
++`/`), empty, or if they contain enough ".." components to ascend from the top
++of the transfer.
++
++Here's a summary of how the symlink options are interpreted.  The list is in
++order of precedence, so if your combination of options isn't mentioned, use the
++first line that is a complete subset of your options:
++
++0.  `--copy-links` Turn all symlinks into normal files and directories
++    (leaving no symlinks in the transfer for any other options to affect).
++0.  `--copy-dirlinks` Turn just symlinks to directories into real
++    directories, leaving all other symlinks to be handled as described below.
++0.  `--links --copy-unsafe-links` Turn all unsafe symlinks
++    into files and create all safe symlinks.
++0.  `--copy-unsafe-links` Turn all unsafe symlinks into files, noisily
++    skip all safe symlinks.
++0.  `--links --safe-links` The receiver skips creating
++    unsafe symlinks found in the transfer and creates the safe ones.
++0.  `--links` Create all symlinks.
++
++For the effect of [`--munge-links`](#opt), see the discussion in that option's
++section.
++
++Note that the [`--keep-dirlinks`](#opt) option does not effect symlinks in the
++transfer but instead affects how rsync treats a symlink to a directory that
++already exists on the receiving side.  See that option's section for a warning.
++
++## DIAGNOSTICS
++
++Rsync occasionally produces error messages that may seem a little cryptic.  The
++one that seems to cause the most confusion is "protocol version mismatch -- is
++your shell clean?".
++
++This message is usually caused by your startup scripts or remote shell facility
++producing unwanted garbage on the stream that rsync is using for its transport.
++The way to diagnose this problem is to run your remote shell like this:
++
++>     ssh remotehost /bin/true > out.dat
++
++then look at out.dat.  If everything is working correctly then out.dat should
++be a zero length file.  If you are getting the above error from rsync then you
++will probably find that out.dat contains some text or data.  Look at the
++contents and try to work out what is producing it.  The most common cause is
++incorrectly configured shell startup scripts (such as .cshrc or .profile) that
++contain output statements for non-interactive logins.
++
++If you are having trouble debugging filter patterns, then try specifying the
++`-vv` option.  At this level of verbosity rsync will show why each individual
++file is included or excluded.
++
++## EXIT VALUES
++
++- **0** - Success
++- **1** - Syntax or usage error
++- **2** - Protocol incompatibility
++- **3** - Errors selecting input/output files, dirs
++- **4** - Requested action not supported. Either:
++  - an attempt was made to manipulate 64-bit files on a platform that cannot support them
++  - an option was specified that is supported by the client and not by the server
++- **5** - Error starting client-server protocol
++- **6** - Daemon unable to append to log-file
++- **10** - Error in socket I/O
++- **11** - Error in file I/O
++- **12** - Error in rsync protocol data stream
++- **13** - Errors with program diagnostics
++- **14** - Error in IPC code
++- **20** - Received SIGUSR1 or SIGINT
++- **21** - Some error returned by **waitpid()**
++- **22** - Error allocating core memory buffers
++- **23** - Partial transfer due to error
++- **24** - Partial transfer due to vanished source files
++- **25** - The --max-delete limit stopped deletions
++- **30** - Timeout in data send/receive
++- **35** - Timeout waiting for daemon connection
++
++## ENVIRONMENT VARIABLES
++
++0.  `CVSIGNORE`
++
++    The CVSIGNORE environment variable supplements any ignore patterns in
++    .cvsignore files.  See the [`--cvs-exclude`](#opt) option for more details.
++
++0.  `RSYNC_ICONV`
++
++    Specify a default [`--iconv`](#opt) setting using this environment
++    variable. First supported in 3.0.0.
++
++0.  `RSYNC_OLD_ARGS`
++
++    Specify a "1" if you want the [`--old-args`](#opt) option to be enabled by
++    default, a "2" (or more) if you want it to be enabled in the
++    repeated-option state, or a "0" to make sure that it is disabled by
++    default. When this environment variable is set to a non-zero value, it
++    supersedes the [`RSYNC_PROTECT_ARGS`](#) variable.
++
++    This variable is ignored if [`--old-args`](#opt), `--no-old-args`, or
++    [`--secluded-args`](#opt) is specified on the command line.
++
++    First supported in 3.2.4.
++
++0.  `RSYNC_PROTECT_ARGS`
++
++    Specify a non-zero numeric value if you want the [`--secluded-args`](#opt)
++    option to be enabled by default, or a zero value to make sure that it is
++    disabled by default.
++
++    This variable is ignored if [`--secluded-args`](#opt), `--no-secluded-args`,
++    or [`--old-args`](#opt) is specified on the command line.
++
++    First supported in 3.1.0.  Starting in 3.2.4, this variable is ignored if
++    [`RSYNC_OLD_ARGS`](#) is set to a non-zero value.
++
++0.  `RSYNC_RSH`
++
++    This environment variable allows you to override the default shell used as
++    the transport for rsync.  Command line options are permitted after the
++    command name, just as in the [`--rsh`](#opt) (`-e`) option.
++
++0.  `RSYNC_PROXY`
++
++    This environment variable allows you to redirect your rsync
++    client to use a web proxy when connecting to an rsync daemon.  You should
++    set `RSYNC_PROXY` to a hostname:port pair.
++
++0.  `RSYNC_PASSWORD`
++
++    This environment variable allows you to set the password for an rsync
++    **daemon** connection, which avoids the password prompt.  Note that this
++    does **not** supply a password to a remote shell transport such as ssh
++    (consult its documentation for how to do that).
++
++0.  `USER` or `LOGNAME`
++
++    The USER or LOGNAME environment variables are used to determine the default
++    username sent to an rsync daemon.  If neither is set, the username defaults
++    to "nobody".  If both are set, `USER` takes precedence.
++
++0. `RSYNC_PARTIAL_DIR`
++
++    This environment variable specifies the directory to use for a
++    [`--partial`](#opt) transfer without implying that partial transfers be
++    enabled.  See the [`--partial-dir`](#opt) option for full details.
++
++0. `RSYNC_COMPRESS_LIST`
++
++    This environment variable allows you to customize the negotiation of the
++    compression algorithm by specifying an alternate order or a reduced list of
++    names.  Use the command `rsync --version` to see the available compression
++    names.  See the [`--compress`](#opt) option for full details.
++
++0. `RSYNC_CHECKSUM_LIST`
++
++    This environment variable allows you to customize the negotiation of the
++    checksum algorithm by specifying an alternate order or a reduced list of
++    names.  Use the command `rsync --version` to see the available checksum
++    names.  See the [`--checksum-choice`](#opt) option for full details.
++
++0. `RSYNC_MAX_ALLOC`
++
++    This environment variable sets an allocation maximum as if you had used the
++    [`--max-alloc`](#opt) option.
++
++0. `RSYNC_PORT`
++
++    This environment variable is not read by rsync, but is instead set in
++    its sub-environment when rsync is running the remote shell in combination
++    with a daemon connection.  This allows a script such as
++    [`rsync-ssl`](rsync-ssl.1) to be able to know the port number that the user
++    specified on the command line.
++
++0.  `HOME`
++
++    This environment variable is used to find the user's default .cvsignore
++    file.
++
++0. `RSYNC_CONNECT_PROG`
++
++    This environment variable is mainly used in debug setups to set the program
++    to use when making a daemon connection.  See [CONNECTING TO AN RSYNC
++    DAEMON](#) for full details.
++
++0. `RSYNC_SHELL`
++
++    This environment variable is mainly used in debug setups to set the program
++    to use to run the program specified by [`RSYNC_CONNECT_PROG`](#).  See
++    [CONNECTING TO AN RSYNC DAEMON](#) for full details.
++
++## FILES
++
++/etc/rsyncd.conf or rsyncd.conf
++
++## SEE ALSO
++
++[**rsync-ssl**(1)](rsync-ssl.1), [**rsyncd.conf**(5)](rsyncd.conf.5), [**rrsync**(1)](rrsync.1)
++
++## BUGS
++
++- Times are transferred as \*nix time_t values.
++- When transferring to FAT filesystems rsync may re-sync unmodified files.  See
++  the comments on the [`--modify-window`](#opt) option.
++- File permissions, devices, etc. are transferred as native numerical values.
++- See also the comments on the [`--delete`](#opt) option.
++
++Please report bugs! See the web site at <https://rsync.samba.org/>.
++
++## VERSION
++
++This manpage is current for version @VERSION@ of rsync.
++
++## INTERNAL OPTIONS
++
++The options `--server` and `--sender` are used internally by rsync, and should
++never be typed by a user under normal circumstances.  Some awareness of these
++options may be needed in certain scenarios, such as when setting up a login
++that can only run an rsync command.  For instance, the support directory of the
++rsync distribution has an example script named rrsync (for restricted rsync)
++that can be used with a restricted ssh login.
++
++## CREDITS
++
++Rsync is distributed under the GNU General Public License.  See the file
++[COPYING](COPYING) for details.
++
++An rsync web site is available at <https://rsync.samba.org/>.  The site
++includes an FAQ-O-Matic which may cover questions unanswered by this manual
++page.
++
++The rsync github project is <https://github.com/WayneD/rsync>.
++
++We would be delighted to hear from you if you like this program.  Please
++contact the mailing-list at <rsync@lists.samba.org>.
++
++This program uses the excellent zlib compression library written by Jean-loup
++Gailly and Mark Adler.
++
++## THANKS
++
++Special thanks go out to: John Van Essen, Matt McCutchen, Wesley W. Terpstra,
++David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and our
++gone-but-not-forgotten compadre, J.W. Schultz.
++
++Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell and
++David Bell.  I've probably missed some people, my apologies if I have.
++
++## AUTHOR
++
++Rsync was originally written by Andrew Tridgell and Paul Mackerras.  Many
++people have later contributed to it. It is currently maintained by Wayne
++Davison.
++
++Mailing lists for support and development are available at
++<https://lists.samba.org/>.
+diff --git a/rsync.h b/rsync.h
+index d3709fe0..702be09b 100644
+--- a/rsync.h
++++ b/rsync.h
+@@ -175,6 +175,11 @@
+ #define COMPARE_DEST 1
+ #define COPY_DEST 2
+ #define LINK_DEST 3
++#define CLONE_DEST 4
++
++#if !defined FICLONE && defined __linux__
++#define FICLONE _IOW(0x94, 9, int)
++#endif
+ 
+ #define MPLEX_BASE 7
+ 
+@@ -286,7 +291,7 @@ enum filetype {
+ #define NDX_DEL_STATS -3
+ #define NDX_FLIST_OFFSET -101
+ 
+-/* For calling delete_item() and delete_dir_contents(). */
++/* For calling delete_item(), delete_dir_contents(), and delete_in_dir(). */
+ #define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
+ #define DEL_RECURSE		(1<<1) /* if dir, delete all contents */
+ #define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
+@@ -296,6 +301,7 @@ enum filetype {
+ #define DEL_FOR_DEVICE		(1<<6) /* making room for a replacement device */
+ #define DEL_FOR_SPECIAL 	(1<<7) /* making room for a replacement special */
+ #define DEL_FOR_BACKUP	 	(1<<8) /* the delete is for a backup operation */
++#define DEL_NO_DELETIONS	(1<<9) /* just check for renames w/o deleting */
+ 
+ #define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)
+ 
+diff --git a/rsync.h.orig b/rsync.h.orig
+new file mode 100644
+index 00000000..613591f4
+--- /dev/null
++++ b/rsync.h.orig
+@@ -0,0 +1,1491 @@
++/*
++ * Copyright (C) 1996, 2000 Andrew Tridgell
++ * Copyright (C) 1996 Paul Mackerras
++ * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
++ * Copyright (C) 2003-2022 Wayne Davison
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 3 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program; if not, visit the http://fsf.org website.
++ */
++
++#define False 0
++#define True 1
++#define Unset (-1) /* Our BOOL values are always an int. */
++
++#define BLOCK_SIZE 700
++#define RSYNC_RSH_ENV "RSYNC_RSH"
++#define RSYNC_RSH_IO_ENV "RSYNC_RSH_IO"
++
++#define RSYNC_NAME "rsync"
++/* RSYNCD_SYSCONF is now set in config.h */
++#define RSYNCD_USERCONF "rsyncd.conf"
++
++#define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
++#define URL_PREFIX "rsync://"
++
++#define SYMLINK_PREFIX "/rsyncd-munged/"  /* This MUST have a trailing slash! */
++#define SYMLINK_PREFIX_LEN ((int)sizeof SYMLINK_PREFIX - 1)
++
++#define BACKUP_SUFFIX "~"
++
++/* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is
++   incompatible with older versions :-( */
++#define CHAR_OFFSET 0
++
++/* These flags are only used during the flist transfer. */
++
++#define XMIT_TOP_DIR (1<<0)
++#define XMIT_SAME_MODE (1<<1)
++#define XMIT_SAME_RDEV_pre28 (1<<2)	/* protocols 20 - 27  */
++#define XMIT_EXTENDED_FLAGS (1<<2)	/* protocols 28 - now */
++#define XMIT_SAME_UID (1<<3)
++#define XMIT_SAME_GID (1<<4)
++#define XMIT_SAME_NAME (1<<5)
++#define XMIT_LONG_NAME (1<<6)
++#define XMIT_SAME_TIME (1<<7)
++
++#define XMIT_SAME_RDEV_MAJOR (1<<8)	/* protocols 28 - now (devices only) */
++#define XMIT_NO_CONTENT_DIR (1<<8)	/* protocols 30 - now (dirs only) */
++#define XMIT_HLINKED (1<<9)		/* protocols 28 - now (non-dirs) */
++#define XMIT_SAME_DEV_pre30 (1<<10)	/* protocols 28 - 29  */
++#define XMIT_USER_NAME_FOLLOWS (1<<10)	/* protocols 30 - now */
++#define XMIT_RDEV_MINOR_8_pre30 (1<<11) /* protocols 28 - 29  */
++#define XMIT_GROUP_NAME_FOLLOWS (1<<11) /* protocols 30 - now */
++#define XMIT_HLINK_FIRST (1<<12)	/* protocols 30 - now (HLINKED files only) */
++#define XMIT_IO_ERROR_ENDLIST (1<<12)	/* protocols 31*- now (w/XMIT_EXTENDED_FLAGS) (also protocol 30 w/'f' compat flag) */
++#define XMIT_MOD_NSEC (1<<13)		/* protocols 31 - now */
++#define XMIT_SAME_ATIME (1<<14) 	/* any protocol - restricted by command-line option */
++#define XMIT_UNUSED_15 (1<<15)  	/* unused flag bit */
++
++/* The following XMIT flags require an rsync that uses a varint for the flag values */
++
++#define XMIT_RESERVED_16 (1<<16) 	/* reserved for future fileflags use */
++#define XMIT_CRTIME_EQ_MTIME (1<<17)	/* any protocol - restricted by command-line option */
++
++/* These flags are used in the live flist data. */
++
++#define FLAG_TOP_DIR (1<<0)	/* sender/receiver/generator */
++#define FLAG_OWNED_BY_US (1<<0) /* generator: set by make_file() for aux flists only */
++#define FLAG_FILE_SENT (1<<1)	/* sender/receiver/generator */
++#define FLAG_DIR_CREATED (1<<1)	/* generator */
++#define FLAG_CONTENT_DIR (1<<2)	/* sender/receiver/generator */
++#define FLAG_MOUNT_DIR (1<<3)	/* sender/generator (dirs only) */
++#define FLAG_SKIP_HLINK (1<<3)	/* receiver/generator (w/FLAG_HLINKED) */
++#define FLAG_DUPLICATE (1<<4)	/* sender */
++#define FLAG_MISSING_DIR (1<<4)	/* generator */
++#define FLAG_HLINKED (1<<5)	/* receiver/generator (checked on all types) */
++#define FLAG_HLINK_FIRST (1<<6)	/* receiver/generator (w/FLAG_HLINKED) */
++#define FLAG_IMPLIED_DIR (1<<6)	/* sender/receiver/generator (dirs only) */
++#define FLAG_HLINK_LAST (1<<7)	/* receiver/generator */
++#define FLAG_HLINK_DONE (1<<8)	/* receiver/generator (checked on all types) */
++#define FLAG_LENGTH64 (1<<9)	/* sender/receiver/generator */
++#define FLAG_SKIP_GROUP (1<<10)	/* receiver/generator */
++#define FLAG_TIME_FAILED (1<<11)/* generator */
++#define FLAG_MOD_NSEC (1<<12)	/* sender/receiver/generator */
++
++/* These flags are passed to functions but not stored. */
++
++#define FLAG_DIVERT_DIRS (1<<16)   /* sender, but must be unique */
++#define FLAG_PERHAPS_DIR (1<<17)   /* generator */
++
++/* These flags are for get_dirlist(). */
++#define GDL_IGNORE_FILTER_RULES (1<<0)
++#define GDL_PERHAPS_DIR (1<<1)
++
++/* Some helper macros for matching bits. */
++#define BITS_SET(val,bits) (((val) & (bits)) == (bits))
++#define BITS_SETnUNSET(val,onbits,offbits) (((val) & ((onbits)|(offbits))) == (onbits))
++#define BITS_EQUAL(b1,b2,mask) (((unsigned)(b1) & (unsigned)(mask)) \
++			     == ((unsigned)(b2) & (unsigned)(mask)))
++
++/* Update this if you make incompatible changes and ALSO update the
++ * SUBPROTOCOL_VERSION if it is not a final (official) release. */
++#define PROTOCOL_VERSION 31
++
++/* This is used when working on a new protocol version or for any unofficial
++ * protocol tweaks.  It should be a non-zero value for each pre-release repo
++ * change that affects the protocol. The official pre-release versions should
++ * start with 1 (after incrementing the PROTOCOL_VERSION) and go up by 1 for
++ * each new protocol change.  For unofficial changes, pick a fairly large
++ * random number that will hopefully not collide with anyone else's unofficial
++ * protocol.  It must ALWAYS be 0 when the protocol goes final (and official)
++ * and NEVER before!  When rsync negotiates a protocol match, it will only
++ * allow the newest protocol to be used if the SUBPROTOCOL_VERSION matches.
++ * All older protocol versions MUST be compatible with the final, official
++ * release of the protocol, so don't tweak the code to change the protocol
++ * behavior for an older protocol version. */
++#define SUBPROTOCOL_VERSION 0
++
++/* We refuse to interoperate with versions that are not in this range.
++ * Note that we assume we'll work with later versions: the onus is on
++ * people writing them to make sure that they don't send us anything
++ * we won't understand.
++ *
++ * Interoperation with old but supported protocol versions
++ * should cause a warning to be printed.  At a future date
++ * the old protocol will become the minimum and
++ * compatibility code removed.
++ *
++ * There are two possible explanations for the limit at
++ * MAX_PROTOCOL_VERSION: either to allow new major-rev versions that
++ * do not interoperate with us, and (more likely) so that we can
++ * detect an attempt to connect rsync to a non-rsync server, which is
++ * unlikely to begin by sending a byte between MIN_PROTOCL_VERSION and
++ * MAX_PROTOCOL_VERSION. */
++
++#define MIN_PROTOCOL_VERSION 20
++#define OLD_PROTOCOL_VERSION 25
++#define MAX_PROTOCOL_VERSION 40
++
++#define MIN_FILECNT_LOOKAHEAD 1000
++#define MAX_FILECNT_LOOKAHEAD 10000
++
++#define RSYNC_PORT 873
++
++#define SPARSE_WRITE_SIZE (1024)
++#define WRITE_SIZE (32*1024)
++#define CHUNK_SIZE (32*1024)
++#define MAX_MAP_SIZE (256*1024)
++#define IO_BUFFER_SIZE (32*1024)
++#define MAX_BLOCK_SIZE ((int32)1 << 17)
++
++/* For compatibility with older rsyncs */
++#define OLD_MAX_BLOCK_SIZE ((int32)1 << 29)
++
++#define ROUND_UP_1024(siz) ((siz) & (1024-1) ? ((siz) | (1024-1)) + 1 : (siz))
++
++#define IOERR_GENERAL	(1<<0) /* For backward compatibility, this must == 1 */
++#define IOERR_VANISHED	(1<<1)
++#define IOERR_DEL_LIMIT (1<<2)
++
++#define MAX_ARGS 1000
++#define MAX_BASIS_DIRS 20
++#define MAX_SERVER_ARGS (MAX_BASIS_DIRS*2 + 100)
++
++#define COMPARE_DEST 1
++#define COPY_DEST 2
++#define LINK_DEST 3
++#define CLONE_DEST 4
++
++#if !defined FICLONE && defined __linux__
++#define FICLONE _IOW(0x94, 9, int)
++#endif
++
++#define MPLEX_BASE 7
++
++#define NO_FILTERS	0
++#define SERVER_FILTERS	1
++#define ALL_FILTERS	2
++
++#define XFLG_FATAL_ERRORS	(1<<0)
++#define XFLG_OLD_PREFIXES	(1<<1)
++#define XFLG_ANCHORED2ABS	(1<<2) /* leading slash indicates absolute */
++#define XFLG_ABS_IF_SLASH	(1<<3) /* leading or interior slash is absolute */
++#define XFLG_DIR2WILD3		(1<<4) /* dir/ match gets trailing *** added */
++
++#define ATTRS_REPORT		(1<<0)
++#define ATTRS_SKIP_MTIME	(1<<1)
++#define ATTRS_ACCURATE_TIME	(1<<2)
++#define ATTRS_SKIP_ATIME	(1<<3)
++#define ATTRS_SKIP_CRTIME	(1<<5)
++
++#define MSG_FLUSH	2
++#define FULL_FLUSH	1
++#define NORMAL_FLUSH	0
++
++#define PDIR_CREATE	1
++#define PDIR_DELETE	0
++
++/* Note: 0x00 - 0x7F are used for basis_dir[] indexes! */
++#define FNAMECMP_BASIS_DIR_LOW	0x00 /* Must remain 0! */
++#define FNAMECMP_BASIS_DIR_HIGH 0x7F
++#define FNAMECMP_FNAME		0x80
++#define FNAMECMP_PARTIAL_DIR	0x81
++#define FNAMECMP_BACKUP 	0x82
++#define FNAMECMP_FUZZY		0x83
++
++/* For use by the itemize_changes code */
++#define ITEM_REPORT_ATIME (1<<0)
++#define ITEM_REPORT_CHANGE (1<<1)
++#define ITEM_REPORT_SIZE (1<<2)     /* regular files only */
++#define ITEM_REPORT_TIMEFAIL (1<<2) /* symlinks only */
++#define ITEM_REPORT_TIME (1<<3)
++#define ITEM_REPORT_PERMS (1<<4)
++#define ITEM_REPORT_OWNER (1<<5)
++#define ITEM_REPORT_GROUP (1<<6)
++#define ITEM_REPORT_ACL (1<<7)
++#define ITEM_REPORT_XATTR (1<<8)
++#define ITEM_REPORT_CRTIME (1<<10)
++#define ITEM_BASIS_TYPE_FOLLOWS (1<<11)
++#define ITEM_XNAME_FOLLOWS (1<<12)
++#define ITEM_IS_NEW (1<<13)
++#define ITEM_LOCAL_CHANGE (1<<14)
++#define ITEM_TRANSFER (1<<15)
++/* These are outside the range of the transmitted flags. */
++#define ITEM_MISSING_DATA (1<<16)	   /* used by log_formatted() */
++#define ITEM_DELETED (1<<17)		   /* used by log_formatted() */
++#define ITEM_MATCHED (1<<18)		   /* used by itemize() */
++
++#define SIGNIFICANT_ITEM_FLAGS (~(\
++	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
++
++#define CFN_KEEP_DOT_DIRS (1<<0)
++#define CFN_KEEP_TRAILING_SLASH (1<<1)
++#define CFN_DROP_TRAILING_DOT_DIR (1<<2)
++#define CFN_COLLAPSE_DOT_DOT_DIRS (1<<3)
++#define CFN_REFUSE_DOT_DOT_DIRS (1<<4)
++
++#define SP_DEFAULT 0
++#define SP_KEEP_DOT_DIRS (1<<0)
++
++#define CD_NORMAL 0
++#define CD_SKIP_CHDIR 1
++
++/* Log-message categories.  FLOG only goes to the log file, not the client;
++ * FCLIENT is the opposite. */
++enum logcode {
++    FNONE=0, /* never sent */
++    FERROR_XFER=1, FINFO=2, /* sent over socket for any protocol */
++    FERROR=3, FWARNING=4, /* sent over socket for protocols >= 30 */
++    FERROR_SOCKET=5, FLOG=6, /* only sent via receiver -> generator pipe */
++    FERROR_UTF8=8, /* only sent via receiver -> generator pipe */
++    FCLIENT=7 /* never transmitted (e.g. server converts to FINFO) */
++};
++
++/* Messages types that are sent over the message channel.  The logcode
++ * values must all be present here with identical numbers. */
++enum msgcode {
++	MSG_DATA=0,	/* raw data on the multiplexed stream */
++	MSG_ERROR_XFER=FERROR_XFER, MSG_INFO=FINFO, /* remote logging */
++	MSG_ERROR=FERROR, MSG_WARNING=FWARNING, /* protocol-30 remote logging */
++	MSG_ERROR_SOCKET=FERROR_SOCKET, /* sibling logging */
++	MSG_ERROR_UTF8=FERROR_UTF8, /* sibling logging */
++	MSG_LOG=FLOG, MSG_CLIENT=FCLIENT, /* sibling logging */
++	MSG_REDO=9,	/* reprocess indicated flist index */
++	MSG_STATS=10,	/* message has stats data for generator */
++	MSG_IO_ERROR=22,/* the sending side had an I/O error */
++	MSG_IO_TIMEOUT=33,/* tell client about a daemon's timeout value */
++	MSG_NOOP=42,	/* a do-nothing message (legacy protocol-30 only) */
++	MSG_ERROR_EXIT=86, /* synchronize an error exit (siblings and protocol >= 31) */
++	MSG_SUCCESS=100,/* successfully updated indicated flist index */
++	MSG_DELETED=101,/* successfully deleted a file on receiving side */
++	MSG_NO_SEND=102,/* sender failed to open a file we wanted */
++};
++
++enum filetype {
++	FT_UNSUPPORTED, FT_REG, FT_DIR, FT_SYMLINK, FT_SPECIAL, FT_DEVICE
++};
++
++#define NDX_DONE -1
++#define NDX_FLIST_EOF -2
++#define NDX_DEL_STATS -3
++#define NDX_FLIST_OFFSET -101
++
++/* For calling delete_item() and delete_dir_contents(). */
++#define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
++#define DEL_RECURSE		(1<<1) /* if dir, delete all contents */
++#define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
++#define DEL_FOR_FILE		(1<<3) /* making room for a replacement file */
++#define DEL_FOR_DIR		(1<<4) /* making room for a replacement dir */
++#define DEL_FOR_SYMLINK 	(1<<5) /* making room for a replacement symlink */
++#define DEL_FOR_DEVICE		(1<<6) /* making room for a replacement device */
++#define DEL_FOR_SPECIAL 	(1<<7) /* making room for a replacement special */
++#define DEL_FOR_BACKUP	 	(1<<8) /* the delete is for a backup operation */
++
++#define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)
++
++enum delret {
++	DR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY
++};
++
++/* Defines for make_path() */
++#define MKP_DROP_NAME		(1<<0) /* drop trailing filename or trailing slash */
++#define MKP_SKIP_SLASH		(1<<1) /* skip one or more leading slashes */
++
++/* Defines for maybe_send_keepalive() */
++#define MSK_ALLOW_FLUSH 	(1<<0)
++#define MSK_ACTIVE_RECEIVER 	(1<<1)
++
++#include "errcode.h"
++
++#include "config.h"
++
++/* The default RSYNC_RSH is always set in config.h. */
++
++#include <stdio.h>
++#ifdef HAVE_SYS_TYPES_H
++# include <sys/types.h>
++#endif
++#ifdef HAVE_SYS_STAT_H
++# include <sys/stat.h>
++#endif
++#ifdef STDC_HEADERS
++# include <stdlib.h>
++# include <stddef.h>
++#else
++# ifdef HAVE_STDLIB_H
++#  include <stdlib.h>
++# endif
++#endif
++#ifdef HAVE_STRING_H
++# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
++#  include <memory.h>
++# endif
++# include <string.h>
++#endif
++#ifdef HAVE_BSD_STRING_H
++# include <bsd/string.h>
++#endif
++#ifdef HAVE_STRINGS_H
++# include <strings.h>
++#endif
++#ifdef HAVE_INTTYPES_H
++# include <inttypes.h>
++#endif
++#ifdef HAVE_STDINT_H
++# include <stdint.h>
++#endif
++#ifdef HAVE_UNISTD_H
++# include <unistd.h>
++#endif
++
++#ifdef HAVE_SYS_PARAM_H
++#include <sys/param.h>
++#endif
++
++#if defined HAVE_MALLOC_H && (defined HAVE_MALLINFO || !defined HAVE_STDLIB_H)
++#include <malloc.h>
++#endif
++
++#ifdef HAVE_SYS_SOCKET_H
++#include <sys/socket.h>
++#endif
++
++#ifdef HAVE_SYS_TIME_H
++#include <sys/time.h>
++#endif
++#include <time.h>
++
++#ifdef HAVE_FCNTL_H
++#include <fcntl.h>
++#else
++#ifdef HAVE_SYS_FCNTL_H
++#include <sys/fcntl.h>
++#endif
++#endif
++
++#ifdef HAVE_SYS_IOCTL_H
++#include <sys/ioctl.h>
++#endif
++
++#ifdef HAVE_SYS_FILIO_H
++#include <sys/filio.h>
++#endif
++
++#include <signal.h>
++#ifdef HAVE_SYS_WAIT_H
++#include <sys/wait.h>
++#endif
++#ifdef HAVE_CTYPE_H
++#include <ctype.h>
++#endif
++#ifdef HAVE_GRP_H
++#include <grp.h>
++#endif
++#include <errno.h>
++
++#ifdef HAVE_UTIME_H
++#include <utime.h>
++#endif
++
++#if defined HAVE_UTIMENSAT || defined HAVE_LUTIMES || defined HAVE_SETATTRLIST
++#define CAN_SET_SYMLINK_TIMES 1
++#endif
++
++#if defined HAVE_LCHOWN || defined CHOWN_MODIFIES_SYMLINK
++#define CAN_CHOWN_SYMLINK 1
++#endif
++
++#if defined HAVE_LCHMOD || defined HAVE_SETATTRLIST
++#define CAN_CHMOD_SYMLINK 1
++#endif
++
++#if defined HAVE_UTIMENSAT || defined HAVE_SETATTRLIST
++#define CAN_SET_NSEC 1
++#endif
++
++#ifdef CAN_SET_NSEC
++#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
++#define ST_MTIME_NSEC st_mtim.tv_nsec
++#define ST_ATIME_NSEC st_atim.tv_nsec
++#elif defined(HAVE_STRUCT_STAT_ST_MTIMENSEC)
++#define ST_MTIME_NSEC st_mtimensec
++#define ST_ATIME_NSEC st_atimensec
++#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC)
++#define ST_MTIME_NSEC st_mtimespec.tv_nsec
++#define ST_ATIME_NSEC st_atimespec.tv_nsec
++#endif
++#endif
++
++#ifdef HAVE_SYS_SELECT_H
++#include <sys/select.h>
++#endif
++
++#ifdef HAVE_SYS_MODE_H
++/* apparently AIX needs this for S_ISLNK */
++#ifndef S_ISLNK
++#include <sys/mode.h>
++#endif
++#endif
++
++/* these are needed for the uid/gid mapping code */
++#include <pwd.h>
++#include <grp.h>
++
++#include <stdarg.h>
++#include <netinet/in.h>
++#include <arpa/inet.h>
++#ifdef HAVE_NETDB_H
++#include <netdb.h>
++#endif
++#include <syslog.h>
++#ifdef HAVE_SYS_FILE_H
++#include <sys/file.h>
++#endif
++
++#ifdef HAVE_DIRENT_H
++# include <dirent.h>
++#else
++# define dirent direct
++# ifdef HAVE_SYS_NDIR_H
++#  include <sys/ndir.h>
++# endif
++# ifdef HAVE_SYS_DIR_H
++#  include <sys/dir.h>
++# endif
++# ifdef HAVE_NDIR_H
++#  include <ndir.h>
++# endif
++#endif
++
++#ifdef MAJOR_IN_MKDEV
++#include <sys/mkdev.h>
++# if !defined makedev && (defined mkdev || defined _WIN32 || defined __WIN32__)
++#  define makedev mkdev
++# endif
++#elif defined MAJOR_IN_SYSMACROS
++#include <sys/sysmacros.h>
++#endif
++
++#ifdef MAKEDEV_TAKES_3_ARGS
++#define MAKEDEV(devmajor,devminor) makedev(0,devmajor,devminor)
++#else
++#ifndef __TANDEM
++#define MAKEDEV(devmajor,devminor) makedev(devmajor,devminor)
++#else
++# define major DEV_TO_MAJOR
++# define minor DEV_TO_MINOR
++# define MAKEDEV MAJORMINOR_TO_DEV
++#endif
++#endif
++
++#ifdef __TANDEM
++# include <floss.h(floss_read,floss_write,floss_fork,floss_execvp)>
++# include <floss.h(floss_getpwuid,floss_select,floss_seteuid)>
++# define S_IEXEC S_IXUSR
++# define ROOT_UID 65535
++#else
++# define ROOT_UID 0
++#endif
++
++#ifdef HAVE_COMPAT_H
++#include <compat.h>
++#endif
++
++#ifdef HAVE_LIMITS_H
++# include <limits.h>
++#endif
++
++#if defined USE_ICONV_OPEN && defined HAVE_ICONV_H
++#include <iconv.h>
++#ifndef ICONV_CONST
++#define ICONV_CONST
++#endif
++#else
++#ifdef ICONV_CONST
++#undef ICONV_CONST
++#endif
++#ifdef ICONV_OPTION
++#undef ICONV_OPTION
++#endif
++#ifdef iconv_t
++#undef iconv_t
++#endif
++#define iconv_t int
++#endif
++
++#include <assert.h>
++
++#include "lib/pool_alloc.h"
++
++#ifndef HAVE_ID_T
++typedef unsigned int id_t;
++#endif
++#ifndef HAVE_PID_T
++typedef int pid_t;
++#endif
++#ifndef HAVE_MODE_T
++typedef unsigned int mode_t;
++#endif
++#ifndef HAVE_OFF_T
++typedef long off_t;
++#undef SIZEOF_OFF_T
++#define SIZEOF_OFF_T SIZEOF_LONG
++#endif
++#ifndef HAVE_SIZE_T
++typedef unsigned int size_t;
++#endif
++
++#define BOOL int
++
++#ifndef uchar
++#define uchar unsigned char
++#endif
++
++#ifdef SIGNED_CHAR_OK
++#define schar signed char
++#else
++#define schar char
++#endif
++
++#ifndef int16
++#if SIZEOF_INT16_T == 2
++# define int16 int16_t
++#else
++# define int16 short
++#endif
++#endif
++
++#ifndef uint16
++#if SIZEOF_UINT16_T == 2
++# define uint16 uint16_t
++#else
++# define uint16 unsigned int16
++#endif
++#endif
++
++#if !defined __APPLE__ || defined HAVE_GETATTRLIST
++#define SUPPORT_ATIMES 1
++#endif
++
++#if defined HAVE_GETATTRLIST || defined __CYGWIN__
++#define SUPPORT_CRTIMES 1
++#endif
++
++/* Find a variable that is either exactly 32-bits or longer.
++ * If some code depends on 32-bit truncation, it will need to
++ * take special action in a "#if SIZEOF_INT32 > 4" section. */
++#ifndef int32
++#if SIZEOF_INT32_T == 4
++# define int32 int32_t
++# define SIZEOF_INT32 4
++#elif SIZEOF_INT == 4
++# define int32 int
++# define SIZEOF_INT32 4
++#elif SIZEOF_LONG == 4
++# define int32 long
++# define SIZEOF_INT32 4
++#elif SIZEOF_SHORT == 4
++# define int32 short
++# define SIZEOF_INT32 4
++#elif SIZEOF_INT > 4
++# define int32 int
++# define SIZEOF_INT32 SIZEOF_INT
++#elif SIZEOF_LONG > 4
++# define int32 long
++# define SIZEOF_INT32 SIZEOF_LONG
++#else
++# error Could not find a 32-bit integer variable
++#endif
++#else
++# define SIZEOF_INT32 4
++#endif
++
++#ifndef uint32
++#if SIZEOF_UINT32_T == 4
++# define uint32 uint32_t
++#else
++# define uint32 unsigned int32
++#endif
++#endif
++
++#if SIZEOF_OFF_T == 8 || !SIZEOF_OFF64_T || !defined HAVE_STRUCT_STAT64
++#define OFF_T off_t
++#define STRUCT_STAT struct stat
++#define SIZEOF_CAPITAL_OFF_T SIZEOF_OFF_T
++#else
++#define OFF_T off64_t
++#define STRUCT_STAT struct stat64
++#define USE_STAT64_FUNCS 1
++#define SIZEOF_CAPITAL_OFF_T SIZEOF_OFF64_T
++#endif
++
++/* CAVEAT: on some systems, int64 will really be a 32-bit integer IFF
++ * that's the maximum size the file system can handle and there is no
++ * 64-bit type available.  The rsync source must therefore take steps
++ * to ensure that any code that really requires a 64-bit integer has
++ * it (e.g. the checksum code uses two 32-bit integers for its 64-bit
++ * counter). */
++#if SIZEOF_INT64_T == 8
++# define int64 int64_t
++# define SIZEOF_INT64 8
++#elif SIZEOF_LONG == 8
++# define int64 long
++# define SIZEOF_INT64 8
++#elif SIZEOF_INT == 8
++# define int64 int
++# define SIZEOF_INT64 8
++#elif SIZEOF_LONG_LONG == 8
++# define int64 long long
++# define SIZEOF_INT64 8
++#elif SIZEOF_OFF64_T == 8
++# define int64 off64_t
++# define SIZEOF_INT64 8
++#elif SIZEOF_OFF_T == 8
++# define int64 off_t
++# define SIZEOF_INT64 8
++#elif SIZEOF_INT > 8
++# define int64 int
++# define SIZEOF_INT64 SIZEOF_INT
++#elif SIZEOF_LONG > 8
++# define int64 long
++# define SIZEOF_INT64 SIZEOF_LONG
++#elif SIZEOF_LONG_LONG > 8
++# define int64 long long
++# define SIZEOF_INT64 SIZEOF_LONG_LONG
++#else
++/* As long as it gets... */
++# define int64 off_t
++# define SIZEOF_INT64 SIZEOF_OFF_T
++#endif
++
++#define HT_KEY32 0
++#define HT_KEY64 1
++
++struct hashtable {
++	void *nodes;
++	int32 size, entries;
++	uint32 node_size;
++	short key64;
++};
++
++struct ht_int32_node {
++	void *data;
++	int32 key;
++};
++
++struct ht_int64_node {
++	void *data;
++	int64 key;
++};
++
++#define HT_NODE(tbl, bkts, i) ((void*)((char*)(bkts) + (i)*(tbl)->node_size))
++#define HT_KEY(node, k64) ((k64)? ((struct ht_int64_node*)(node))->key \
++			 : (int64)((struct ht_int32_node*)(node))->key)
++
++#ifndef MIN
++#define MIN(a,b) ((a)<(b)?(a):(b))
++#endif
++
++#ifndef MAX
++#define MAX(a,b) ((a)>(b)?(a):(b))
++#endif
++
++#ifndef MAXHOSTNAMELEN
++#define MAXHOSTNAMELEN 256
++#endif
++
++#define SUM_LENGTH 16
++#define SHORT_SUM_LENGTH 2
++#define BLOCKSUM_BIAS 10
++
++#ifndef MAXPATHLEN
++#define MAXPATHLEN 1024
++#endif
++
++/* We want a roomy line buffer that can hold more than MAXPATHLEN,
++ * and significantly more than an overly short MAXPATHLEN. */
++#if MAXPATHLEN < 4096
++#define BIGPATHBUFLEN (4096+1024)
++#else
++#define BIGPATHBUFLEN (MAXPATHLEN+1024)
++#endif
++
++#ifndef NAME_MAX
++#define NAME_MAX 255
++#endif
++
++#ifndef SIZE_MAX
++#define SIZE_MAX ((size_t)-1)
++#endif
++
++#ifndef INADDR_NONE
++#define INADDR_NONE 0xffffffff
++#endif
++
++#ifndef IN_LOOPBACKNET
++#define IN_LOOPBACKNET 127
++#endif
++
++#if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
++#define ACLS_NEED_MASK 1
++#endif
++
++#if defined HAVE_FALLOCATE || HAVE_SYS_FALLOCATE
++#ifdef HAVE_LINUX_FALLOC_H
++#include <linux/falloc.h>
++#endif
++#ifdef FALLOC_FL_KEEP_SIZE
++#define SUPPORT_PREALLOCATION 1
++#elif defined HAVE_FTRUNCATE
++#define SUPPORT_PREALLOCATION 1
++#define PREALLOCATE_NEEDS_TRUNCATE 1
++#endif
++#else /* !fallocate */
++#if defined HAVE_EFFICIENT_POSIX_FALLOCATE && defined HAVE_FTRUNCATE
++#define SUPPORT_PREALLOCATION 1
++#define PREALLOCATE_NEEDS_TRUNCATE 1
++#endif
++#endif
++
++#if SIZEOF_CHARP == 4
++# define PTRS_ARE_32 1
++# define PTR_EXTRA_CNT 1
++#elif SIZEOF_CHARP == 8
++# define PTRS_ARE_64 1
++# define PTR_EXTRA_CNT EXTRA64_CNT
++#else
++# error Character pointers are not 4 or 8 bytes.
++#endif
++
++#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
++#define USE_FLEXIBLE_ARRAY 1
++#define SIZE_T_FMT_MOD "z" /* printf supports %zd */
++#define SIZE_T_FMT_CAST size_t
++#else
++#define SIZE_T_FMT_MOD "l" /* printf supports %ld */
++#define SIZE_T_FMT_CAST long
++#endif
++
++union file_extras {
++	int32 num;
++	uint32 unum;
++#ifdef PTRS_ARE_32
++	const char* ptr;
++#endif
++};
++
++union file_extras64 {
++	int64 num;
++#ifdef PTRS_ARE_64
++	const char* ptr;
++#endif
++};
++
++struct file_struct {
++	const char *dirname;	/* The dir info inside the transfer */
++	time_t modtime;		/* When the item was last modified */
++	uint32 len32;		/* Lowest 32 bits of the file's length */
++	uint16 mode;		/* The item's type and permissions */
++	uint16 flags;		/* The FLAG_* bits for this item */
++#ifdef USE_FLEXIBLE_ARRAY
++	const char basename[];	/* The basename (AKA filename) follows */
++#else
++	const char basename[1];	/* A kluge that should work like a flexible array */
++#endif
++};
++
++extern int file_extra_cnt;
++extern int inc_recurse;
++extern int atimes_ndx;
++extern int crtimes_ndx;
++extern int pathname_ndx;
++extern int depth_ndx;
++extern int uid_ndx;
++extern int gid_ndx;
++extern int acls_ndx;
++extern int xattrs_ndx;
++extern int file_sum_extra_cnt;
++
++#ifdef USE_FLEXIBLE_ARRAY
++#define FILE_STRUCT_LEN (sizeof (struct file_struct))
++#else
++#define FILE_STRUCT_LEN (offsetof(struct file_struct, basename))
++#endif
++#define EXTRA_LEN (sizeof (union file_extras))
++#define DEV_EXTRA_CNT 2
++#define DIRNODE_EXTRA_CNT 3
++#define EXTRA64_CNT ((sizeof (union file_extras64) + EXTRA_LEN - 1) / EXTRA_LEN)
++#define SUM_EXTRA_CNT file_sum_extra_cnt
++
++#define REQ_EXTRA(f,ndx) ((union file_extras*)(f) - (ndx))
++#define OPT_EXTRA(f,bump) ((union file_extras*)(f) - file_extra_cnt - 1 - (bump))
++
++/* These are guaranteed to be allocated first in the array so that they
++ * are aligned for direct int64-pointer access. */
++#define REQ_EXTRA64(f,ndx) ((union file_extras64*)REQ_EXTRA(f,ndx))
++
++#define NSEC_BUMP(f) ((f)->flags & FLAG_MOD_NSEC ? 1 : 0)
++#define LEN64_BUMP(f) ((f)->flags & FLAG_LENGTH64 ? 1 : 0)
++#define START_BUMP(f) (NSEC_BUMP(f) + LEN64_BUMP(f))
++#define HLINK_BUMP(f) ((f)->flags & (FLAG_HLINKED|FLAG_HLINK_DONE) ? inc_recurse+1 : 0)
++#define ACL_BUMP(f) (acls_ndx ? 1 : 0)
++
++/* The length applies to all items. */
++#if SIZEOF_INT64 < 8
++#define F_LENGTH(f) ((int64)(f)->len32)
++#else
++#define F_HIGH_LEN(f) (OPT_EXTRA(f, NSEC_BUMP(f))->unum)
++#define F_LENGTH(f) ((int64)(f)->len32 + ((f)->flags & FLAG_LENGTH64 ? (int64)F_HIGH_LEN(f) << 32 : 0))
++#endif
++
++#define F_MOD_NSEC(f) OPT_EXTRA(f, 0)->unum
++#define F_MOD_NSEC_or_0(f) ((f)->flags & FLAG_MOD_NSEC ? F_MOD_NSEC(f) : 0)
++
++/* If there is a symlink string, it is always right after the basename */
++#define F_SYMLINK(f) ((f)->basename + strlen((f)->basename) + 1)
++
++/* The sending side always has this available: */
++#ifdef PTRS_ARE_32
++#define F_PATHNAME(f) REQ_EXTRA(f, pathname_ndx)->ptr
++#else
++#define F_PATHNAME(f) REQ_EXTRA64(f, pathname_ndx)->ptr
++#endif
++
++/* The receiving side always has this available: */
++#define F_DEPTH(f) REQ_EXTRA(f, depth_ndx)->num
++
++/* When the associated option is on, all entries will have these present: */
++#define F_OWNER(f) REQ_EXTRA(f, uid_ndx)->unum
++#define F_GROUP(f) REQ_EXTRA(f, gid_ndx)->unum
++#define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num
++#define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num
++#define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num
++#define F_ATIME(f) REQ_EXTRA64(f, atimes_ndx)->num
++#define F_CRTIME(f) REQ_EXTRA64(f, crtimes_ndx)->num
++
++/* These items are per-entry optional: */
++#define F_HL_GNUM(f) OPT_EXTRA(f, START_BUMP(f))->num /* non-dirs */
++#define F_HL_PREV(f) OPT_EXTRA(f, START_BUMP(f)+inc_recurse)->num /* non-dirs */
++#define F_DIR_NODE_P(f) (&OPT_EXTRA(f, START_BUMP(f) \
++				+ DIRNODE_EXTRA_CNT - 1)->num) /* sender dirs */
++#define F_DIR_RELNAMES_P(f) (&OPT_EXTRA(f, START_BUMP(f) + DIRNODE_EXTRA_CNT \
++				+ PTR_EXTRA_CNT - 1)->num) /* sender dirs */
++#define F_DIR_DEFACL(f) OPT_EXTRA(f, START_BUMP(f))->unum /* receiver dirs */
++#define F_DIR_DEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + ACL_BUMP(f) \
++				+ DEV_EXTRA_CNT - 1)->unum) /* receiver dirs */
++
++/* This optional item might follow an F_HL_*() item. */
++#define F_RDEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) + DEV_EXTRA_CNT - 1)->unum)
++
++/* The sum is only present on regular files. */
++#define F_SUM(f) ((char*)OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) \
++				    + SUM_EXTRA_CNT - 1))
++
++/* Some utility defines: */
++#define F_IS_ACTIVE(f) (f)->basename[0]
++#define F_IS_HLINKED(f) ((f)->flags & FLAG_HLINKED)
++
++#define F_HLINK_NOT_FIRST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_FIRST)
++#define F_HLINK_NOT_LAST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_LAST)
++
++/* These access the F_DIR_DEV_P() and F_RDEV_P() values: */
++#define DEV_MAJOR(a) (a)[0]
++#define DEV_MINOR(a) (a)[1]
++
++/* These access the F_DIRS_NODE_P() values: */
++#define DIR_PARENT(a) (a)[0]
++#define DIR_FIRST_CHILD(a) (a)[1]
++#define DIR_NEXT_SIBLING(a) (a)[2]
++
++#define IS_MISSING_FILE(statbuf) ((statbuf).st_mode == 0)
++
++/*
++ * Start the flist array at FLIST_START entries and grow it
++ * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR
++ */
++#define FLIST_START		(32)
++#define FLIST_START_LARGE	(32 * 1024)
++#define FLIST_LINEAR		(FLIST_START_LARGE * 512)
++
++/*
++ * Extent size for allocation pools: A minimum size of 128KB
++ * is needed to mmap them so that freeing will release the
++ * space to the OS.
++ *
++ * Larger sizes reduce leftover fragments and speed free calls
++ * (when they happen). Smaller sizes increase the chance of
++ * freed allocations freeing whole extents.
++ */
++#define NORMAL_EXTENT	(256 * 1024)
++#define SMALL_EXTENT	(128 * 1024)
++
++#define FLIST_TEMP	(1<<1)
++
++struct file_list {
++	struct file_list *next, *prev;
++	struct file_struct **files, **sorted;
++	alloc_pool_t file_pool;
++	void *pool_boundary;
++	int used, malloced;
++	int low, high;  /* 0-relative index values excluding empties */
++	int ndx_start;  /* the start offset for inc_recurse mode */
++	int flist_num;  /* 1-relative file_list number or 0 */
++	int parent_ndx; /* dir_flist index of parent directory */
++	int in_progress, to_redo;
++};
++
++#define SUMFLG_SAME_OFFSET	(1<<0)
++
++struct sum_buf {
++	OFF_T offset;		/**< offset in file of this chunk */
++	int32 len;		/**< length of chunk of file */
++	uint32 sum1;	        /**< simple checksum */
++	int32 chain;		/**< next hash-table collision */
++	short flags;		/**< flag bits */
++	char sum2[SUM_LENGTH];	/**< checksum  */
++};
++
++struct sum_struct {
++	OFF_T flength;		/**< total file length */
++	struct sum_buf *sums;	/**< points to info for each chunk */
++	int32 count;		/**< how many chunks */
++	int32 blength;		/**< block_length */
++	int32 remainder;	/**< flength % block_length */
++	int s2length;		/**< sum2_length */
++};
++
++struct map_struct {
++	OFF_T file_size;	/* File size (from stat)		*/
++	OFF_T p_offset;		/* Window start				*/
++	OFF_T p_fd_offset;	/* offset of cursor in fd ala lseek	*/
++	char *p;		/* Window pointer			*/
++	int32 p_size;		/* Largest window size we allocated	*/
++	int32 p_len;		/* Latest (rounded) window size		*/
++	int32 def_window_size;	/* Default window size			*/
++	int fd;			/* File Descriptor			*/
++	int status;		/* first errno from read errors		*/
++};
++
++#define NAME_IS_FILE		(0)    /* filter name as a file */
++#define NAME_IS_DIR		(1<<0) /* filter name as a dir */
++#define NAME_IS_XATTR		(1<<2) /* filter name as an xattr */
++
++#define FILTRULE_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
++#define FILTRULE_WILD2		(1<<1) /* pattern has '**' */
++#define FILTRULE_WILD2_PREFIX	(1<<2) /* pattern starts with "**" */
++#define FILTRULE_WILD3_SUFFIX	(1<<3) /* pattern ends with "***" */
++#define FILTRULE_ABS_PATH	(1<<4) /* path-match on absolute path */
++#define FILTRULE_INCLUDE	(1<<5) /* this is an include, not an exclude */
++#define FILTRULE_DIRECTORY	(1<<6) /* this matches only directories */
++#define FILTRULE_WORD_SPLIT	(1<<7) /* split rules on whitespace */
++#define FILTRULE_NO_INHERIT	(1<<8) /* don't inherit these rules */
++#define FILTRULE_NO_PREFIXES	(1<<9) /* parse no prefixes from patterns */
++#define FILTRULE_MERGE_FILE	(1<<10)/* specifies a file to merge */
++#define FILTRULE_PERDIR_MERGE	(1<<11)/* merge-file is searched per-dir */
++#define FILTRULE_EXCLUDE_SELF	(1<<12)/* merge-file name should be excluded */
++#define FILTRULE_FINISH_SETUP	(1<<13)/* per-dir merge file needs setup */
++#define FILTRULE_NEGATE 	(1<<14)/* rule matches when pattern does not */
++#define FILTRULE_CVS_IGNORE	(1<<15)/* rule was -C or :C */
++#define FILTRULE_SENDER_SIDE	(1<<16)/* rule applies to the sending side */
++#define FILTRULE_RECEIVER_SIDE	(1<<17)/* rule applies to the receiving side */
++#define FILTRULE_CLEAR_LIST	(1<<18)/* this item is the "!" token */
++#define FILTRULE_PERISHABLE	(1<<19)/* perishable if parent dir goes away */
++#define FILTRULE_XATTR		(1<<20)/* rule only applies to xattr names */
++
++#define FILTRULES_SIDES (FILTRULE_SENDER_SIDE | FILTRULE_RECEIVER_SIDE)
++
++typedef struct filter_struct {
++	struct filter_struct *next;
++	char *pattern;
++	uint32 rflags;
++	union {
++		int slash_cnt;
++		struct filter_list_struct *mergelist;
++	} u;
++	uchar elide;
++} filter_rule;
++
++typedef struct filter_list_struct {
++	filter_rule *head;
++	filter_rule *tail;
++	char *debug_type;
++} filter_rule_list;
++
++struct stats {
++	int64 total_size;
++	int64 total_transferred_size;
++	int64 total_written;
++	int64 total_read;
++	int64 literal_data;
++	int64 matched_data;
++	int64 flist_buildtime;
++	int64 flist_xfertime;
++	int64 flist_size;
++	int num_files, num_dirs, num_symlinks, num_devices, num_specials;
++	int created_files, created_dirs, created_symlinks, created_devices, created_specials;
++	int deleted_files, deleted_dirs, deleted_symlinks, deleted_devices, deleted_specials;
++	int xferred_files;
++};
++
++struct chmod_mode_struct;
++
++struct flist_ndx_item {
++	struct flist_ndx_item *next;
++	int ndx;
++};
++
++typedef struct {
++	struct flist_ndx_item *head, *tail;
++} flist_ndx_list;
++
++#define EMPTY_ITEM_LIST {NULL, 0, 0}
++
++typedef struct {
++	void *items;
++	size_t count;
++	size_t malloced;
++} item_list;
++
++#define EXPAND_ITEM_LIST(lp, type, incr) \
++	(type*)expand_item_list(lp, sizeof (type), #type, incr)
++
++#define EMPTY_XBUF {NULL, 0, 0, 0}
++
++typedef struct {
++	char *buf;
++	size_t pos;  /* pos = read pos in the buf */
++	size_t len;  /* len = chars following pos */
++	size_t size; /* size = total space in buf */
++} xbuf;
++
++#define INIT_XBUF(xb, str, ln, sz) (xb).buf = (str), (xb).len = (ln), (xb).size = (sz), (xb).pos = 0
++#define INIT_XBUF_STRLEN(xb, str) (xb).buf = (str), (xb).len = strlen((xb).buf), (xb).size = (size_t)-1, (xb).pos = 0
++/* This one is used to make an output xbuf based on a char[] buffer: */
++#define INIT_CONST_XBUF(xb, bf) (xb).buf = (bf), (xb).size = sizeof (bf), (xb).len = (xb).pos = 0
++
++#define ICB_EXPAND_OUT (1<<0)
++#define ICB_INCLUDE_BAD (1<<1)
++#define ICB_INCLUDE_INCOMPLETE (1<<2)
++#define ICB_CIRCULAR_OUT (1<<3)
++#define ICB_INIT (1<<4)
++
++#define IOBUF_KEEP_BUFS 0
++#define IOBUF_FREE_BUFS 1
++
++#define MPLX_SWITCHING IOBUF_KEEP_BUFS
++#define MPLX_ALL_DONE IOBUF_FREE_BUFS
++#define MPLX_TO_BUFFERED 2
++
++#define RL_EOL_NULLS (1<<0)
++#define RL_DUMP_COMMENTS (1<<1)
++#define RL_CONVERT (1<<2)
++
++typedef struct {
++	char name_type;
++#ifdef USE_FLEXIBLE_ARRAY
++	char fname[]; /* has variable size */
++#else
++	char fname[1]; /* A kluge that should work like a flexible array */
++#endif
++} relnamecache;
++
++#ifdef USE_FLEXIBLE_ARRAY
++#define RELNAMECACHE_LEN (sizeof (relnamecache))
++#else
++#define RELNAMECACHE_LEN (offsetof(relnamecache, fname))
++#endif
++
++#include "byteorder.h"
++#include "lib/mdigest.h"
++#include "lib/wildmatch.h"
++#include "lib/permstring.h"
++#include "lib/addrinfo.h"
++
++#ifndef __GNUC__
++#define __attribute__(x)
++#else
++# if __GNUC__ <= 2
++# define NORETURN
++# endif
++#endif
++
++#define UNUSED(x) x __attribute__((__unused__))
++#ifndef NORETURN
++#define NORETURN __attribute__((__noreturn__))
++#endif
++
++typedef struct {
++    STRUCT_STAT st;
++    time_t crtime;
++#ifdef SUPPORT_ACLS
++    struct rsync_acl *acc_acl; /* access ACL */
++    struct rsync_acl *def_acl; /* default ACL */
++#endif
++#ifdef SUPPORT_XATTRS
++    item_list *xattr;
++#endif
++} stat_x;
++
++#define ACL_READY(sx) ((sx).acc_acl != NULL)
++#define XATTR_READY(sx) ((sx).xattr != NULL)
++
++#define CLVL_NOT_SPECIFIED INT_MIN
++
++#define CPRES_AUTO (-1)
++#define CPRES_NONE 0
++#define CPRES_ZLIB 1
++#define CPRES_ZLIBX 2
++#define CPRES_LZ4 3
++#define CPRES_ZSTD 4
++
++#define NSTR_CHECKSUM 0
++#define NSTR_COMPRESS 1
++
++struct name_num_item {
++	int num, flags;
++	const char *name;
++	struct name_num_item *main_nni;
++};
++
++struct name_num_obj {
++	const char *type;
++	struct name_num_item *negotiated_nni;
++	uchar *saw;
++	int saw_len;
++	struct name_num_item *list;
++};
++
++#ifdef EXTERNAL_ZLIB
++#define read_buf read_buf_
++#endif
++
++#ifndef __cplusplus
++#include "proto.h"
++#endif
++
++#ifndef SUPPORT_XATTRS
++#define x_stat(fn,fst,xst) do_stat(fn,fst)
++#define x_lstat(fn,fst,xst) do_lstat(fn,fst)
++#define x_fstat(fd,fst,xst) do_fstat(fd,fst)
++#endif
++
++/* We have replacement versions of these if they're missing. */
++#ifndef HAVE_ASPRINTF
++int asprintf(char **ptr, const char *format, ...);
++#endif
++
++#ifndef HAVE_VASPRINTF
++int vasprintf(char **ptr, const char *format, va_list ap);
++#endif
++
++#if !defined HAVE_VSNPRINTF || !defined HAVE_C99_VSNPRINTF
++#define vsnprintf rsync_vsnprintf
++int vsnprintf(char *str, size_t count, const char *fmt, va_list args);
++#endif
++
++#if !defined HAVE_SNPRINTF || !defined HAVE_C99_VSNPRINTF
++#define snprintf rsync_snprintf
++int snprintf(char *str, size_t count, const char *fmt,...);
++#endif
++
++#ifndef HAVE_STRERROR
++extern char *sys_errlist[];
++#define strerror(i) sys_errlist[i]
++#endif
++
++#ifndef HAVE_STRCHR
++# define strchr                 index
++# define strrchr                rindex
++#endif
++
++#ifndef HAVE_ERRNO_DECL
++extern int errno;
++#endif
++
++#ifdef HAVE_READLINK
++#define SUPPORT_LINKS 1
++#if !defined NO_SYMLINK_XATTRS && !defined NO_SYMLINK_USER_XATTRS
++#define do_readlink(path, buf, bufsiz) readlink(path, buf, bufsiz)
++#endif
++#endif
++#ifdef HAVE_LINK
++#define SUPPORT_HARD_LINKS 1
++#endif
++
++#ifdef HAVE_SIGACTION
++#define SIGACTION(n,h) sigact.sa_handler=(h), sigaction((n),&sigact,NULL)
++#define signal(n,h) we_need_to_call_SIGACTION_not_signal(n,h)
++#else
++#define SIGACTION(n,h) signal(n,h)
++#endif
++
++#ifndef EWOULDBLOCK
++#define EWOULDBLOCK EAGAIN
++#endif
++
++#ifndef STDIN_FILENO
++#define STDIN_FILENO 0
++#endif
++
++#ifndef STDOUT_FILENO
++#define STDOUT_FILENO 1
++#endif
++
++#ifndef STDERR_FILENO
++#define STDERR_FILENO 2
++#endif
++
++#ifndef S_IRUSR
++#define S_IRUSR 0400
++#endif
++
++#ifndef S_IWUSR
++#define S_IWUSR 0200
++#endif
++
++#ifndef ACCESSPERMS
++#define ACCESSPERMS 0777
++#endif
++
++#ifndef S_ISVTX
++#define S_ISVTX 0
++#endif
++
++#define CHMOD_BITS (S_ISUID | S_ISGID | S_ISVTX | ACCESSPERMS)
++
++#ifndef _S_IFMT
++#define _S_IFMT        0170000
++#endif
++
++#ifndef _S_IFLNK
++#define _S_IFLNK  0120000
++#endif
++
++#ifndef S_ISLNK
++#define S_ISLNK(mode) (((mode) & (_S_IFMT)) == (_S_IFLNK))
++#endif
++
++#ifndef S_ISBLK
++#define S_ISBLK(mode) (((mode) & (_S_IFMT)) == (_S_IFBLK))
++#endif
++
++#ifndef S_ISCHR
++#define S_ISCHR(mode) (((mode) & (_S_IFMT)) == (_S_IFCHR))
++#endif
++
++#ifndef S_ISSOCK
++#ifdef _S_IFSOCK
++#define S_ISSOCK(mode) (((mode) & (_S_IFMT)) == (_S_IFSOCK))
++#else
++#define S_ISSOCK(mode) (0)
++#endif
++#endif
++
++#ifndef S_ISFIFO
++#ifdef _S_IFIFO
++#define S_ISFIFO(mode) (((mode) & (_S_IFMT)) == (_S_IFIFO))
++#else
++#define S_ISFIFO(mode) (0)
++#endif
++#endif
++
++#ifndef S_ISDIR
++#define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))
++#endif
++
++#ifndef S_ISREG
++#define S_ISREG(mode) (((mode) & (_S_IFMT)) == (_S_IFREG))
++#endif
++
++/* work out what fcntl flag to use for non-blocking */
++#ifdef O_NONBLOCK
++# define NONBLOCK_FLAG O_NONBLOCK
++#elif defined SYSV
++# define NONBLOCK_FLAG O_NDELAY
++#else
++# define NONBLOCK_FLAG FNDELAY
++#endif
++
++#ifndef INADDR_LOOPBACK
++#define INADDR_LOOPBACK 0x7f000001
++#endif
++
++#ifndef INADDR_NONE
++#define INADDR_NONE 0xffffffff
++#endif
++
++#define IS_SPECIAL(mode) (S_ISSOCK(mode) || S_ISFIFO(mode))
++#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode))
++
++/* Initial mask on permissions given to temporary files.  Mask off setuid
++     bits and group access because of potential race-condition security
++     holes, and mask other access because mode 707 is bizarre */
++#define INITACCESSPERMS 0700
++
++/* handler for null strings in printf format */
++#define NS(s) ((s)?(s):"<NULL>")
++
++extern char *do_calloc;
++
++/* Convenient wrappers for malloc and realloc.  Use them. */
++#define new(type) ((type*)my_alloc(NULL, sizeof (type), 1, __FILE__, __LINE__))
++#define new0(type) ((type*)my_alloc(do_calloc, sizeof (type), 1, __FILE__, __LINE__))
++#define realloc_buf(ptr, num) my_alloc((ptr), (num), 1, __FILE__, __LINE__)
++
++#define new_array(type, num) ((type*)my_alloc(NULL, (num), sizeof (type), __FILE__, __LINE__))
++#define new_array0(type, num) ((type*)my_alloc(do_calloc, (num), sizeof (type), __FILE__, __LINE__))
++#define realloc_array(ptr, type, num) ((type*)my_alloc((ptr), (num), sizeof (type), __FILE__, __LINE__))
++
++#undef strdup
++#define strdup(s) my_strdup(s, __FILE__, __LINE__)
++
++#define out_of_memory(msg) _out_of_memory(msg, __FILE__, __LINE__)
++#define overflow_exit(msg) _overflow_exit(msg, __FILE__, __LINE__)
++
++/* use magic gcc attributes to catch format errors */
++ void rprintf(enum logcode , const char *, ...)
++     __attribute__((format (printf, 2, 3)))
++;
++
++/* This is just like rprintf, but it also tries to print some
++ * representation of the error code.  Normally errcode = errno. */
++void rsyserr(enum logcode, int, const char *, ...)
++     __attribute__((format (printf, 3, 4)))
++     ;
++
++/* Make sure that the O_BINARY flag is defined. */
++#ifndef O_BINARY
++#define O_BINARY 0
++#endif
++
++#ifndef HAVE_STRLCPY
++size_t strlcpy(char *d, const char *s, size_t bufsize);
++#endif
++
++#ifndef HAVE_STRLCAT
++size_t strlcat(char *d, const char *s, size_t bufsize);
++#endif
++
++#ifndef WEXITSTATUS
++#define	WEXITSTATUS(stat)	((int)(((stat)>>8)&0xFF))
++#endif
++#ifndef WIFEXITED
++#define	WIFEXITED(stat)		((int)((stat)&0xFF) == 0)
++#endif
++
++#define exit_cleanup(code) _exit_cleanup(code, __FILE__, __LINE__)
++
++#ifdef HAVE_GETEUID
++#define MY_UID() geteuid()
++#else
++#define MY_UID() getuid()
++#endif
++
++#ifdef HAVE_GETEGID
++#define MY_GID() getegid()
++#else
++#define MY_GID() getgid()
++#endif
++
++#ifdef FORCE_FD_ZERO_MEMSET
++#undef FD_ZERO
++#define FD_ZERO(fdsetp) memset(fdsetp, 0, sizeof (fd_set))
++#endif
++
++extern short info_levels[], debug_levels[];
++
++#define INFO_GTE(flag, lvl) (info_levels[INFO_##flag] >= (lvl))
++#define INFO_EQ(flag, lvl) (info_levels[INFO_##flag] == (lvl))
++#define DEBUG_GTE(flag, lvl) (debug_levels[DEBUG_##flag] >= (lvl))
++#define DEBUG_EQ(flag, lvl) (debug_levels[DEBUG_##flag] == (lvl))
++
++#define INFO_BACKUP 0
++#define INFO_COPY (INFO_BACKUP+1)
++#define INFO_DEL (INFO_COPY+1)
++#define INFO_FLIST (INFO_DEL+1)
++#define INFO_MISC (INFO_FLIST+1)
++#define INFO_MOUNT (INFO_MISC+1)
++#define INFO_NAME (INFO_MOUNT+1)
++#define INFO_NONREG (INFO_NAME+1)
++#define INFO_PROGRESS (INFO_NONREG+1)
++#define INFO_REMOVE (INFO_PROGRESS+1)
++#define INFO_SKIP (INFO_REMOVE+1)
++#define INFO_STATS (INFO_SKIP+1)
++#define INFO_SYMSAFE (INFO_STATS+1)
++
++#define COUNT_INFO (INFO_SYMSAFE+1)
++
++#define DEBUG_ACL 0
++#define DEBUG_BACKUP (DEBUG_ACL+1)
++#define DEBUG_BIND (DEBUG_BACKUP+1)
++#define DEBUG_CHDIR (DEBUG_BIND+1)
++#define DEBUG_CONNECT (DEBUG_CHDIR+1)
++#define DEBUG_CMD (DEBUG_CONNECT+1)
++#define DEBUG_DEL (DEBUG_CMD+1)
++#define DEBUG_DELTASUM (DEBUG_DEL+1)
++#define DEBUG_DUP (DEBUG_DELTASUM+1)
++#define DEBUG_EXIT (DEBUG_DUP+1)
++#define DEBUG_FILTER (DEBUG_EXIT+1)
++#define DEBUG_FLIST (DEBUG_FILTER+1)
++#define DEBUG_FUZZY (DEBUG_FLIST+1)
++#define DEBUG_GENR (DEBUG_FUZZY+1)
++#define DEBUG_HASH (DEBUG_GENR+1)
++#define DEBUG_HLINK (DEBUG_HASH+1)
++#define DEBUG_ICONV (DEBUG_HLINK+1)
++#define DEBUG_IO (DEBUG_ICONV+1)
++#define DEBUG_NSTR (DEBUG_IO+1)
++#define DEBUG_OWN (DEBUG_NSTR+1)
++#define DEBUG_PROTO (DEBUG_OWN+1)
++#define DEBUG_RECV (DEBUG_PROTO+1)
++#define DEBUG_SEND (DEBUG_RECV+1)
++#define DEBUG_TIME (DEBUG_SEND+1)
++
++#define COUNT_DEBUG (DEBUG_TIME+1)
++
++#ifndef HAVE_INET_NTOP
++const char *inet_ntop(int af, const void *src, char *dst, size_t size);
++#endif
++
++#ifndef HAVE_INET_PTON
++int inet_pton(int af, const char *src, void *dst);
++#endif
++
++#ifndef HAVE_GETPASS
++char *getpass(const char *prompt);
++#endif
++
++#ifdef MAINTAINER_MODE
++const char *get_panic_action(void);
++#endif
++
++#define NOISY_DEATH(msg) do { \
++    fprintf(stderr, "%s in %s at line %d\n", msg, __FILE__, __LINE__); \
++    exit_cleanup(RERR_UNSUPPORTED); \
++} while (0)
++
++#ifdef HAVE_MALLINFO2
++#define MEM_ALLOC_INFO mallinfo2
++#elif defined HAVE_MALLINFO
++#define MEM_ALLOC_INFO mallinfo
++#endif
+diff --git a/syscall.c b/syscall.c
+index d92074aa..ba24c9d4 100644
+--- a/syscall.c
++++ b/syscall.c
+@@ -146,6 +146,54 @@ int do_link(const char *old_path, const char *new_path)
+ }
+ #endif
+ 
++int do_clone(const char *old_path, const char *new_path, mode_t mode)
++{
++#ifdef FICLONE
++	int ifd, ofd, ret, save_errno;
++
++	if (dry_run) return 0;
++	RETURN_ERROR_IF_RO_OR_LO;
++
++	if ((ifd = do_open(old_path, O_RDONLY, 0)) < 0) {
++		save_errno = errno;
++		rsyserr(FERROR_XFER, errno, "open %s", full_fname(old_path));
++		errno = save_errno;
++		return -1;
++	}
++
++	if (robust_unlink(new_path) && errno != ENOENT) {
++		save_errno = errno;
++		rsyserr(FERROR_XFER, errno, "unlink %s", full_fname(new_path));
++		close(ifd);
++		errno = save_errno;
++		return -1;
++	}
++
++	mode &= INITACCESSPERMS;
++	if ((ofd = do_open(new_path, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0) {
++		save_errno = errno;
++		rsyserr(FERROR_XFER, save_errno, "open %s", full_fname(new_path));
++		close(ifd);
++		errno = save_errno;
++		return -1;
++	}
++
++	ret = ioctl(ofd, FICLONE, ifd);
++	save_errno = errno;
++	close(ifd);
++	close(ofd);
++	if (ret < 0)
++		unlink(new_path);
++	errno = save_errno;
++	return ret;
++#else
++	(void)old_path;
++	(void)new_path;
++	errno = ENOTSUP;
++	return -1;
++#endif
++}
++
+ int do_lchown(const char *path, uid_t owner, gid_t group)
+ {
+ 	if (dry_run) return 0;
+diff --git a/t_stub.c b/t_stub.c
+index 085378a8..55ff51c1 100644
+--- a/t_stub.c
++++ b/t_stub.c
+@@ -38,6 +38,7 @@ size_t max_alloc = 0; /* max_alloc is needed when combined with util2.o */
+ char *partial_dir;
+ char *module_dir;
+ filter_rule_list daemon_filter_list;
++short info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];
+ 
+  void rprintf(UNUSED(enum logcode code), const char *format, ...)
+ {
+diff --git a/t_unsafe.c b/t_unsafe.c
+index 010cac50..09d7d381 100644
+--- a/t_unsafe.c
++++ b/t_unsafe.c
+@@ -28,7 +28,6 @@ int am_root = 0;
+ int am_sender = 1;
+ int read_only = 0;
+ int list_only = 0;
+-short info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];
+ 
+ int
+ main(int argc, char **argv)
+diff --git a/util1.c b/util1.c
+index da50ff1e..906addd3 100644
+--- a/util1.c
++++ b/util1.c
+@@ -183,7 +183,7 @@ int set_times(const char *fname, STRUCT_STAT *stp)
+ /* Create any necessary directories in fname.  Any missing directories are
+  * created with default permissions.  Returns < 0 on error, or the number
+  * of directories created. */
+-int make_path(char *fname, int flags)
++int make_path(char *fname, mode_t mode, int flags)
+ {
+ 	char *end, *p;
+ 	int ret = 0;
+@@ -214,7 +214,7 @@ int make_path(char *fname, int flags)
+ 				else
+ 					errno = ENOTDIR;
+ 			}
+-		} else if (do_mkdir(fname, ACCESSPERMS) == 0) {
++		} else if (do_mkdir(fname, mode) == 0) {
+ 			ret++;
+ 			break;
+ 		}
+@@ -253,7 +253,7 @@ int make_path(char *fname, int flags)
+ 		p += strlen(p);
+ 		if (ret < 0) /* Skip mkdir on error, but keep restoring the path. */
+ 			continue;
+-		if (do_mkdir(fname, ACCESSPERMS) < 0)
++		if (do_mkdir(fname, mode) < 0)
+ 			ret = -ret - 1;
+ 		else
+ 			ret++;
+@@ -1196,6 +1196,32 @@ char *normalize_path(char *path, BOOL force_newbuf, unsigned int *len_ptr)
+ 	return path;
+ }
+ 
++/* We need to supply our own strcmp function for file list comparisons
++ * to ensure that signed/unsigned usage is consistent between machines. */
++int u_strcmp(const char *p1, const char *p2)
++{
++        for ( ; *p1; p1++, p2++) {
++		if (*p1 != *p2)
++			break;
++	}
++
++	return (int)*(uchar*)p1 - (int)*(uchar*)p2;
++}
++
++/* We need a memcmp function compares unsigned-byte values. */
++int u_memcmp(const void *p1, const void *p2, size_t len)
++{
++	const uchar *u1 = p1;
++	const uchar *u2 = p2;
++
++	while (len--) {
++		if (*u1 != *u2)
++			return (int)*u1 - (int)*u2;
++	}
++
++	return 0;
++}
++
+ /**
+  * Return a quoted string with the full pathname of the indicated filename.
+  * The string " (in MODNAME)" may also be appended.  The returned pointer
+@@ -1289,7 +1315,7 @@ int handle_partial_dir(const char *fname, int create)
+ 			}
+ 			statret = -1;
+ 		}
+-		if (statret < 0 && do_mkdir(dir, 0700) < 0) {
++		if (statret < 0 && make_path(dir, 0700, 0) < 0) {
+ 			*fn = '/';
+ 			return 0;
+ 		}
+
diff --git a/rsync.spec b/rsync.spec
index dfff14e..bf3d625 100644
--- a/rsync.spec
+++ b/rsync.spec
@@ -13,13 +13,14 @@ Release: 2%{?prerelease}%{?dist}
 URL: https://rsync.samba.org/
 
 Source0: https://download.samba.org/pub/rsync/src/rsync-%{version}%{?prerelease}.tar.gz
-Source1: https://download.samba.org/pub/rsync/src/rsync-patches-%{version}%{?prerelease}.tar.gz
 Source2: rsyncd.socket
 Source3: rsyncd.service
 Source4: rsyncd.conf
 Source5: rsyncd.sysconfig
 Source6: rsyncd@.service
 
+Patch: detect-renamed-and-clone-dest.diff
+
 BuildRequires: make
 BuildRequires: gcc
 BuildRequires: gcc-c++
@@ -73,9 +74,6 @@ package provides the anonymous rsync service.
 
 %patch 1 -p1 -b .runtests
 
-patch -p1 -i patches/detect-renamed.diff
-patch -p1 -i patches/detect-renamed-lax.diff
-
 %build
 %configure \
   --enable-openssl \
